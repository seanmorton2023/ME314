

TO-DO
Helpers
- SE3_ddt(): takes derivative of SE(3) matrix
- SO3_ddt(): takes derivative of SO(3) matrix

Main Event
- make symbolic variables
- use transformation matrices to find positions of things
- define Lagrangian 
- set up constrained + forced Euler-Lagrange EQs
- Solve the above
- attach plot of how I defined my trans. matrices


Functions I will need for:
- matrix math: already written for this hw
- computing Lagrangian:
	- 
- Euler-Lagrange:
	- compute_EL
	- solve_constrained_EL
	- simulate()
	- rk4()
- Animation:
	- simulate_biped()
		- modify the single pendulum animation


Major errors:
- system isn't starting at the right theta1, theta2, ... thetan
- system is dividing by 0
	- explainable by the fact I have sines in my denominator - 
		prof said that wasn't the right form
- shape of output is wrong: each "row" is 2D, not a 1D vector
- will need to find another way to test the animation function
	w/ expected output
		- find the shape of the output we need + reasonable
			values for each var; make an interpolated array
			based on it and test with that




**it may be a good idea to use dictionaries for the state
	vector - with 8 extended variables the possibility
	of error grows**



questions for Prof:
- for homework question 1: you mentioned we don't need to
	use omegahat in the explanation. how do we take the derivative
	of R if we don't use e^omegahat?
		-2-line statement
		- don't need matrix component
		- think about properties of SO(n) and there aren't
			a lot of choices
- can you explain why theta1 and theta1d have to be 
	replaced with symbolic variables for calculating forces?
		- may or may not be needed; it's Jake's work
		- if I don't have it working, can test with
			single pendulum with torques applied at base
		- recommends I check this by looking at results:
			get theta1dd and sin^2(t/2) terms
		
- why do we need to use the body velocity in R6?
	- if we need the time derivative of omega, will that be
		a function of t or a symbolic substitution for thetad?
		- see answer to above question
		
	- generally more convenient to write this down in terms
		of 3d motions; omega needed
- one of the hints is: "Be careful to consider the relationship 
	between the frames and to not build in any implicit assumptions 
	(such as assuming some variables are fixed)." My question is:
	does this refer to state variables, or things like the inertia
	matrix?		
		- don't assume pivot point is on the y axis; 
			pivot has a position in both x and y
		- if things are working it'll do a split; if things
			are not working robot may fall over
- given that J is a constant, I never ended up using W in my
	calculations. Was I supposed to, or is that only there 
	for animation?
		- 
- code question: my lambdify call isn't substituting t properly-
	it's the only symbolic variable that's type Symbol, not
	type Function(t). any thoughts?
		- recommends I not haul around a symbolic variable
			representation of t
		- don't append t onto the state array; don't lambdify
			with respect to t
		- also recommends making a micro-example where a single
			pend is forced by an external torque, then post about
			it on a discussion board. said it should only take a few
			minutes. and Jake will be happy to answer non-homework
			problems in extreme depth
		- a thought I had: if I want to try again with
			the lambdify() version where we calculate using t,
			could make ti a type Function(t), and then lambdify
			after. if this works and gives good results, may not
			need to go through as much effort in making an example
			to test with
		
- a note: while talking about how the problem has a dependence
	on sin^2(t), he said that there shouldn't be sin^2t in the
	denominator - since it's a force and only on the "Right hand side",
	sin^t(t) term should only be in numerator. masses, inertia,
	will all potentially be in the denominator
	






	
Done
- SO2AndR2toSE2(): done
- SO3AndR3toSE3() helper to create transf. matrices
	- possible error: sending p in as a numpy array
- HatVector(): turns a R2 or R3 vcetor to a so(2) or so(3) matrix
- UnhatMatrix(): turns a so(3) or so(2) matric to a R3 or R2 vector
- InvSE3() matrix: helper to compute inverse of a transformation matrix






Notes

based on interpretation of the problem notes, way to do the problem is
- cannot solve for t = __ during the solving for theta at a given point
	in time bc theta and thetad depend on t
- modify RK4 to take a dependence on t as well, like in HW1
	- simulate(), integrate(), and dxdt() need to pass t to rk4 as well
	- already have the framework for this 
- use the solve_constrained_EL() equation and modify:
	- modify so we can combine with a matrix of forcing
	- make a new dummy variable t_i that uses the current point
		in time for computing forcing
		
		
		




#save these for later

def SE3_ddt(SE3mat):
    '''Takes the derivative of a matrix in SE(3).
    '''
    pass

def SO3_ddt(SO3mat):
    '''Takes the derivative of a matrix in SO(3).
    '''
    pass

def InertiaMatrix(rho, r_b, volume_limits, w):
    '''Calculates the Inertia Matrix for a given volume of material.
    '''
    pass