

TO-DO
Helpers
- SE3_ddt(): takes derivative of SE(3) matrix
- SO3_ddt(): takes derivative of SO(3) matrix

Main Event
- make symbolic variables
- use transformation matrices to find positions of things
- define Lagrangian 
- set up constrained + forced Euler-Lagrange EQs
- Solve the above
- attach plot of how I defined my trans. matrices


Functions I will need for:
- matrix math: already written for this hw
- computing Lagrangian:
	- 
- Euler-Lagrange:
	- compute_EL
	- solve_constrained_EL
	- simulate()
	- rk4()
- Animation:
	- simulate_biped()
		- modify the single pendulum animation

**it may be a good idea to use dictionaries for the state
	vector - with 8 extended variables the possibility
	of error grows**



questions for Prof:
- for homework question 1: you mentioned we don't need to
	use omegahat in the explanation. how do we take the derivative
	of R if we don't use e^omegahat?
- can you explain why theta1 and theta1d have to be 
	replaced with symbolic variables for calculating forces?
- why do we need to use the body velocity in R6?
	- if we need the time derivative of omega, will that be
		a function of t or a symbolic substitution for thetad?
- one of the hints is: "Be careful to consider the relationship 
	between the frames and to not build in any implicit assumptions 
	(such as assuming some variables are fixed)." My question is:
	does this refer to state variables, or things like the inertia
	matrix?
- given that J is a constant, I never ended up using W in my
	calculations. Was I supposed to, or is that only there 
	for animation?
	






	
Done
- SO2AndR2toSE2(): done
- SO3AndR3toSE3() helper to create transf. matrices
	- possible error: sending p in as a numpy array
- HatVector(): turns a R2 or R3 vcetor to a so(2) or so(3) matrix
- UnhatMatrix(): turns a so(3) or so(2) matric to a R3 or R2 vector
- InvSE3() matrix: helper to compute inverse of a transformation matrix






Notes

based on interpretation of the problem notes, way to do the problem is
- cannot solve for t = __ during the solving for theta at a given point
	in time bc theta and thetad depend on t
- modify RK4 to take a dependence on t as well, like in HW1
	- simulate(), integrate(), and dxdt() need to pass t to rk4 as well
	- already have the framework for this 
- use the solve_constrained_EL() equation and modify:
	- modify so we can combine with a matrix of forcing
	- make a new dummy variable t_i that uses the current point
		in time for computing forcing
		
		
		




#save these for later

def SE3_ddt(SE3mat):
    '''Takes the derivative of a matrix in SE(3).
    '''
    pass

def SO3_ddt(SO3mat):
    '''Takes the derivative of a matrix in SO(3).
    '''
    pass

def InertiaMatrix(rho, r_b, volume_limits, w):
    '''Calculates the Inertia Matrix for a given volume of material.
    '''
    pass