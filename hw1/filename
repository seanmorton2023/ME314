 1/1:
import numpy as np
zeroMat=np.zeros((3,2))
print(zeroMat)
a=1
 1/2:
import numpy as np
zeroMat=np.zeros((3,2))
print(zeroMat)
a=1
 3/1: print(merge)
 4/1:
from sqlalchemy import create_engine
from sqlalchemy.sql import text
import urllib
import pandas as pd
pd.set_option('display.max_rows', 500)
pd.set_option('display.max_columns', 500)
pd.set_option('display.width', 1000)
import tkinter as tk
from tkinter import filedialog
import datetime
import csv
 5/1:
from sqlalchemy import create_engine
from sqlalchemy.sql import text
import urllib
import pandas as pd
pd.set_option('display.max_rows', 500)
pd.set_option('display.max_columns', 500)
pd.set_option('display.width', 1000)
import tkinter as tk
from tkinter import filedialog
import datetime
import csv
 5/2:
root = tk.Tk()
root.withdraw()
 5/3: params = urllib.parse.quote_plus("DRIVER={SQL Server};SERVER=34.85.144.245;PORT=1433;DATABASE=budmarysdata;UID=sqlserver;PWD=oozafaF4;Trusted_Connection=no;")
 5/4: engine = create_engine("mssql+pyodbc:///?odbc_connect=%s" % params)
 6/1:
from sqlalchemy import create_engine
from sqlalchemy.sql import text
import urllib
import pandas as pd
pd.set_option('display.max_rows', 500)
pd.set_option('display.max_columns', 500)
pd.set_option('display.width', 1000)
import tkinter as tk
from tkinter import filedialog
import datetime
import csv
 6/2:
root = tk.Tk()
root.withdraw()
 6/3: params = urllib.parse.quote_plus("DRIVER={SQL Server};SERVER=34.85.144.245;PORT=1433;DATABASE=budmarysdata;UID=sqlserver;PWD=oozafaF4;Trusted_Connection=no;")
 6/4: engine = create_engine("mssql+pyodbc:///?odbc_connect=%s" % params)
 6/5: con = engine.connect()
10/1:
A = np.array([[1.,2.,3.],[4.,5.,6.],[7.,8.,9.]])
print(A)
10/2:
import numpy as me314_np
import numpy as np
import sympy as sym

print("check sympy version to make sure it's newer than 1.6: ", sym.__version__)

# This command below is a type of command that's unique to Jupyter notebooks, 
# it tells the notebook how to display plotsfrom matplotlib. Don't mess with it.
%matplotlib inline 
import matplotlib.pyplot as plt
10/3:
import numpy as me314_np
import numpy as np
import sympy as sym

print("check sympy version to make sure it's newer than 1.6: ", sym.__version__)

# This command below is a type of command that's unique to Jupyter notebooks, 
# it tells the notebook how to display plotsfrom matplotlib. Don't mess with it.
%matplotlib inline 
import matplotlib.pyplot as plt
10/4:
def custom_latex_printer(exp,**options):
    from google.colab.output._publish import javascript
    url = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=default"
    javascript(url=url)
    return sym.printing.latex(exp,**options)
sym.init_printing(use_latex="mathjax",latex_printer=custom_latex_printer)
10/5:
A = np.array([[1.,2.,3.],[4.,5.,6.],[7.,8.,9.]])
print(A)
10/6: print(A[0,1])
10/7:
# things are even more interesting on vectors
a = np.array([1, 2, 3])
b = np.array([1, 2, 3])

# element-wise multiplication
print(a * b)

# Matrix multiplication between a 1-by-3 vector and a 3-by-1 vector
print(a.dot(b))

# Matrix multiplication between a 3-by-1 vector and a 1-by-3 vector
print(np.outer(a,b))
print(a.reshape(3,1) * b)
10/8:
from numpy import pi, cos, sin

def my_tan(a):
    return sin(a) / cos(a)

print('my_tan(pi) =', my_tan(pi))
print('type of the output: ', type(my_tan(pi)))
10/9:
from sympy import pi, cos, sin

def my_tan(a):
    return sin(a) / cos(a)

print('my_tan(pi) =', my_tan(pi))
print('type of the output: ', type(my_tan(pi)))
10/10:
def add_one(a):
    return [a[0]+1, a[1]+1]

a = [1, 2]
print('a =', a)
print('add_one(a) =', add_one(a))
print('a =', a)
10/11:
def add_one(a):
    b = [0, 0]
    b[0] = a[0] + 1
    b[1] = a[1] + 1
    return b

a = [1, 2]
print('a =', a)
print('add_one(a) =', add_one(a))
print('a =', a)
10/12:
a_list = [1, 2, 3]
an_array = np.array([1, 2, 3])
print('a_list + [1, 2, 3] =', a_list + [1, 2, 3])
print('an_array + [1, 2, 3] =', an_array + [1, 2, 3])
12/1:
import numpy as np
%matplotlib inline
import matplotlib.plt as pyplot
import pandas as pd
12/2:
import numpy as np
import matplotlib
%matplotlib inline
import matplotlib.plt as pyplot
import pandas as pd
12/3:
import numpy as np
import matplotlib
%matplotlib inline
import matplotlib.plt as pyplot
import pandas as pd
12/4:
import numpy as np
import matplotlib
%matplotlib inline
import matplotlib.plt as pyplot
import pandas as pd
12/5:
import numpy as np
import matplotlib
%matplotlib inline
import matplotlib.plt as pyplot
import pandas as pd
12/6:
import numpy as np
import matplotlib
%matplotlib inline
import matplotlib.pyplot as plt
import pandas as pd
12/7:
import numpy as np
%matplotlib inline
import matplotlib.pyplot as plt
import pandas as pd
13/1:
import numpy as np
%matplotlib inline
import matplotlib.pyplot as plt
import pandas as pd
13/2:
df = pd.read_csv(r"C:\Users\seanp\Downloads\Python Lessons\transactions.csv")
df
13/3:
df = pd.read_csv(r"C:\Users\seanp\Downloads\Python Lessons\transactions.csv")
df.head()
13/4:
df = pd.read_csv(r"C:\Users\seanp\Downloads\Python Lessons\transactions.csv")
df.head()
13/5:
df = pd.read_csv(r"C:\Users\seanp\Downloads\Python Lessons\transactions.csv")
df
13/6: df.columns()
13/7: df.columns
13/8:
for column in df.columns:
    print(column)
13/9:
for ind, column in enumerate(df.columns):
    print(column)
13/10:
for ind, column in enumerate(df.columns):
    print(ind, column)
13/11:
class Transaction:
    
    def __init__(self, date, orderSource):
        _date = date
        _orderSource = orderSource
        

class Customer:
    
    def __init__(self, name):
        _name = name
        _transactions = []
        _date_converted = ""

    #setter and getter for transactions
    #@property
    
    def add_transaction(Transaction):
        _transactions.append(Transaction)
    
    #... add methods that populate our person with data
13/12:
customers_list = []

for ind, row in df.iterrows():
    print(row)
    print(type(row))
    
    if ind >= 1:
        break
#     name = row[14]
#     date = row[10]
#     orderSource = row[22]
    #handle transaction data
13/13:
customers_list = []

for ind, row in df.iterrows():
    print(row[14])
    print(type(row))
    
    if ind >= 1:
        break
#     name = row[14]
#     date = row[10]
#     orderSource = row[22]
    #handle transaction data
13/14:
customers_list = []

for ind, row in df.iterrows():
    print(row[14])
    print(type(row))
    
    break
#     name = row[14]
#     date = row[10]
#     orderSource = row[22]
    #handle transaction data
13/15:
customers_list = []

for ind, row in df.iterrows():
    print(row[14])
    print(type(row))
    print(type(row[14]))
    break
#     name = row[14]
#     date = row[10]
#     orderSource = row[22]
    #handle transaction data
13/16:
customers_dict = {}

for ind, row in df.iterrows():

    #handle transaction data
    name = row[14]
    date = row[10]
    orderSource = row[22]
    t = Transaction(date, orderSource)
    
    #if we have a new customer, add to the list of customers
    if name not in customers_dict.keys():
        c = Customer(name)
        c.add_transaction(t)
        customers_dict[name] = c #key, value
        
    #otherwise, add a transaction to their name
    else:
        customers_dict[name].add_transaction(t)
13/17:
class Transaction:
    
    def __init__(self, date, orderSource):
        _date = date
        _orderSource = orderSource
        

class Customer:
    
    def __init__(self, name):
        _name = name
        _transactions = []
        _num_trans = 0
        _date_converted = ""

    #setter and getter for transactions
    #@property
    
    def add_transaction(self, Transaction):
        _transactions.append(Transaction)
        num_trans += 1
    
    #... add methods that populate our person with data
13/18:
customers_dict = {}

for ind, row in df.iterrows():

    #handle transaction data
    name = row[14]
    date = row[10]
    orderSource = row[22]
    t = Transaction(date, orderSource)
    
    #if we have a new customer, add to the list of customers
    if name not in customers_dict.keys():
        c = Customer(name)
        c.add_transaction(t)
        customers_dict[name] = c #key, value
        
    #otherwise, add a transaction to their name
    else:
        customers_dict[name].add_transaction(t)
13/19:
class Transaction:
    
    def __init__(self, date, orderSource):
        self._date = date
        self._orderSource = orderSource
        

class Customer:
    
    def __init__(self, name):
        self._name = name
        self._transactions = []
        self._num_trans = 0
        self._date_converted = ""

    #setter and getter for transactions
    #@property
    
    def add_transaction(self, Transaction):
        self._transactions.append(Transaction)
        self._num_trans += 1
    
    #... add methods that populate our person with data
13/20:
customers_dict = {}

for ind, row in df.iterrows():

    #handle transaction data
    name = row[14]
    date = row[10]
    orderSource = row[22]
    t = Transaction(date, orderSource)
    
    #if we have a new customer, add to the list of customers
    if name not in customers_dict.keys():
        c = Customer(name)
        c.add_transaction(t)
        customers_dict[name] = c #key, value
        
    #otherwise, add a transaction to their name
    else:
        customers_dict[name].add_transaction(t)
13/21:
class Transaction:
    
    def __init__(self, date, orderSource):
        self._date = date
        self._orderSource = orderSource
        

class Customer:
    
    def __init__(self, name):
        self._name = name
        self._transactions = []
        self._num_trans = 0
        self._date_converted = ""
    
    def add_transaction(self, Transaction):
        self._transactions.append(Transaction)
        self._num_trans += 1
        
    def get_trans(self): return self._transactions
    def get_num_trans(self): return self._num_trans
    
    #... add methods that populate our person with data
13/22:
customers_dict = {}

for ind, row in df.iterrows():

    #handle transaction data
    name = row[14]
    date = row[10]
    orderSource = row[22]
    t = Transaction(date, orderSource)
    
    #if we have a new customer, add to the list of customers
    if name not in customers_dict.keys():
        c = Customer(name)
        c.add_transaction(t)
        customers_dict[name] = c #key, value
        
    #otherwise, add a transaction to their name
    else:
        customers_dict[name].add_transaction(t)
13/23:
total_transactions = 0
for k, v in customers_dict.iteritems():
    total_transactions += v.get_num_trans()
    
assert total_transactions == 22473
13/24:
total_transactions = 0
for k, v in customers_dict.items():
    total_transactions += v.get_num_trans()
    
assert total_transactions == 22473
13/25:
total_transactions = 0
for k, v in customers_dict.items():
    total_transactions += v.get_num_trans()
    
assert total_transactions == 22473
13/26:
total_transactions = 0
for k, v in customers_dict.items():
    total_transactions += v.get_num_trans()
    
assert total_transactions == 22473
assert customers_dict["Aashvi Shah"].get_num_trans = 32
13/27:
total_transactions = 0
for k, v in customers_dict.items():
    total_transactions += v.get_num_trans()
    
assert total_transactions == 22473
assert customers_dict["Aashvi Shah"].get_num_trans() == 32
13/28:
total_transactions = 0
for k, v in customers_dict.items():
    total_transactions += v.get_num_trans()
    
assert total_transactions == 22473, f"Total: {total_transactions}"
assert customers_dict["Aashvi Shah"].get_num_trans() == 32, ""
13/29:
total_transactions = 0
for k, v in customers_dict.items():
    total_transactions += v.get_num_trans()
    
assert total_transactions == 22473, f"Total: {total_transactions}"
n = customers_dict["Aashvi Shah"].get_num_trans()
assert n == 32, "Num transactions: {n}"
13/30:
total_transactions = 0
for k, v in customers_dict.items():
    total_transactions += v.get_num_trans()
    
assert total_transactions == 22473, f"Total: {total_transactions}"
n = customers_dict["Aashvi Shah"].get_num_trans()
assert n == 32, f"Num transactions: {n} "
13/31:
total_transactions = 0
for k, v in customers_dict.items():
    total_transactions += v.get_num_trans()
    
assert total_transactions == 22473, f"Total: {total_transactions}"

# n = customers_dict["Aashvi Shah"].get_num_trans()
# assert n == 32, f"Num transactions: {n} "

m = customers_dict["Abby Warren"].get_num_trans()
assert m == 8, f"Num transactions: {n} "
13/32:
total_transactions = 0
for k, v in customers_dict.items():
    total_transactions += v.get_num_trans()
    
assert total_transactions == 22473, f"Total: {total_transactions}"

# n = customers_dict["Aashvi Shah"].get_num_trans()
# assert n == 32, f"Num transactions: {n} "

m = customers_dict["Abby Warren"].get_num_trans()
assert m == 8, f"Num transactions: {n} "
13/33:
total_transactions = 0
for k, v in customers_dict.items():
    total_transactions += v.get_num_trans()
    
assert total_transactions == 22473, f"Total: {total_transactions}"

m = customers_dict["Abby Warren"].get_num_trans()
assert m == 8, f"Num transactions: {n} "

n = customers_dict["Aashvi Shah"].get_num_trans()
assert n == 32, f"Num transactions: {n} "
13/34:
total_transactions = 0
for k, v in customers_dict.items():
    total_transactions += v.get_num_trans()
    
assert total_transactions == 22473, f"Total: {total_transactions}"

#check the number of transactions for customers in the dataset.
#I've chosen customers who ordered on multiple days, not just once
m = customers_dict["Abby Warren"].get_num_trans()
assert m == 8, f"Num transactions: {n} "

n = customers_dict["Aashvi Shah"].get_num_trans()
assert n == 23, f"Num transactions: {n} " #32 if using new data
13/35:
customers_dict = {} #indexing Customer instances by name
dutchie_tr = {} #date + number of dutchie transactions
lantern_tr = {} #"", lantern

for ind, row in df.iterrows():

    #handle transaction data
    name = row[14]
    date = row[10]
    orderSource = row[22]
    t = Transaction(date, orderSource)
    
    #if we have a new customer, add to the list of customers
    if name not in customers_dict.keys():
        c = Customer(name)
        c.add_transaction(t)
        customers_dict[name] = c #key, value
        
    #otherwise, add a transaction to their name
    else:
        customers_dict[name].add_transaction(t) 
        
    #####
    
    #if dutchie transaction, add +1 to the count for this date; ditto Lantern
    if orderSource is "Dutchie":
        if date in dutchie_tr.keys():
            dutchie_tr[date] += 1
        else:
            dutchie_tr[date] = 1
        
    elif orderSource is "Lantern (Drizly)":
        if date in lantern_tr.keys():
            lantern_tr[date] += 1
        else:
            lantern_tr[date] = 1
            
    elif orderSource is "Walk In":
        pass
    
    else:
        raise ValueError("Unexpected order source")
13/36:
customers_dict = {} #indexing Customer instances by name
dutchie_tr = {} #date + number of dutchie transactions
lantern_tr = {} #"", lantern

for ind, row in df.iterrows():

    #handle transaction data
    name = row[14]
    date = row[10]
    orderSource = row[22]
    t = Transaction(date, orderSource)
    
    #if we have a new customer, add to the list of customers
    if name not in customers_dict.keys():
        c = Customer(name)
        c.add_transaction(t)
        customers_dict[name] = c #key, value
        
    #otherwise, add a transaction to their name
    else:
        customers_dict[name].add_transaction(t) 
        
    #####
    
    #if dutchie transaction, add +1 to the count for this date; ditto Lantern
    if orderSource == "Dutchie":
        if date in dutchie_tr.keys():
            dutchie_tr[date] += 1
        else:
            dutchie_tr[date] = 1
        
    elif orderSource == "Lantern (Drizly)":
        if date in lantern_tr.keys():
            lantern_tr[date] += 1
        else:
            lantern_tr[date] = 1
            
    elif orderSource == "Walk In":
        pass
    
    else:
        raise ValueError("Unexpected order source")
13/37:
customers_dict = {} #indexing Customer instances by name
dutchie_tr = {} #date + number of dutchie transactions
lantern_tr = {} #"", lantern

for ind, row in df.iterrows():

    #handle transaction data
    name = row[14]
    date = row[10]
    orderSource = row[22]
    t = Transaction(date, orderSource)
    
    #if we have a new customer, add to the list of customers
    if name not in customers_dict.keys():
        c = Customer(name)
        c.add_transaction(t)
        customers_dict[name] = c #key, value
        
    #otherwise, add a transaction to their name
    else:
        customers_dict[name].add_transaction(t) 
        
    #####
    
    #if dutchie transaction, add +1 to the count for this date; ditto Lantern
    if orderSource == "Dutchie":
        if date in dutchie_tr.keys():
            dutchie_tr[date] += 1
        else:
            dutchie_tr[date] = 1
        
    elif orderSource == "Lantern (Drizly)":
        if date in lantern_tr.keys():
            lantern_tr[date] += 1
        else:
            lantern_tr[date] = 1
            
    elif orderSource == "Walk In":
        pass
    
    else:
        raise ValueError("Unexpected order source")
13/38:
total_transactions = 0
for k, v in customers_dict.items():
    total_transactions += v.get_num_trans()
    
assert total_transactions == 22473, f"Total: {total_transactions}"

#check the number of transactions for customers in the dataset.
#I've chosen customers who ordered on multiple days, not just once
m = customers_dict["Abby Warren"].get_num_trans()
assert m == 8, f"Num transactions: {n} "

n = customers_dict["Aashvi Shah"].get_num_trans()
assert n == 23, f"Num transactions: {n} " #32 if using new data - transactions(1).csv

s = sum(dutchie_tr.values())
assert s == 3806, f"Num Dutchie transactions: {s}"

t = sum(lantern_tr.values())
assert t == 18642, f"Num Lantern transactions: {t}"
13/39:
total_transactions = 0
for k, v in customers_dict.items():
    total_transactions += v.get_num_trans()
    
assert total_transactions == 22473, f"Total: {total_transactions}"

#check the number of transactions for customers in the dataset.
#I've chosen customers who ordered on multiple days, not just once
m = customers_dict["Abby Warren"].get_num_trans()
assert m == 8, f"Num transactions: {n} "

n = customers_dict["Aashvi Shah"].get_num_trans()
assert n == 23, f"Num transactions: {n} " #32 if using new data - transactions(1).csv

s = sum(dutchie_tr.values())
assert s == 3806, f"Num Dutchie transactions: {s}"

t = sum(lantern_tr.values())
assert t == 18642, f"Num Lantern transactions: {t}"
13/40: dutchie_tr
13/41: dutchie_tr
13/42:
def standardize_dates(dict1):
    dict2 = {}
    
    for i, key in enumerate(dict1.keys()):
        val = dict1.pop(key)
        strkey = key.split('/')
        strlst = ['0' + i if len(i) < 2 else i for i in strkey]
        
        newval = '/'.join(strlst)
        print(newval)
        
        if i > 5:
            break
            
standardize_dates(dutchie_tr)
13/43:
def standardize_dates(dict1):
    dict2 = {}
    
    for i, key in enumerate(dict1.keys()):
        val = dict1[key]
        strkey = key.split('/')
        strlst = ['0' + i if len(i) < 2 else i for i in strkey]
        
        newval = '/'.join(strlst)
        print(newval)
        
        if i > 5:
            break
            
standardize_dates(dutchie_tr)
13/44:
def standardize_dates(dict1):
    ''' Formats a date as MM-DD-YYYY so the dates can be sorted
    alphanumerically in further data manipulation.
    '''
    dict2 = {}
    
    for i, key in enumerate(dict1.keys()):
        val = dict1[key]
        strkey = key.split('/')
        strlst = ['0' + i if len(i) < 2 else i for i in strkey]       
        newval = '/'.join(strlst)
        dict2[key] = newval
        
    return dict2
            
dict2 = standardize_dates(dutchie_tr)
dict2
13/45:
def standardize_dates(dict1):
    ''' Formats a date as MM-DD-YYYY so the dates can be sorted
    alphanumerically in further data manipulation.
    '''
    dict2 = {}
    
    for i, key in enumerate(dict1.keys()):
        val = dict1[key]
        strkey = key.split('/')
        strlst = ['0' + i if len(i) < 2 else i for i in strkey]       
        newkey = '/'.join(strlst)
        dict2[newkey] = val
        
    return dict2
            
dict2 = standardize_dates(dutchie_tr)
dict2
13/46:
def standardize_dates(dict1):
    ''' Formats a date as MM-DD-YYYY so the dates can be sorted
    alphanumerically in further data manipulation.
    '''
    dict2 = {}
    
    for i, key in enumerate(dict1.keys()):
        val = dict1[key]
        strkey = key.split('/')
        strlst = ['0' + i if len(i) < 2 else i for i in strkey]       
        newkey = '/'.join(strlst)
        dict2[newkey] = val
        
    return dict2
13/47:
dutchie_tr2 = standardize_dates(dutchie_tr)
lantern_tr2 = standardize_dates(lantern_tr)

#sort by key, i.e. by date
dutchie_tr3 = co.OrderedDict(sorted(dutchie_tr2.items()))
lantern_tr3 = co.OrderedDict(sorted(lantern_tr3.items()))
                                
dutchie_tr3
13/48:
import numpy as np
%matplotlib inline
import matplotlib.pyplot as plt
import pandas as pd
import collections as co
13/49:
dutchie_tr2 = standardize_dates(dutchie_tr)
lantern_tr2 = standardize_dates(lantern_tr)

#sort by key, i.e. by date
dutchie_tr3 = co.OrderedDict(sorted(dutchie_tr2.items()))
lantern_tr3 = co.OrderedDict(sorted(lantern_tr3.items()))
                                
dutchie_tr3
13/50:
dutchie_tr2 = standardize_dates(dutchie_tr)
lantern_tr2 = standardize_dates(lantern_tr)

#sort by key, i.e. by date
dutchie_tr3 = co.OrderedDict(sorted(dutchie_tr2.items()))
lantern_tr3 = co.OrderedDict(sorted(lantern_tr2.items()))
                                
dutchie_tr3
13/51:
dutchie_tr2 = standardize_dates(dutchie_tr)
lantern_tr2 = standardize_dates(lantern_tr)

#sort by key, i.e. by date
dutchie_tr3 = sorted(dutchie_tr2.items()))
lantern_tr3 = sorted(lantern_tr2.items()))

dutchie_tr3
13/52:
dutchie_tr2 = standardize_dates(dutchie_tr)
lantern_tr2 = standardize_dates(lantern_tr)

#sort by key, i.e. by date
dutchie_tr3 = sorted(dutchie_tr2.items())
lantern_tr3 = sorted(lantern_tr2.items())

dutchie_tr3
13/53:
dutchie_tr2 = standardize_dates(dutchie_tr)
lantern_tr2 = standardize_dates(lantern_tr)

#sort by key, i.e. by date
dutchie_tr3 = sorted(dutchie_tr2.items())
lantern_tr3 = sorted(lantern_tr2.items())

dutchie_date, dutchie_orders = [i[0], i[1] for i in dutchie_tr2.items()]
13/54:
dutchie_tr2 = standardize_dates(dutchie_tr)
lantern_tr2 = standardize_dates(lantern_tr)

#sort by key, i.e. by date
dutchie_tr3 = sorted(dutchie_tr2.items())
lantern_tr3 = sorted(lantern_tr2.items())

dutchie_date, dutchie_orders = [(i[0], i[1]) for i in dutchie_tr2.items()]
13/55:
dutchie_tr2 = standardize_dates(dutchie_tr)
lantern_tr2 = standardize_dates(lantern_tr)

#sort by key, i.e. by date
dutchie_tr3 = sorted(dutchie_tr2.items())
lantern_tr3 = sorted(lantern_tr2.items())

(dutchie_date, dutchie_orders) = [(i[0], i[1]) for i in dutchie_tr2.items()]
13/56:
dutchie_tr2 = standardize_dates(dutchie_tr)
lantern_tr2 = standardize_dates(lantern_tr)

#sort by key, i.e. by date
dutchie_tr3 = sorted(dutchie_tr2.items())
lantern_tr3 = sorted(lantern_tr2.items())

dutchie_date, dutchie_orders = [i for i in dutchie_tr2.items()]
13/57:
dutchie_tr2 = standardize_dates(dutchie_tr)
lantern_tr2 = standardize_dates(lantern_tr)

#sort by key, i.e. by date
dutchie_tr3 = sorted(dutchie_tr2.items())
lantern_tr3 = sorted(lantern_tr2.items())

dutchie_date = [i[0] for i in dutchie_tr2.items()]
13/58:
dutchie_tr2 = standardize_dates(dutchie_tr)
lantern_tr2 = standardize_dates(lantern_tr)

#sort by key, i.e. by date
dutchie_tr3 = sorted(dutchie_tr2.items())
lantern_tr3 = sorted(lantern_tr2.items())

#this isn't computationally efficient - optimize into one line if possible
dutchie_date = [i[0] for i in dutchie_tr3]
dutchie_orders = [[i[1] for i in dutchie_tr3]
                  
lantern_date = [[i[0] for i in dutchie_tr3]
lantern_orders = [[i[1] for i in dutchie_tr3]
13/59:
dutchie_tr2 = standardize_dates(dutchie_tr)
lantern_tr2 = standardize_dates(lantern_tr)

#sort by key, i.e. by date
dutchie_tr3 = sorted(dutchie_tr2.items())
lantern_tr3 = sorted(lantern_tr2.items())

#this isn't computationally efficient - optimize into one line if possible
dutchie_date = [i[0] for i in dutchie_tr3]
dutchie_orders = [[i[1] for i in dutchie_tr3]
                  
lantern_date = [i[0] for i in dutchie_tr3]
lantern_orders = [i[1] for i in dutchie_tr3]
13/60:
dutchie_tr2 = standardize_dates(dutchie_tr)
lantern_tr2 = standardize_dates(lantern_tr)

#sort by key, i.e. by date
dutchie_tr3 = sorted(dutchie_tr2.items())
lantern_tr3 = sorted(lantern_tr2.items())

#this isn't computationally efficient - optimize into one line if possible
dutchie_date = [i[0] for i in dutchie_tr3]
dutchie_orders = [i[1] for i in dutchie_tr3]
                  
lantern_date = [i[0] for i in dutchie_tr3]
lantern_orders = [i[1] for i in dutchie_tr3]
13/61:
dutchie_tr2 = standardize_dates(dutchie_tr)
lantern_tr2 = standardize_dates(lantern_tr)

#sort by key, i.e. by date
dutchie_tr3 = sorted(dutchie_tr2.items())
lantern_tr3 = sorted(lantern_tr2.items())

#this isn't computationally efficient - optimize into one line if possible
dutchie_date = [i[0] for i in dutchie_tr3]
dutchie_orders = [j[1] for j in dutchie_tr3]
                  
lantern_date = [ii[0] for ii in dutchie_tr3]
lantern_orders = [jj[1] for jj in dutchie_tr3]
13/62: dutchie_date
13/63: dutchie_orders
13/64:
plt.figure()
plt.scatter(dutchie_date, dutchie_orders)
plt.show()
13/65:
plt.figure()
plt.scatter(dutchie_date, dutchie_orders)
plt.scatter(lantern_date, lantern_orders)
plt.show()
13/66:
plt.figure()
#plt.scatter(dutchie_date, dutchie_orders)
plt.scatter(lantern_date, lantern_orders)
plt.show()
13/67:
dutchie_tr2 = standardize_dates(dutchie_tr)
lantern_tr2 = standardize_dates(lantern_tr)

#sort by key, i.e. by date
dutchie_tr3 = sorted(dutchie_tr2.items())
lantern_tr3 = sorted(lantern_tr2.items())

#this isn't computationally efficient - optimize into one line if possible
dutchie_date = [i[0] for i in dutchie_tr3]
dutchie_orders = [j[1] for j in dutchie_tr3]
                  
lantern_date = [ii[0] for ii in lantern_tr3]
lantern_orders = [jj[1] for jj in lantern_tr3]
13/68:
dutchie_tr2 = standardize_dates(dutchie_tr)
lantern_tr2 = standardize_dates(lantern_tr)

#sort by key, i.e. by date
dutchie_tr3 = sorted(dutchie_tr2.items())
lantern_tr3 = sorted(lantern_tr2.items())

#this isn't computationally efficient - optimize into one line if possible
dutchie_date = [i[0] for i in dutchie_tr3]
dutchie_orders = [j[1] for j in dutchie_tr3]
                  
lantern_date = [ii[0] for ii in lantern_tr3]
lantern_orders = [jj[1] for jj in lantern_tr3]
13/69:
plt.figure()
plt.scatter(dutchie_date, dutchie_orders)
plt.scatter(lantern_date, lantern_orders)
plt.show()
14/1:
import numpy as np
%matplotlib inline
import matplotlib.pyplot as plt
import pandas as pd
import collections as co
import datetime as dt
14/2:
import numpy as np
%matplotlib inline
import matplotlib.pyplot as plt
import pandas as pd
import collections as co
import datetime as dt
14/3:
class Transaction:
    
    def __init__(self, date, orderSource):
        self._date = date
        self._orderSource = orderSource
        
        def get_date(self): return self._date
        def get_orderSource(self): return self.orderSource
        

class Customer:
    
    def __init__(self, name):
        self._name = name
        self._transactions = []
        self._num_trans = 0
        self._num_dutchie = 0
        self._num_lantern = 0
        self._dates = {
            'first dutchie': None,
            'last dutchie': None,
            'first lantern': None,
            'last lantern': None  
        }
    
    def add_transaction(self, Transaction):
        self._transactions.append(Transaction)
        self._num_trans += 1
        if Transaction._orderSource is "Dutchie":
            self._num_dutchie += 1
        elif Transaction._orderSource is "Lantern (Drizly)":
            self._num_lantern += 1
        else:
            raise ValueError("Unexpected order source encountered.")
        
    def get_trans(self): return self._transactions
    def get_num_trans(self): return self._num_trans
    
    #... add methods that populate our person with data
14/4:
class Transaction:
    
    def __init__(self, date, orderSource):
        self._date = date
        self._orderSource = orderSource
        
        def get_date(self): return self._date
        def get_orderSource(self): return self._orderSource
        

class Customer:
    
    def __init__(self, name):
        self._name = name
        self._transactions = []
        self._num_trans = 0
        self._num_dutchie = 0
        self._num_lantern = 0
        self._dates = {
            'first dutchie': None,
            'last dutchie': None,
            'first lantern': None,
            'last lantern': None  
        }
    
    def add_transaction(self, Transaction):
        self._transactions.append(Transaction)
        self._num_trans += 1
        if Transaction._orderSource is "Dutchie":
            self._num_dutchie += 1
        elif Transaction._orderSource is "Lantern (Drizly)":
            self._num_lantern += 1
        else:
            raise ValueError("Unexpected order source encountered.")
        
    def get_trans(self): return self._transactions
    def get_num_trans(self): return self._num_trans
    def get_dates(self): return self._dates
    
    def set_dates(self, key, val):
        self._dates[key] = val
    
    #... add methods that populate our person with data
14/5:
class Transaction:
    
    def __init__(self, date, orderSource):
        self._date = date
        self._orderSource = orderSource
        
        def get_date(self): return self._date
        def get_orderSource(self): return self._orderSource
        

class Customer:
    
    def __init__(self, name):
        #member data relating to total transactions made
        self._name = name
        self._transactions = []
        self._num_trans = 0
        self._num_dutchie = 0
        self._num_lantern = 0
        
        #member data relating to whether they've switched from L to D
        self._dates = {
            'first dutchie': None,
            'last dutchie': None,
            'first lantern': None,
            'last lantern': None  
        }
        self._converted = None #default, don't know if they switched
        self._converted_date = None
        
    
    def add_transaction(self, Transaction):
        self._transactions.append(Transaction)
        self._num_trans += 1
        if Transaction._orderSource is "Dutchie":
            self._num_dutchie += 1
        elif Transaction._orderSource is "Lantern (Drizly)":
            self._num_lantern += 1
        else:
            raise ValueError("Unexpected order source encountered.")
        
    def get_trans(self): return self._transactions
    def get_num_trans(self): return self._num_trans
    def get_dates(self): return self._dates
    def get_converted(self): return self._converted
    def get_converted_date(self): return self._converted_date
    
    def set_dates(self, key, val): self._dates[key] = val
    def set_converted_date(self, date): self._converted_date = date
14/6:
class Transaction:
    
    def __init__(self, date, orderSource):
        self._date = date
        self._orderSource = orderSource
        
        def get_date(self): return self._date
        def get_orderSource(self): return self._orderSource
        

class Customer:
    
    def __init__(self, name):
        #member data relating to total transactions made
        self._name = name
        self._transactions = []
        self._num_trans = 0
        self._num_dutchie = 0
        self._num_lantern = 0
        
        #member data relating to whether they've switched from L to D
        self._dates = {
            'first dutchie': None,
            'last dutchie': None,
            'first lantern': None,
            'last lantern': None  
        }
        self._converted = None #default, don't know if they switched
        self._converted_date = None
        
    
    def add_transaction(self, Transaction):
        self._transactions.append(Transaction)
        self._num_trans += 1
        if Transaction._orderSource == "Dutchie":
            self._num_dutchie += 1
        elif Transaction._orderSource == "Lantern (Drizly)":
            self._num_lantern += 1
        else:
            raise ValueError("Unexpected order source encountered.")
        
    def get_trans(self): return self._transactions
    def get_num_trans(self): return self._num_trans
    def get_dates(self): return self._dates
    def get_converted(self): return self._converted
    def get_converted_date(self): return self._converted_date
    
    def set_dates(self, key, val): self._dates[key] = val
    def set_converted_date(self, date): self._converted_date = date
14/7:
class Transaction:
    
    def __init__(self, date, orderSource):
        self._date = date
        self._orderSource = orderSource
        
        def get_date(self): return self._date
        def get_orderSource(self): return self._orderSource
        

class Customer:
    
    def __init__(self, name):
        #member data relating to total transactions made
        self._name = name
        self._transactions = []
        self._num_trans = 0
        self._num_dutchie = 0
        self._num_lantern = 0
        
        #member data relating to whether they've switched from L to D
        self._dates = {
            'first dutchie': None,
            'last dutchie': None,
            'first lantern': None,
            'last lantern': None
            'first dutchie after lantern': None
        }
        self._converted = None #default, don't know if they switched
        self._converted_date = None
        
    
    def add_transaction(self, Transaction):
        self._transactions.append(Transaction)
        self._num_trans += 1
        if Transaction._orderSource == "Dutchie":
            self._num_dutchie += 1
        elif Transaction._orderSource == "Lantern (Drizly)":
            self._num_lantern += 1
        else:
            raise ValueError("Unexpected order source encountered.")
        
    def get_trans(self): return self._transactions
    def get_num_trans(self): return self._num_trans
    def get_dates(self): return self._dates
    def get_converted(self): return self._converted
    def get_converted_date(self): return self._converted_date
    
    def set_dates(self, key, val): self._dates[key] = val
    def set_converted_date(self, date): self._converted_date = date
14/8:
class Transaction:
    
    def __init__(self, date, orderSource):
        self._date = date
        self._orderSource = orderSource
        
        def get_date(self): return self._date
        def get_orderSource(self): return self._orderSource
        

class Customer:
    
    def __init__(self, name):
        #member data relating to total transactions made
        self._name = name
        self._transactions = []
        self._num_trans = 0
        self._num_dutchie = 0
        self._num_lantern = 0
        
        #member data relating to whether they've switched from L to D
        self._dates = {
            'first dutchie': None,
            'last dutchie': None,
            'first lantern': None,
            'last lantern': None,
            'first dutchie after lantern': None
        }
        self._converted = None #default, don't know if they switched
        self._converted_date = None
        
    
    def add_transaction(self, Transaction):
        self._transactions.append(Transaction)
        self._num_trans += 1
        if Transaction._orderSource == "Dutchie":
            self._num_dutchie += 1
        elif Transaction._orderSource == "Lantern (Drizly)":
            self._num_lantern += 1
        else:
            raise ValueError("Unexpected order source encountered.")
        
    def get_trans(self): return self._transactions
    def get_num_trans(self): return self._num_trans
    def get_dates(self): return self._dates
    def get_converted(self): return self._converted
    def get_converted_date(self): return self._converted_date
    
    def set_dates(self, key, val): self._dates[key] = val
    def set_converted_date(self, date): self._converted_date = date
    def set_converted(self, boolean): self._converted = boolean
14/9:
#nested loops are slow - see if it needs to be optimized
for k, cust in customer_dict.items():
    
    #store initial values of dates
    tr1 = cust.get_trans()[0] 
    
    for i, trans in enumerate(cust.get_trans()):
        
        source = trans.get_orderSource()
        date = trans.get_date()
        
        match source:
            case 'Dutchie':
                
                if date < cust.get_dates()['first dutchie']:
                    cust.set_dates('first dutchie', date)
                elif date > cust.get_dates()['last dutchie']:
                    cust.set_dates('last dutchie', date)
                
            case 'Lantern (Drizly)':
                
                if date < cust.get_dates()['first lantern']:
                    cust.set_dates('first lantern', date)
                elif date > cust.get_dates()['last lantern']:
                    cust.set_dates('last lantern', date)               
                                   
            case 'Walk In':
                pass
            
            case default:
                raise ValueError('Unexpected item source')
            
        ###
        
    ###
    
    #assume they "converted" from using Lantern to Dutchie if they have
    #transactions from Dutchie after having used Lantern
    if cust.get_dates()['last dutchie'] > cust.get_dates()['last lantern']:
        
        cust.set_converted(True)
        for i, trans in enumerate(cust.get_trans()):
            
            #find the minimum value of date after they last used Lantern
            tdate = trans.get_date()
            if tdate >= cust.get_dates()['last lantern']:
                
                if cust.get_converted_date() == None:
                    cust.set_converted_date(tdate)
                    
                #earlier than the date currently stored there
                else if tdate < cust.get_converted_date():
                    cust.set_converted_date(tdate)
                
        
    else:
        cust.set_converted(False)
15/1:
import numpy as np
%matplotlib inline
import matplotlib.pyplot as plt
import pandas as pd
import collections as co
import datetime as dt
15/2:
df = pd.read_csv(r"C:\Users\seanp\Downloads\Python Lessons\transactions.csv")
df
15/3:
for ind, column in enumerate(df.columns):
    print(ind, column)
15/4:
class Transaction:
    
    def __init__(self, date, orderSource):
        self._date = date
        self._orderSource = orderSource
        
        def get_date(self): return self._date
        def get_orderSource(self): return self._orderSource
        

class Customer:
    
    def __init__(self, name):
        #member data relating to total transactions made
        self._name = name
        self._transactions = []
        self._num_trans = 0
        self._num_dutchie = 0
        self._num_lantern = 0
        
        #member data relating to whether they've switched from L to D
        self._dates = {
            'first dutchie': None,
            'last dutchie': None,
            'first lantern': None,
            'last lantern': None,
            'first dutchie after lantern': None
        }
        self._converted = None #default, don't know if they switched
        self._converted_date = None
        
    
    def add_transaction(self, Transaction):
        self._transactions.append(Transaction)
        self._num_trans += 1
        if Transaction._orderSource == "Dutchie":
            self._num_dutchie += 1
        elif Transaction._orderSource == "Lantern (Drizly)":
            self._num_lantern += 1
        else:
            raise ValueError("Unexpected order source encountered.")
        
    def get_trans(self): return self._transactions
    def get_num_trans(self): return self._num_trans
    def get_dates(self): return self._dates
    def get_converted(self): return self._converted
    def get_converted_date(self): return self._converted_date
    
    def set_dates(self, key, val): self._dates[key] = val
    def set_converted_date(self, date): self._converted_date = date
    def set_converted(self, boolean): self._converted = boolean
15/5:
customers_dict = {} #indexing Customer instances by name
dutchie_tr = {} #date + number of dutchie transactions
lantern_tr = {} #"", lantern

for ind, row in df.iterrows():

    #handle transaction data
    name = row[14]
    date = row[10]
    orderSource = row[22]
    t = Transaction(date, orderSource)
    
    #if we have a new customer, add to the list of customers
    if name not in customers_dict.keys():
        c = Customer(name)
        c.add_transaction(t)
        customers_dict[name] = c #key, value
        
    #otherwise, add a transaction to their name
    else:
        customers_dict[name].add_transaction(t) 
        
    #####
    
    #if dutchie transaction, add +1 to the count for this date; ditto Lantern
    if orderSource == "Dutchie":
        if date in dutchie_tr.keys():
            dutchie_tr[date] += 1
        else:
            dutchie_tr[date] = 1
        
    elif orderSource == "Lantern (Drizly)":
        if date in lantern_tr.keys():
            lantern_tr[date] += 1
        else:
            lantern_tr[date] = 1
            
    elif orderSource == "Walk In":
        pass
    
    else:
        raise ValueError("Unexpected order source")
15/6:
customers_dict = {} #indexing Customer instances by name
dutchie_tr = {} #date + number of dutchie transactions
lantern_tr = {} #"", lantern

for ind, row in df.iterrows():

    #handle transaction data
    name = row[14]
    date = row[10]
    orderSource = row[22]
    t = Transaction(date, orderSource)
    
    #if we have a new customer, add to the list of customers
    if name not in customers_dict.keys():
        c = Customer(name)
        c.add_transaction(t)
        customers_dict[name] = c #key, value
        
    #otherwise, add a transaction to their name
    else:
        customers_dict[name].add_transaction(t) 
        
    #####
    
    #if dutchie transaction, add +1 to the count for this date; ditto Lantern
    if orderSource == "Dutchie":
        if date in dutchie_tr.keys():
            dutchie_tr[date] += 1
        else:
            dutchie_tr[date] = 1
        
    elif orderSource == "Lantern (Drizly)":
        if date in lantern_tr.keys():
            lantern_tr[date] += 1
        else:
            lantern_tr[date] = 1
            
    elif orderSource == "Walk In":
        pass
    
    else:
        raise ValueError("Unexpected order source: ", orderSource)
15/7:
class Transaction:
    
    def __init__(self, date, orderSource):
        self._date = date
        self._orderSource = orderSource
        
        def get_date(self): return self._date
        def get_orderSource(self): return self._orderSource
        

class Customer:
    
    def __init__(self, name):
        #member data relating to total transactions made
        self._name = name
        self._transactions = []
        self._num_trans = 0
        self._num_dutchie = 0
        self._num_lantern = 0
        
        #member data relating to whether they've switched from L to D
        self._dates = {
            'first dutchie': None,
            'last dutchie': None,
            'first lantern': None,
            'last lantern': None,
            'first dutchie after lantern': None
        }
        self._converted = None #default, don't know if they switched        
    
    def add_transaction(self, Transaction):
        self._transactions.append(Transaction)
        self._num_trans += 1
        if Transaction._orderSource == "Dutchie":
            self._num_dutchie += 1
        elif Transaction._orderSource == "Lantern (Drizly)":
            self._num_lantern += 1
        else:
            raise ValueError("Unexpected order source encountered: ", Transaction._orderSource)
        
    def get_trans(self): return self._transactions
    def get_num_trans(self): return self._num_trans
    def get_dates(self): return self._dates
    def get_converted(self): return self._converted
    def get_converted_date(self): return self._converted_date
    
    def set_dates(self, key, val): self._dates[key] = val
    def set_converted_date(self, date): self._converted_date = date
    def set_converted(self, boolean): self._converted = boolean
15/8:
customers_dict = {} #indexing Customer instances by name
dutchie_tr = {} #date + number of dutchie transactions
lantern_tr = {} #"", lantern

for ind, row in df.iterrows():

    #handle transaction data
    name = row[14]
    date = row[10]
    orderSource = row[22]
    t = Transaction(date, orderSource)
    
    #if we have a new customer, add to the list of customers
    if name not in customers_dict.keys():
        c = Customer(name)
        c.add_transaction(t)
        customers_dict[name] = c #key, value
        
    #otherwise, add a transaction to their name
    else:
        customers_dict[name].add_transaction(t) 
        
    #####
    
    #if dutchie transaction, add +1 to the count for this date; ditto Lantern
    if orderSource == "Dutchie":
        if date in dutchie_tr.keys():
            dutchie_tr[date] += 1
        else:
            dutchie_tr[date] = 1
        
    elif orderSource == "Lantern (Drizly)":
        if date in lantern_tr.keys():
            lantern_tr[date] += 1
        else:
            lantern_tr[date] = 1
            
    elif orderSource == "Walk In":
        pass
    
    else:
        raise ValueError("Unexpected order source: ", orderSource)
15/9:
class Transaction:
    
    def __init__(self, date, orderSource):
        self._date = date
        self._orderSource = orderSource
        
        def get_date(self): return self._date
        def get_orderSource(self): return self._orderSource
        

class Customer:
    
    def __init__(self, name):
        #member data relating to total transactions made
        self._name = name
        self._transactions = []
        self._num_trans = 0
        self._num_dutchie = 0
        self._num_lantern = 0
        
        #member data relating to whether they've switched from L to D
        self._dates = {
            'first dutchie': None,
            'last dutchie': None,
            'first lantern': None,
            'last lantern': None,
            'first dutchie after lantern': None
        }
        self._converted = None #default, don't know if they switched        
    
    def add_transaction(self, Transaction):
        self._transactions.append(Transaction)
        self._num_trans += 1
        if Transaction._orderSource == "Dutchie":
            self._num_dutchie += 1
        elif Transaction._orderSource == "Lantern (Drizly)":
            self._num_lantern += 1
        elif Transaction._orderSource == "Walk In":
            pass
        else:
            raise ValueError("Unexpected order source encountered: ", Transaction._orderSource)
        
    def get_trans(self): return self._transactions
    def get_num_trans(self): return self._num_trans
    def get_dates(self): return self._dates
    def get_converted(self): return self._converted
    def get_converted_date(self): return self._converted_date
    
    def set_dates(self, key, val): self._dates[key] = val
    def set_converted_date(self, date): self._converted_date = date
    def set_converted(self, boolean): self._converted = boolean
15/10:
customers_dict = {} #indexing Customer instances by name
dutchie_tr = {} #date + number of dutchie transactions
lantern_tr = {} #"", lantern

for ind, row in df.iterrows():

    #handle transaction data
    name = row[14]
    date = row[10]
    orderSource = row[22]
    t = Transaction(date, orderSource)
    
    #if we have a new customer, add to the list of customers
    if name not in customers_dict.keys():
        c = Customer(name)
        c.add_transaction(t)
        customers_dict[name] = c #key, value
        
    #otherwise, add a transaction to their name
    else:
        customers_dict[name].add_transaction(t) 
        
    #####
    
    #if dutchie transaction, add +1 to the count for this date; ditto Lantern
    if orderSource == "Dutchie":
        if date in dutchie_tr.keys():
            dutchie_tr[date] += 1
        else:
            dutchie_tr[date] = 1
        
    elif orderSource == "Lantern (Drizly)":
        if date in lantern_tr.keys():
            lantern_tr[date] += 1
        else:
            lantern_tr[date] = 1
            
    elif orderSource == "Walk In":
        pass
    
    else:
        raise ValueError("Unexpected order source: ", orderSource)
15/11:
total_transactions = 0
for k, v in customers_dict.items():
    total_transactions += v.get_num_trans()
    
assert total_transactions == 22473, f"Total: {total_transactions}"

#check the number of transactions for customers in the dataset.
#I've chosen customers who ordered on multiple days, not just once
m = customers_dict["Abby Warren"].get_num_trans()
assert m == 8, f"Num transactions: {n} "

n = customers_dict["Aashvi Shah"].get_num_trans()
assert n == 23, f"Num transactions: {n} " #32 if using new data - transactions(1).csv

s = sum(dutchie_tr.values())
assert s == 3806, f"Num Dutchie transactions: {s}"

t = sum(lantern_tr.values())
assert t == 18642, f"Num Lantern transactions: {t}"
15/12:
total_transactions = 0
for k, v in customers_dict.items():
    total_transactions += v.get_num_trans()
    
assert total_transactions == 22473, f"Total: {total_transactions}"

#check the number of transactions for customers in the dataset.
#I've chosen customers who ordered on multiple days, not just once
m = customers_dict["Abby Warren"].get_num_trans()
assert m == 8, f"Num transactions: {n} "

n = customers_dict["Aashvi Shah"].get_num_trans()
assert n == 23, f"Num transactions: {n} " #32 if using new data - transactions(1).csv

s = sum(dutchie_tr.values())
assert s == 3806, f"Num Dutchie transactions: {s}"

t = sum(lantern_tr.values())
assert t == 18642, f"Num Lantern transactions: {t}"
15/13: dutchie_tr
15/14:
def standardize_dates(dict1):
    ''' Formats a date as MM-DD-YYYY so the dates can be sorted
    alphanumerically in further data manipulation.
    '''
    dict2 = {}
    
    for i, key in enumerate(dict1.keys()):
        val = dict1[key]
        strkey = key.split('/')
        strlst = ['0' + i if len(i) < 2 else i for i in strkey]       
        newkey = '/'.join(strlst)
        dict2[newkey] = val
        
    return dict2
15/15:
total_transactions = 0
for k, v in customers_dict.items():
    total_transactions += v.get_num_trans()
    
assert total_transactions == 22473, f"Total: {total_transactions}"

#check the number of transactions for customers in the dataset.
#I've chosen customers who ordered on multiple days, not just once
m = customers_dict["Abby Warren"].get_num_trans()
assert m == 8, f"Num transactions: {n} "

n = customers_dict["Aashvi Shah"].get_num_trans()
assert n == 23, f"Num transactions: {n} " #32 if using new data - transactions(1).csv

s = sum(dutchie_tr.values())
assert s == 3806, f"Num Dutchie transactions: {s}"

t = sum(lantern_tr.values())
assert t == 18642, f"Num Lantern transactions: {t}"
15/16: dutchie_tr
15/17:
def standardize_dates(dict1):
    ''' Formats a date as MM-DD-YYYY so the dates can be sorted
    alphanumerically in further data manipulation.
    '''
    dict2 = {}
    
    for i, key in enumerate(dict1.keys()):
        val = dict1[key]
        strkey = key.split('/')
        strlst = ['0' + i if len(i) < 2 else i for i in strkey]       
        newkey = '/'.join(strlst)
        dict2[newkey] = val
        
    return dict2
15/18:
dutchie_tr2 = standardize_dates(dutchie_tr)
lantern_tr2 = standardize_dates(lantern_tr)

#sort by key, i.e. by date
dutchie_tr3 = sorted(dutchie_tr2.items())
lantern_tr3 = sorted(lantern_tr2.items())

#this isn't computationally efficient - optimize into one line if possible
dutchie_date = [i[0] for i in dutchie_tr3]
dutchie_orders = [j[1] for j in dutchie_tr3]
                  
lantern_date = [ii[0] for ii in lantern_tr3]
lantern_orders = [jj[1] for jj in lantern_tr3]
15/19: dutchie_date
15/20:
plt.figure()
plt.scatter(dutchie_date, dutchie_orders)
plt.scatter(lantern_date, lantern_orders)
plt.show()
15/21:
#nested loops are slow - see if it needs to be optimized
for k, cust in customer_dict.items():
    
    #store initial values of dates
    tr1 = cust.get_trans()[0] 
    
    for i, trans in enumerate(cust.get_trans()):
        
        source = trans.get_orderSource()
        date = trans.get_date()
        
        match source:
            case 'Dutchie':
                
                if date < cust.get_dates()['first dutchie']:
                    cust.set_dates('first dutchie', date)
                elif date > cust.get_dates()['last dutchie']:
                    cust.set_dates('last dutchie', date)
                
            case 'Lantern (Drizly)':
                
                if date < cust.get_dates()['first lantern']:
                    cust.set_dates('first lantern', date)
                elif date > cust.get_dates()['last lantern']:
                    cust.set_dates('last lantern', date)               
                                   
            case 'Walk In':
                pass
            
            case default:
                raise ValueError('Unexpected item source')
            
        ###
        
    ###
    
    #assume they "converted" from using Lantern to Dutchie if they have
    #transactions from Dutchie after having used Lantern
    if cust.get_dates()['last dutchie'] > cust.get_dates()['last lantern']:
        
        cust.set_converted(True)
        for i, trans in enumerate(cust.get_trans()):
            
            #find the minimum value of date after they last used Lantern
            tdate = trans.get_date()
            if tdate >= cust.get_dates()['last lantern']:
                
                if cust.get_dates()['first dutchie after lantern'] == None:
                    cust.set_dates('first dutchie after lantern', tdate)
                    
                #earlier than the date currently stored there
                elif tdate < cust.get_dates()['first dutchie after lantern']:
                    cust.set_dates('first dutchie after lantern', tdate)

                
        
    else:
        cust.set_converted(False)
15/22:
#nested loops are slow - see if it needs to be optimized
for k, cust in customers_dict.items():
    
    #store initial values of dates
    tr1 = cust.get_trans()[0] 
    
    for i, trans in enumerate(cust.get_trans()):
        
        source = trans.get_orderSource()
        date = trans.get_date()
        
        match source:
            case 'Dutchie':
                
                if date < cust.get_dates()['first dutchie']:
                    cust.set_dates('first dutchie', date)
                elif date > cust.get_dates()['last dutchie']:
                    cust.set_dates('last dutchie', date)
                
            case 'Lantern (Drizly)':
                
                if date < cust.get_dates()['first lantern']:
                    cust.set_dates('first lantern', date)
                elif date > cust.get_dates()['last lantern']:
                    cust.set_dates('last lantern', date)               
                                   
            case 'Walk In':
                pass
            
            case default:
                raise ValueError('Unexpected item source')
            
        ###
        
    ###
    
    #assume they "converted" from using Lantern to Dutchie if they have
    #transactions from Dutchie after having used Lantern
    if cust.get_dates()['last dutchie'] > cust.get_dates()['last lantern']:
        
        cust.set_converted(True)
        for i, trans in enumerate(cust.get_trans()):
            
            #find the minimum value of date after they last used Lantern
            tdate = trans.get_date()
            if tdate >= cust.get_dates()['last lantern']:
                
                if cust.get_dates()['first dutchie after lantern'] == None:
                    cust.set_dates('first dutchie after lantern', tdate)
                    
                #earlier than the date currently stored there
                elif tdate < cust.get_dates()['first dutchie after lantern']:
                    cust.set_dates('first dutchie after lantern', tdate)

                
        
    else:
        cust.set_converted(False)
15/23:
class Transaction:
    
    def __init__(self, date, orderSource):
        self._date = date
        self._orderSource = orderSource
        
    def get_date(self): return self._date
    def get_orderSource(self): return self._orderSource
        

class Customer:
    
    def __init__(self, name):
        #member data relating to total transactions made
        self._name = name
        self._transactions = []
        self._num_trans = 0
        self._num_dutchie = 0
        self._num_lantern = 0
        
        #member data relating to whether they've switched from L to D
        self._dates = {
            'first dutchie': None,
            'last dutchie': None,
            'first lantern': None,
            'last lantern': None,
            'first dutchie after lantern': None
        }
        self._converted = None #default, don't know if they switched        
    
    def add_transaction(self, Transaction):
        self._transactions.append(Transaction)
        self._num_trans += 1
        if Transaction._orderSource == "Dutchie":
            self._num_dutchie += 1
        elif Transaction._orderSource == "Lantern (Drizly)":
            self._num_lantern += 1
        elif Transaction._orderSource == "Walk In":
            pass
        else:
            raise ValueError("Unexpected order source encountered: ", Transaction._orderSource)
        
    def get_trans(self): return self._transactions
    def get_num_trans(self): return self._num_trans
    def get_dates(self): return self._dates
    def get_converted(self): return self._converted
    def get_converted_date(self): return self._converted_date
    
    def set_dates(self, key, val): self._dates[key] = val
    def set_converted_date(self, date): self._converted_date = date
    def set_converted(self, boolean): self._converted = boolean
15/24:
#nested loops are slow - see if it needs to be optimized
for k, cust in customers_dict.items():
    
    #store initial values of dates
    tr1 = cust.get_trans()[0] 
    
    for i, trans in enumerate(cust.get_trans()):
        
        source = trans.get_orderSource()
        date = trans.get_date()
        
        match source:
            case 'Dutchie':
                
                if date < cust.get_dates()['first dutchie']:
                    cust.set_dates('first dutchie', date)
                elif date > cust.get_dates()['last dutchie']:
                    cust.set_dates('last dutchie', date)
                
            case 'Lantern (Drizly)':
                
                if date < cust.get_dates()['first lantern']:
                    cust.set_dates('first lantern', date)
                elif date > cust.get_dates()['last lantern']:
                    cust.set_dates('last lantern', date)               
                                   
            case 'Walk In':
                pass
            
            case default:
                raise ValueError('Unexpected item source')
            
        ###
        
    ###
    
    #assume they "converted" from using Lantern to Dutchie if they have
    #transactions from Dutchie after having used Lantern
    if cust.get_dates()['last dutchie'] > cust.get_dates()['last lantern']:
        
        cust.set_converted(True)
        for i, trans in enumerate(cust.get_trans()):
            
            #find the minimum value of date after they last used Lantern
            tdate = trans.get_date()
            if tdate >= cust.get_dates()['last lantern']:
                
                if cust.get_dates()['first dutchie after lantern'] == None:
                    cust.set_dates('first dutchie after lantern', tdate)
                    
                #earlier than the date currently stored there
                elif tdate < cust.get_dates()['first dutchie after lantern']:
                    cust.set_dates('first dutchie after lantern', tdate)

                
        
    else:
        cust.set_converted(False)
17/1:
import numpy as np
%matplotlib inline
import matplotlib.pyplot as plt
import pandas as pd
import collections as co
import datetime as dt
17/2:
df = pd.read_csv(r"C:\Users\seanp\Downloads\Python Lessons\transactions.csv")
df
17/3:
df = pd.read_csv(r"C:\Users\seanp\Downloads\Python Lessons\transactions.csv")
df
17/4:
for ind, column in enumerate(df.columns):
    print(ind, column)
17/5:
class Transaction:
    
    def __init__(self, date, orderSource):
        self._date = date
        self._orderSource = orderSource
        
    def get_date(self): return self._date
    def get_orderSource(self): return self._orderSource
        

class Customer:
    
    def __init__(self, name):
        #member data relating to total transactions made
        self._name = name
        self._transactions = []
        self._num_trans = 0
        self._num_dutchie = 0
        self._num_lantern = 0
        
        #member data relating to whether they've switched from L to D
        self._dates = {
            'first dutchie': None,
            'last dutchie': None,
            'first lantern': None,
            'last lantern': None,
            'first dutchie after lantern': None
        }
        self._converted = None #default, don't know if they switched        
    
    def add_transaction(self, Transaction):
        self._transactions.append(Transaction)
        self._num_trans += 1
        if Transaction._orderSource == "Dutchie":
            self._num_dutchie += 1
        elif Transaction._orderSource == "Lantern (Drizly)":
            self._num_lantern += 1
        elif Transaction._orderSource == "Walk In":
            pass
        else:
            raise ValueError("Unexpected order source encountered: ", Transaction._orderSource)
        
    def get_trans(self): return self._transactions
    def get_num_trans(self): return self._num_trans
    def get_dates(self): return self._dates
    def get_converted(self): return self._converted
    def get_converted_date(self): return self._converted_date
    
    def set_dates(self, key, val): self._dates[key] = val
    def set_converted_date(self, date): self._converted_date = date
    def set_converted(self, boolean): self._converted = boolean
17/6:
customers_dict = {} #indexing Customer instances by name
dutchie_tr = {} #date + number of dutchie transactions
lantern_tr = {} #"", lantern

for ind, row in df.iterrows():

    #handle transaction data
    name = row[14]
    date = row[10]
    orderSource = row[22]
    t = Transaction(date, orderSource)
    
    #if we have a new customer, add to the list of customers
    if name not in customers_dict.keys():
        c = Customer(name)
        c.add_transaction(t)
        customers_dict[name] = c #key, value
        
    #otherwise, add a transaction to their name
    else:
        customers_dict[name].add_transaction(t) 
        
    #####
    
    #if dutchie transaction, add +1 to the count for this date; ditto Lantern
    if orderSource == "Dutchie":
        if date in dutchie_tr.keys():
            dutchie_tr[date] += 1
        else:
            dutchie_tr[date] = 1
        
    elif orderSource == "Lantern (Drizly)":
        if date in lantern_tr.keys():
            lantern_tr[date] += 1
        else:
            lantern_tr[date] = 1
            
    elif orderSource == "Walk In":
        pass
    
    else:
        raise ValueError("Unexpected order source: ", orderSource)
17/7:
total_transactions = 0
for k, v in customers_dict.items():
    total_transactions += v.get_num_trans()
    
assert total_transactions == 22473, f"Total: {total_transactions}"

#check the number of transactions for customers in the dataset.
#I've chosen customers who ordered on multiple days, not just once
m = customers_dict["Abby Warren"].get_num_trans()
assert m == 8, f"Num transactions: {n} "

n = customers_dict["Aashvi Shah"].get_num_trans()
assert n == 23, f"Num transactions: {n} " #32 if using new data - transactions(1).csv

s = sum(dutchie_tr.values())
assert s == 3806, f"Num Dutchie transactions: {s}"

t = sum(lantern_tr.values())
assert t == 18642, f"Num Lantern transactions: {t}"
17/8: dutchie_tr
17/9:
def standardize_dates(dict1):
    ''' Formats a date as MM-DD-YYYY so the dates can be sorted
    alphanumerically in further data manipulation.
    '''
    dict2 = {}
    
    for i, key in enumerate(dict1.keys()):
        val = dict1[key]
        strkey = key.split('/')
        strlst = ['0' + i if len(i) < 2 else i for i in strkey]       
        newkey = '/'.join(strlst)
        dict2[newkey] = val
        
    return dict2
17/10:
dutchie_tr2 = standardize_dates(dutchie_tr)
lantern_tr2 = standardize_dates(lantern_tr)

#sort by key, i.e. by date
dutchie_tr3 = sorted(dutchie_tr2.items())
lantern_tr3 = sorted(lantern_tr2.items())

#this isn't computationally efficient - optimize into one line if possible
dutchie_date = [i[0] for i in dutchie_tr3]
dutchie_orders = [j[1] for j in dutchie_tr3]
                  
lantern_date = [ii[0] for ii in lantern_tr3]
lantern_orders = [jj[1] for jj in lantern_tr3]
17/11: dutchie_date
17/12:
plt.figure()
plt.scatter(dutchie_date, dutchie_orders)
plt.scatter(lantern_date, lantern_orders)
plt.show()
17/13:
#nested loops are slow - see if it needs to be optimized
for k, cust in customers_dict.items():
    
    #store initial values of dates
    tr1 = cust.get_trans()[0] 
    
    for i, trans in enumerate(cust.get_trans()):
        
        source = trans.get_orderSource()
        date = trans.get_date()
        
        match source:
            case 'Dutchie':
                
                if date < cust.get_dates()['first dutchie']:
                    cust.set_dates('first dutchie', date)
                elif date > cust.get_dates()['last dutchie']:
                    cust.set_dates('last dutchie', date)
                
            case 'Lantern (Drizly)':
                
                if date < cust.get_dates()['first lantern']:
                    cust.set_dates('first lantern', date)
                elif date > cust.get_dates()['last lantern']:
                    cust.set_dates('last lantern', date)               
                                   
            case 'Walk In':
                pass
            
            case default:
                raise ValueError('Unexpected item source')
            
        ###
        
    ###
    
    #assume they "converted" from using Lantern to Dutchie if they have
    #transactions from Dutchie after having used Lantern
    if cust.get_dates()['last dutchie'] > cust.get_dates()['last lantern']:
        
        cust.set_converted(True)
        for i, trans in enumerate(cust.get_trans()):
            
            #find the minimum value of date after they last used Lantern
            tdate = trans.get_date()
            if tdate >= cust.get_dates()['last lantern']:
                
                if cust.get_dates()['first dutchie after lantern'] == None:
                    cust.set_dates('first dutchie after lantern', tdate)
                    
                #earlier than the date currently stored there
                elif tdate < cust.get_dates()['first dutchie after lantern']:
                    cust.set_dates('first dutchie after lantern', tdate)

                
        
    else:
        cust.set_converted(False)
17/14:
#nested loops are slow - see if it needs to be optimized
for k, cust in customers_dict.items():
    
    #store initial values of dates
    tr1 = cust.get_trans()[0] 
    
    for i, trans in enumerate(cust.get_trans()):
        
        source = trans.get_orderSource()
        date = trans.get_date()
        
        match source:
            case 'Dutchie':
                
                fd = cust.get_dates()['first dutchie']
                ld = cust.get_dates()['last dutchie']
                
                #initialize fd/ld or compare to existing fd/ld
                if (not fd or date < fd):
                    cust.set_dates('first dutchie', date)
                if (not ld or date > ld):
                    cust.set_dates('last dutchie', date)
                
            case 'Lantern (Drizly)':
                
                fl = cust.get_dates()['first lantern']
                ll = cust.get_dates()['last lantern']
                
                if (not fl or date < fl):
                    cust.set_dates('first lantern', date)
                elif (not ll or date > ll):
                    cust.set_dates('last lantern', date)               
                                   
            case 'Walk In':
                pass
            
            case default:
                raise ValueError('Unexpected item source')
            
        ###
        
    ###
    
    #assume they "converted" from using Lantern to Dutchie if they have
    #transactions from Dutchie after having used Lantern
    if cust.get_dates()['last dutchie'] > cust.get_dates()['last lantern']:
        
        cust.set_converted(True)
        for i, trans in enumerate(cust.get_trans()):
            
            #find the minimum value of date after they last used Lantern
            tdate = trans.get_date()
            if tdate >= cust.get_dates()['last lantern']:
                
                if cust.get_dates()['first dutchie after lantern'] == None:
                    cust.set_dates('first dutchie after lantern', tdate)
                    
                #earlier than the date currently stored there
                elif tdate < cust.get_dates()['first dutchie after lantern']:
                    cust.set_dates('first dutchie after lantern', tdate)

                
        
    else:
        cust.set_converted(False)
17/15:
#nested loops are slow - see if it needs to be optimized
for k, cust in customers_dict.items():
    
    #store initial values of dates
    tr1 = cust.get_trans()[0] 
    
    for i, trans in enumerate(cust.get_trans()):
        
        source = trans.get_orderSource()
        date = trans.get_date()
        
        match source:
            case 'Dutchie':
                
                fd = cust.get_dates()['first dutchie']
                ld = cust.get_dates()['last dutchie']
                
                #initialize fd/ld or compare to existing fd/ld
                if (not fd or date < fd):
                    cust.set_dates('first dutchie', date)
                if (not ld or date > ld):
                    cust.set_dates('last dutchie', date)
                
            case 'Lantern (Drizly)':
                
                fl = cust.get_dates()['first lantern']
                ll = cust.get_dates()['last lantern']
                
                if (not fl or date < fl):
                    cust.set_dates('first lantern', date)
                elif (not ll or date > ll):
                    cust.set_dates('last lantern', date)               
                                   
            case 'Walk In':
                pass
            
            case default:
                raise ValueError('Unexpected item source')
            
        ###
        
    ###
    
    #assume they "converted" from using Lantern to Dutchie if they have
    #transactions from Dutchie after having used Lantern
    ll = cust.get_dates()['last lantern']
    ld = cust.get_dates()['last dutchie']
    fdal  = cust.get_dates()['first dutchie after lantern']
    
    #cust. must have made transactions w/ both services
    if (ll and ld and (ld > ll)):
        
        cust.set_converted(True)
        for i, trans in enumerate(cust.get_trans()):
            
            #find the minimum value of date after they last used Lantern
            tdate = trans.get_date()
            if tdate >= ll:
                
                if fdal == None:
                    cust.set_dates('first dutchie after lantern', tdate)
                    
                #earlier than the date currently stored there
                elif tdate < fdal:
                    cust.set_dates('first dutchie after lantern', tdate)

                
        
    else:
        cust.set_converted(False)
17/16:
#nested loops are slow - see if it needs to be optimized
for k, cust in customers_dict.items():
    
    #store initial values of dates
    tr1 = cust.get_trans()[0] 
    
    for i, trans in enumerate(cust.get_trans()):
        
        source = trans.get_orderSource()
        date = trans.get_date()
        
        match source:
            case 'Dutchie':
                
                fd = cust.get_dates()['first dutchie']
                ld = cust.get_dates()['last dutchie']
                
                #initialize fd/ld or compare to existing fd/ld
                if (not fd or date < fd):
                    cust.set_dates('first dutchie', date)
                if (not ld or date > ld):
                    cust.set_dates('last dutchie', date)
                
            case 'Lantern (Drizly)':
                
                fl = cust.get_dates()['first lantern']
                ll = cust.get_dates()['last lantern']
                
                if (not fl or date < fl):
                    cust.set_dates('first lantern', date)
                elif (not ll or date > ll):
                    cust.set_dates('last lantern', date)               
                                   
            case 'Walk In':
                pass
            
            case default:
                raise ValueError('Unexpected item source')
            
        ###
        
    ###
    
    #assume they "converted" from using Lantern to Dutchie if they have
    #transactions from Dutchie after having used Lantern
    ll = cust.get_dates()['last lantern']
    ld = cust.get_dates()['last dutchie']
    fdal  = cust.get_dates()['first dutchie after lantern']
    
    #cust. must have made transactions w/ both services
    if (ll and ld and (ld > ll)):
        
        cust.set_converted(True)
        for i, trans in enumerate(cust.get_trans()):
            
            #find the minimum value of date after they last used Lantern
            tdate = trans.get_date()
            if tdate >= ll:
                
                if fdal == None:
                    cust.set_dates('first dutchie after lantern', tdate)
                    
                #earlier than the date currently stored there
                elif tdate < fdal:
                    cust.set_dates('first dutchie after lantern', tdate)

                
        
    else:
        cust.set_converted(False)
17/17:
ath = customers_dict["Aleisha Thompson-Heinz"].get_converted_date()
assert( ath == '06/09/2022', "Actual date: " + ath)

ar = customers_dict["Allyson Rychlak"].get_converted_date()
assert(ar == '07/19/2022', "Actual date: " + ar )

ab = customers_dict["Andrew Berlanstein"].get_converted_date()
assert(ar == '07/19/2022', "Actual date: " + ab )
17/18:
ath = customers_dict["Aleisha Thompson-Heinz"].get_converted_date()
assert ath == '06/09/2022', "Actual date: " + ath

ar = customers_dict["Allyson Rychlak"].get_converted_date()
assert ar == '07/19/2022', "Actual date: " + ar 

ab = customers_dict["Andrew Berlanstein"].get_converted_date()
assert ar == '07/19/2022', "Actual date: " + ab
17/19:
ath = customers_dict["Aleisha Thompson-Heinz"].get_converted_date()
assert ath == '06/09/2022', "Actual date: " + ath

ar = customers_dict["Allyson Rychlak"].get_converted_date()
assert ar == '07/19/2022', "Actual date: " + ar 

ab = customers_dict["Andrew Berlanstein"].get_converted_date()
assert ar == '07/19/2022', "Actual date: " + ab
17/20:
class Transaction:
    
    def __init__(self, date, orderSource):
        self._date = date
        self._orderSource = orderSource
        
    def get_date(self): return self._date
    def get_orderSource(self): return self._orderSource
        

class Customer:
    
    def __init__(self, name):
        #member data relating to total transactions made
        self._name = name
        self._transactions = []
        self._num_trans = 0
        self._num_dutchie = 0
        self._num_lantern = 0
        
        #member data relating to whether they've switched from L to D
        self._dates = {
            'first dutchie': None,
            'last dutchie': None,
            'first lantern': None,
            'last lantern': None,
            'first dutchie after lantern': None
        }
        self._converted = None #default, don't know if they switched        
    
    def add_transaction(self, Transaction):
        self._transactions.append(Transaction)
        self._num_trans += 1
        if Transaction._orderSource == "Dutchie":
            self._num_dutchie += 1
        elif Transaction._orderSource == "Lantern (Drizly)":
            self._num_lantern += 1
        elif Transaction._orderSource == "Walk In":
            pass
        else:
            raise ValueError("Unexpected order source encountered: ", Transaction._orderSource)
        
    def get_trans(self): return self._transactions
    def get_num_trans(self): return self._num_trans
    def get_dates(self): return self._dates
    def get_converted(self): return self._converted
    def get_converted_date(self): return self._dates['first dutchie after lantern']
    
    def set_dates(self, key, val): self._dates[key] = val
    def set_converted_date(self, date): self._converted_date = date
    def set_converted(self, boolean): self._converted = boolean
17/21:
ath = customers_dict["Aleisha Thompson-Heinz"].get_converted_date()
assert ath == '06/09/2022', "Actual date: " + ath

ar = customers_dict["Allyson Rychlak"].get_converted_date()
assert ar == '07/19/2022', "Actual date: " + ar 

ab = customers_dict["Andrew Berlanstein"].get_converted_date()
assert ar == '07/19/2022', "Actual date: " + ab
17/22:
class Transaction:
    
    def __init__(self, date, orderSource):
        self._date = date
        self._orderSource = orderSource
        
    def get_date(self): return self._date
    def get_orderSource(self): return self._orderSource
        

class Customer:
    
    def __init__(self, name):
        #member data relating to total transactions made
        self._name = name
        self._transactions = []
        self._num_trans = 0
        self._num_dutchie = 0
        self._num_lantern = 0
        
        #member data relating to whether they've switched from L to D
        self._dates = {
            'first dutchie': None,
            'last dutchie': None,
            'first lantern': None,
            'last lantern': None,
            'first dutchie after lantern': None
        }
        self._converted = None #default, don't know if they switched        
    
    def add_transaction(self, Transaction):
        self._transactions.append(Transaction)
        self._num_trans += 1
        if Transaction._orderSource == "Dutchie":
            self._num_dutchie += 1
        elif Transaction._orderSource == "Lantern (Drizly)":
            self._num_lantern += 1
        elif Transaction._orderSource == "Walk In":
            pass
        else:
            raise ValueError("Unexpected order source encountered: ", Transaction._orderSource)
        
    def get_trans(self): return self._transactions
    def get_num_trans(self): return self._num_trans
    def get_dates(self): return self._dates
    def get_converted(self): return self._converted
    def get_converted_date(self): return self._dates['first dutchie after lantern']
    
    def set_dates(self, key, val): self._dates[key] = val
    def set_converted_date(self, date): self._converted_date = date
    def set_converted(self, boolean): self._converted = boolean
17/23:
class Transaction:
    
    def __init__(self, date, orderSource):
        self._date = date
        self._orderSource = orderSource
        
    def get_date(self): return self._date
    def get_orderSource(self): return self._orderSource
        

class Customer:
    
    def __init__(self, name):
        #member data relating to total transactions made
        self._name = name
        self._transactions = []
        self._num_trans = 0
        self._num_dutchie = 0
        self._num_lantern = 0
        
        #member data relating to whether they've switched from L to D
        self._dates = {
            'first dutchie': None,
            'last dutchie': None,
            'first lantern': None,
            'last lantern': None,
            'first dutchie after lantern': None
        }
        self._converted = None #default, don't know if they switched        
    
    def add_transaction(self, Transaction):
        self._transactions.append(Transaction)
        self._num_trans += 1
        if Transaction._orderSource == "Dutchie":
            self._num_dutchie += 1
        elif Transaction._orderSource == "Lantern (Drizly)":
            self._num_lantern += 1
        elif Transaction._orderSource == "Walk In":
            pass
        else:
            raise ValueError("Unexpected order source encountered: ", Transaction._orderSource)
        
    def get_trans(self): return self._transactions
    def get_num_trans(self): return self._num_trans
    def get_dates(self): return self._dates
    def get_converted(self): return self._converted
    def get_converted_date(self): return self._dates['first dutchie after lantern']
    
    def set_dates(self, key, val): self._dates[key] = val
    def set_converted_date(self, date): self._converted_date = date
    def set_converted(self, boolean): self._converted = boolean
17/24:
ath = customers_dict["Aleisha Thompson-Heinz"].get_converted_date()
assert ath == '06/09/2022', "Actual date: " + ath

ar = customers_dict["Allyson Rychlak"].get_converted_date()
assert ar == '07/19/2022', "Actual date: " + ar 

ab = customers_dict["Andrew Berlanstein"].get_converted_date()
assert ar == '07/19/2022', "Actual date: " + ab
17/25:
ath = customers_dict["Aleisha Thompson-Heinz"].get_converted_date()
assert ath == '06/09/2022', "Actual date: " + ath

ar = customers_dict["Allyson Rychlak"].get_converted_date()
assert ar == '07/19/2022', "Actual date: " + ar 

ab = customers_dict["Andrew Berlanstein"].get_converted_date()
assert ar == '07/19/2022', "Actual date: " + ab
17/26:
class Transaction:
    
    def __init__(self, date, orderSource):
        self._date = date
        self._orderSource = orderSource
        
    def get_date(self): return self._date
    def get_orderSource(self): return self._orderSource
        

class Customer:
    
    def __init__(self, name):
        #member data relating to total transactions made
        self._name = name
        self._transactions = []
        self._num_trans = 0
        self._num_dutchie = 0
        self._num_lantern = 0
        
        #member data relating to whether they've switched from L to D
        self._dates = {
            'first dutchie': None,
            'last dutchie': None,
            'first lantern': None,
            'last lantern': None,
            'first dutchie after lantern': None
        }
        self._converted = None #default, don't know if they switched        
    
    def add_transaction(self, Transaction):
        self._transactions.append(Transaction)
        self._num_trans += 1
        if Transaction._orderSource == "Dutchie":
            self._num_dutchie += 1
        elif Transaction._orderSource == "Lantern (Drizly)":
            self._num_lantern += 1
        elif Transaction._orderSource == "Walk In":
            pass
        else:
            raise ValueError("Unexpected order source encountered: ", Transaction._orderSource)
        
    def get_trans(self): return self._transactions
    def get_num_trans(self): return self._num_trans
    def get_dates(self): return self._dates
    def get_converted(self): return self._converted
    def get_converted_date(self): return self._dates['first dutchie after lantern']
    
    def set_dates(self, key, val): self._dates[key] = val
    def set_converted(self, boolean): self._converted = boolean
17/27:
ath = customers_dict["Aleisha Thompson-Heinz"].get_converted_date()
assert ath == '06/09/2022', "Actual date: " + ath

ar = customers_dict["Allyson Rychlak"].get_converted_date()
assert ar == '07/19/2022', "Actual date: " + ar 

ab = customers_dict["Andrew Berlanstein"].get_converted_date()
assert ar == '07/19/2022', "Actual date: " + ab
18/1:
import numpy as np
%matplotlib inline
import matplotlib.pyplot as plt
import pandas as pd
import collections as co
import datetime as dt
18/2:
df = pd.read_csv(r"C:\Users\seanp\Downloads\Python Lessons\transactions.csv")
df
18/3:
for ind, column in enumerate(df.columns):
    print(ind, column)
18/4:
class Transaction:
    
    def __init__(self, date, orderSource):
        self._date = date
        self._orderSource = orderSource
        
    def get_date(self): return self._date
    def get_orderSource(self): return self._orderSource
        

class Customer:
    
    def __init__(self, name):
        #member data relating to total transactions made
        self._name = name
        self._transactions = []
        self._num_trans = 0
        self._num_dutchie = 0
        self._num_lantern = 0
        
        #member data relating to whether they've switched from L to D
        self._dates = {
            'first dutchie': None,
            'last dutchie': None,
            'first lantern': None,
            'last lantern': None,
            'first dutchie after lantern': None
        }
        self._converted = None #default, don't know if they switched        
    
    def add_transaction(self, Transaction):
        self._transactions.append(Transaction)
        self._num_trans += 1
        if Transaction._orderSource == "Dutchie":
            self._num_dutchie += 1
        elif Transaction._orderSource == "Lantern (Drizly)":
            self._num_lantern += 1
        elif Transaction._orderSource == "Walk In":
            pass
        else:
            raise ValueError("Unexpected order source encountered: ", Transaction._orderSource)
        
    def get_trans(self): return self._transactions
    def get_num_trans(self): return self._num_trans
    def get_dates(self): return self._dates
    def get_converted(self): return self._converted
    def get_converted_date(self): return self._dates['first dutchie after lantern']
    
    def set_dates(self, key, val): self._dates[key] = val
    def set_converted(self, boolean): self._converted = boolean
18/5:
customers_dict = {} #indexing Customer instances by name
dutchie_tr = {} #date + number of dutchie transactions
lantern_tr = {} #"", lantern

for ind, row in df.iterrows():

    #handle transaction data
    name = row[14]
    date = row[10]
    orderSource = row[22]
    t = Transaction(date, orderSource)
    
    #if we have a new customer, add to the list of customers
    if name not in customers_dict.keys():
        c = Customer(name)
        c.add_transaction(t)
        customers_dict[name] = c #key, value
        
    #otherwise, add a transaction to their name
    else:
        customers_dict[name].add_transaction(t) 
        
    #####
    
    #if dutchie transaction, add +1 to the count for this date; ditto Lantern
    if orderSource == "Dutchie":
        if date in dutchie_tr.keys():
            dutchie_tr[date] += 1
        else:
            dutchie_tr[date] = 1
        
    elif orderSource == "Lantern (Drizly)":
        if date in lantern_tr.keys():
            lantern_tr[date] += 1
        else:
            lantern_tr[date] = 1
            
    elif orderSource == "Walk In":
        pass
    
    else:
        raise ValueError("Unexpected order source: ", orderSource)
18/6:
total_transactions = 0
for k, v in customers_dict.items():
    total_transactions += v.get_num_trans()
    
assert total_transactions == 22473, f"Total: {total_transactions}"

#check the number of transactions for customers in the dataset.
#I've chosen customers who ordered on multiple days, not just once
m = customers_dict["Abby Warren"].get_num_trans()
assert m == 8, f"Num transactions: {n} "

n = customers_dict["Aashvi Shah"].get_num_trans()
assert n == 23, f"Num transactions: {n} " #32 if using new data - transactions(1).csv

s = sum(dutchie_tr.values())
assert s == 3806, f"Num Dutchie transactions: {s}"

t = sum(lantern_tr.values())
assert t == 18642, f"Num Lantern transactions: {t}"
18/7: dutchie_tr
18/8:
def standardize_dates(dict1):
    ''' Formats a date as MM-DD-YYYY so the dates can be sorted
    alphanumerically in further data manipulation.
    '''
    dict2 = {}
    
    for i, key in enumerate(dict1.keys()):
        val = dict1[key]
        strkey = key.split('/')
        strlst = ['0' + i if len(i) < 2 else i for i in strkey]       
        newkey = '/'.join(strlst)
        dict2[newkey] = val
        
    return dict2
18/9:
dutchie_tr2 = standardize_dates(dutchie_tr)
lantern_tr2 = standardize_dates(lantern_tr)

#sort by key, i.e. by date
dutchie_tr3 = sorted(dutchie_tr2.items())
lantern_tr3 = sorted(lantern_tr2.items())

#this isn't computationally efficient - optimize into one line if possible
dutchie_date = [i[0] for i in dutchie_tr3]
dutchie_orders = [j[1] for j in dutchie_tr3]
                  
lantern_date = [ii[0] for ii in lantern_tr3]
lantern_orders = [jj[1] for jj in lantern_tr3]
18/10: dutchie_date
18/11:
plt.figure()
plt.scatter(dutchie_date, dutchie_orders)
plt.scatter(lantern_date, lantern_orders)
plt.show()
18/12:
#nested loops are slow - see if it needs to be optimized
for k, cust in customers_dict.items():
    
    #store initial values of dates
    tr1 = cust.get_trans()[0] 
    
    for i, trans in enumerate(cust.get_trans()):
        
        source = trans.get_orderSource()
        date = trans.get_date()
        
        match source:
            case 'Dutchie':
                
                fd = cust.get_dates()['first dutchie']
                ld = cust.get_dates()['last dutchie']
                
                #initialize fd/ld or compare to existing fd/ld
                if (not fd or date < fd):
                    cust.set_dates('first dutchie', date)
                if (not ld or date > ld):
                    cust.set_dates('last dutchie', date)
                
            case 'Lantern (Drizly)':
                
                fl = cust.get_dates()['first lantern']
                ll = cust.get_dates()['last lantern']
                
                if (not fl or date < fl):
                    cust.set_dates('first lantern', date)
                elif (not ll or date > ll):
                    cust.set_dates('last lantern', date)               
                                   
            case 'Walk In':
                pass
            
            case default:
                raise ValueError('Unexpected item source')
            
        ###
        
    ###
    
    #assume they "converted" from using Lantern to Dutchie if they have
    #transactions from Dutchie after having used Lantern
    ll = cust.get_dates()['last lantern']
    ld = cust.get_dates()['last dutchie']
    fdal  = cust.get_dates()['first dutchie after lantern']
    
    #cust. must have made transactions w/ both services
    if (ll and ld and (ld > ll)):
        
        cust.set_converted(True)
        for i, trans in enumerate(cust.get_trans()):
            
            #find the minimum value of date after they last used Lantern
            tdate = trans.get_date()
            if tdate >= ll:
                
                if fdal == None:
                    cust.set_dates('first dutchie after lantern', tdate)
                    
                #earlier than the date currently stored there
                elif tdate < fdal:
                    cust.set_dates('first dutchie after lantern', tdate)

                
        
    else:
        cust.set_converted(False)
18/13:
ath = customers_dict["Aleisha Thompson-Heinz"].get_converted_date()
assert ath == '06/09/2022', "Actual date: " + ath

ar = customers_dict["Allyson Rychlak"].get_converted_date()
assert ar == '07/19/2022', "Actual date: " + ar 

ab = customers_dict["Andrew Berlanstein"].get_converted_date()
assert ar == '07/19/2022', "Actual date: " + ab
18/14:
# ath = customers_dict["Aleisha Thompson-Heinz"].get_converted_date()
# assert ath == '06/09/2022', "Actual date: " + ath
#returns 8/22/22, her most recent transaction

ar = customers_dict["Allyson Rychlak"].get_converted_date()
assert ar == '07/19/2022', "Actual date: " + ar 

ab = customers_dict["Andrew Berlanstein"].get_converted_date()
assert ar == '07/19/2022', "Actual date: " + ab
18/15:
# ath = customers_dict["Aleisha Thompson-Heinz"].get_converted_date()
# assert ath == '06/09/2022', "Actual date: " + ath
#returns 8/22/22, her most recent transaction

# ar = customers_dict["Allyson Rychlak"].get_converted_date()
# assert ar == '07/19/2022', "Actual date: " + ar 
#returns 7/19/22

ab = customers_dict["Andrew Berlanstein"].get_converted_date()
assert ar == '07/19/2022', "Actual date: " + ab
18/16:
class Transaction:
    
    def __init__(self, date, orderSource):
        self._date = date
        self._orderSource = orderSource
        
    def get_date(self): return self._date
    def get_orderSource(self): return self._orderSource
        

class Customer:
    
    def __init__(self, name):
        #member data relating to total transactions made
        self._name = name
        self._transactions = []
        self._num_trans = 0
        self._num_dutchie = 0
        self._num_lantern = 0
        
        #member data relating to whether they've switched from L to D
        self._dates = {
            'first dutchie': None,
            'last dutchie': None,
            'first lantern': None,
            'last lantern': None,
            'first dutchie after lantern': None
        }
        self._converted = None #default, don't know if they switched        
    
    def add_transaction(self, Transaction):
        self._transactions.append(Transaction)
        self._num_trans += 1
        if Transaction._orderSource == "Dutchie":
            self._num_dutchie += 1
        elif Transaction._orderSource == "Lantern (Drizly)":
            self._num_lantern += 1
        elif Transaction._orderSource == "Walk In":
            pass
        else:
            raise ValueError("Unexpected order source encountered: ", Transaction._orderSource)
        
    def get_trans(self): return self._transactions
    def get_num_trans(self): return self._num_trans
    def get_dates(self): return self._dates
    def get_converted(self): return self._converted
    def get_converted_date(self): return self._dates['first dutchie after lantern']
    
    def set_dates(self, key, val): self._dates[key] = val
    def set_converted(self, boolean): self._converted = boolean
18/17:
def standardize_date(date):
    ''' Formats a date as MM-DD-YYYY so the dates can be sorted
    alphanumerically in further data manipulation.
    '''    
    strkey = date.split('/')
    strlst = ['0' + i if len(i) < 2 else i for i in strkey]       
    newkey = '/'.join(strlst)
    return newkey

def standardize_dates(dict1):
    ''' Standardizes dates for an entire dictionary.
    '''
    dict2 = {}
    
    for i, key in enumerate(dict1.keys()):
        val = dict1[key]
        strkey = key.split('/')
        strlst = ['0' + i if len(i) < 2 else i for i in strkey]       
        newkey = '/'.join(strlst)
        dict2[newkey] = val
        
    return dict2
18/18:
customers_dict = {} #indexing Customer instances by name
dutchie_tr = {} #date + number of dutchie transactions
lantern_tr = {} #"", lantern

for ind, row in df.iterrows():

    #handle transaction data
    name = row[14]
    date = standardize_date(row[10])
    orderSource = row[22]
    t = Transaction(date, orderSource)
    
    #if we have a new customer, add to the list of customers
    if name not in customers_dict.keys():
        c = Customer(name)
        c.add_transaction(t)
        customers_dict[name] = c #key, value
        
    #otherwise, add a transaction to their name
    else:
        customers_dict[name].add_transaction(t) 
        
    #####
    
    #if dutchie transaction, add +1 to the count for this date; ditto Lantern
    if orderSource == "Dutchie":
        if date in dutchie_tr.keys():
            dutchie_tr[date] += 1
        else:
            dutchie_tr[date] = 1
        
    elif orderSource == "Lantern (Drizly)":
        if date in lantern_tr.keys():
            lantern_tr[date] += 1
        else:
            lantern_tr[date] = 1
            
    elif orderSource == "Walk In":
        pass
    
    else:
        raise ValueError("Unexpected order source: ", orderSource)
18/19:
total_transactions = 0
for k, v in customers_dict.items():
    total_transactions += v.get_num_trans()
    
assert total_transactions == 22473, f"Total: {total_transactions}"

#check the number of transactions for customers in the dataset.
#I've chosen customers who ordered on multiple days, not just once
m = customers_dict["Abby Warren"].get_num_trans()
assert m == 8, f"Num transactions: {n} "

n = customers_dict["Aashvi Shah"].get_num_trans()
assert n == 23, f"Num transactions: {n} " #32 if using new data - transactions(1).csv

s = sum(dutchie_tr.values())
assert s == 3806, f"Num Dutchie transactions: {s}"

t = sum(lantern_tr.values())
assert t == 18642, f"Num Lantern transactions: {t}"
18/20: dutchie_tr
18/21:
#sort by key, i.e. by date
dutchie_tr3 = sorted(dutchie_tr.items())
lantern_tr3 = sorted(lantern_tr.items())

#this isn't computationally efficient - optimize into one line if possible
dutchie_date = [i[0] for i in dutchie_tr3]
dutchie_orders = [j[1] for j in dutchie_tr3]
                  
lantern_date = [ii[0] for ii in lantern_tr3]
lantern_orders = [jj[1] for jj in lantern_tr3]
18/22: dutchie_date
18/23:
# ath = customers_dict["Aleisha Thompson-Heinz"].get_converted_date()
# assert ath == '06/09/2022', "Actual date: " + ath
#returns 8/22/22, her most recent transaction

# ar = customers_dict["Allyson Rychlak"].get_converted_date()
# assert ar == '07/19/2022', "Actual date: " + ar 
#returns 7/19/22

ab = customers_dict["Andrew Berlanstein"].get_converted_date()
assert ar == '06/16/2022', "Actual date: " + ab
19/1:
import numpy as np
%matplotlib inline
import matplotlib.pyplot as plt
import pandas as pd
import collections as co
import datetime as dt
19/2:
df = pd.read_csv(r"C:\Users\seanp\Downloads\Python Lessons\transactions.csv")
df
19/3:
for ind, column in enumerate(df.columns):
    print(ind, column)
19/4:
class Transaction:
    
    def __init__(self, date, orderSource):
        self._date = date
        self._orderSource = orderSource
        
    def get_date(self): return self._date
    def get_orderSource(self): return self._orderSource
        

class Customer:
    
    def __init__(self, name):
        #member data relating to total transactions made
        self._name = name
        self._transactions = []
        self._num_trans = 0
        self._num_dutchie = 0
        self._num_lantern = 0
        
        #member data relating to whether they've switched from L to D
        self._dates = {
            'first dutchie': None,
            'last dutchie': None,
            'first lantern': None,
            'last lantern': None,
            'first dutchie after lantern': None
        }
        self._converted = None #default, don't know if they switched        
    
    def add_transaction(self, Transaction):
        self._transactions.append(Transaction)
        self._num_trans += 1
        if Transaction._orderSource == "Dutchie":
            self._num_dutchie += 1
        elif Transaction._orderSource == "Lantern (Drizly)":
            self._num_lantern += 1
        elif Transaction._orderSource == "Walk In":
            pass
        else:
            raise ValueError("Unexpected order source encountered: ", Transaction._orderSource)
        
    def get_trans(self): return self._transactions
    def get_num_trans(self): return self._num_trans
    def get_dates(self): return self._dates
    def get_converted(self): return self._converted
    def get_converted_date(self): return self._dates['first dutchie after lantern']
    
    def set_dates(self, key, val): self._dates[key] = val
    def set_converted(self, boolean): self._converted = boolean
19/5:
def standardize_date(date):
    ''' Formats a date as MM-DD-YYYY so the dates can be sorted
    alphanumerically in further data manipulation.
    '''    
    strkey = date.split('/')
    strlst = ['0' + i if len(i) < 2 else i for i in strkey]       
    newkey = '/'.join(strlst)
    return newkey

def standardize_dates(dict1):
    ''' Standardizes dates for an entire dictionary.
    '''
    dict2 = {}
    
    for i, key in enumerate(dict1.keys()):
        val = dict1[key]
        strkey = key.split('/')
        strlst = ['0' + i if len(i) < 2 else i for i in strkey]       
        newkey = '/'.join(strlst)
        dict2[newkey] = val
        
    return dict2
19/6:
customers_dict = {} #indexing Customer instances by name
dutchie_tr = {} #date + number of dutchie transactions
lantern_tr = {} #"", lantern

for ind, row in df.iterrows():

    #handle transaction data
    name = row[14]
    date = standardize_date(row[10])
    orderSource = row[22]
    t = Transaction(date, orderSource)
    
    #if we have a new customer, add to the list of customers
    if name not in customers_dict.keys():
        c = Customer(name)
        c.add_transaction(t)
        customers_dict[name] = c #key, value
        
    #otherwise, add a transaction to their name
    else:
        customers_dict[name].add_transaction(t) 
        
    #####
    
    #if dutchie transaction, add +1 to the count for this date; ditto Lantern
    if orderSource == "Dutchie":
        if date in dutchie_tr.keys():
            dutchie_tr[date] += 1
        else:
            dutchie_tr[date] = 1
        
    elif orderSource == "Lantern (Drizly)":
        if date in lantern_tr.keys():
            lantern_tr[date] += 1
        else:
            lantern_tr[date] = 1
            
    elif orderSource == "Walk In":
        pass
    
    else:
        raise ValueError("Unexpected order source: ", orderSource)
19/7:
total_transactions = 0
for k, v in customers_dict.items():
    total_transactions += v.get_num_trans()
    
assert total_transactions == 22473, f"Total: {total_transactions}"

#check the number of transactions for customers in the dataset.
#I've chosen customers who ordered on multiple days, not just once
m = customers_dict["Abby Warren"].get_num_trans()
assert m == 8, f"Num transactions: {n} "

n = customers_dict["Aashvi Shah"].get_num_trans()
assert n == 23, f"Num transactions: {n} " #32 if using new data - transactions(1).csv

s = sum(dutchie_tr.values())
assert s == 3806, f"Num Dutchie transactions: {s}"

t = sum(lantern_tr.values())
assert t == 18642, f"Num Lantern transactions: {t}"
19/8: dutchie_tr
19/9:
#sort by key, i.e. by date
dutchie_tr3 = sorted(dutchie_tr.items())
lantern_tr3 = sorted(lantern_tr.items())

#this isn't computationally efficient - optimize into one line if possible
dutchie_date = [i[0] for i in dutchie_tr3]
dutchie_orders = [j[1] for j in dutchie_tr3]
                  
lantern_date = [ii[0] for ii in lantern_tr3]
lantern_orders = [jj[1] for jj in lantern_tr3]
19/10: dutchie_date
19/11:
plt.figure()
plt.scatter(dutchie_date, dutchie_orders)
plt.scatter(lantern_date, lantern_orders)
plt.show()
19/12:
#nested loops are slow - see if it needs to be optimized
for k, cust in customers_dict.items():
    
    #store initial values of dates
    tr1 = cust.get_trans()[0] 
    
    for i, trans in enumerate(cust.get_trans()):
        
        source = trans.get_orderSource()
        date = trans.get_date()
        
        match source:
            case 'Dutchie':
                
                fd = cust.get_dates()['first dutchie']
                ld = cust.get_dates()['last dutchie']
                
                #initialize fd/ld or compare to existing fd/ld
                if (not fd or date < fd):
                    cust.set_dates('first dutchie', date)
                if (not ld or date > ld):
                    cust.set_dates('last dutchie', date)
                
            case 'Lantern (Drizly)':
                
                fl = cust.get_dates()['first lantern']
                ll = cust.get_dates()['last lantern']
                
                if (not fl or date < fl):
                    cust.set_dates('first lantern', date)
                elif (not ll or date > ll):
                    cust.set_dates('last lantern', date)               
                                   
            case 'Walk In':
                pass
            
            case default:
                raise ValueError('Unexpected item source')
            
        ###
        
    ###
    
    #assume they "converted" from using Lantern to Dutchie if they have
    #transactions from Dutchie after having used Lantern
    ll = cust.get_dates()['last lantern']
    ld = cust.get_dates()['last dutchie']
    fdal  = cust.get_dates()['first dutchie after lantern']
    
    #cust. must have made transactions w/ both services
    if (ll and ld and (ld > ll)):
        
        cust.set_converted(True)
        for i, trans in enumerate(cust.get_trans()):
            
            #find the minimum value of date after they last used Lantern
            tdate = trans.get_date()
            if tdate >= ll:
                
                if fdal == None:
                    cust.set_dates('first dutchie after lantern', tdate)
                    
                #earlier than the date currently stored there
                elif tdate < fdal:
                    cust.set_dates('first dutchie after lantern', tdate)

                
        
    else:
        cust.set_converted(False)
19/13:
# ath = customers_dict["Aleisha Thompson-Heinz"].get_converted_date()
# assert ath == '06/09/2022', "Actual date: " + ath
#returns 8/22/22, her most recent transaction

# ar = customers_dict["Allyson Rychlak"].get_converted_date()
# assert ar == '07/19/2022', "Actual date: " + ar 
#returns 7/19/22

ab = customers_dict["Andrew Berlanstein"].get_converted_date()
assert ar == '06/16/2022', "Actual date: " + ab
19/14:
# ath = customers_dict["Aleisha Thompson-Heinz"].get_converted_date()
# assert ath == '06/09/2022', "Actual date: " + ath
#returns 8/22/22, her most recent transaction

# ar = customers_dict["Allyson Rychlak"].get_converted_date()
# assert ar == '07/19/2022', "Actual date: " + ar 
#returns 7/19/22

ab = customers_dict["Andrew Berlanstein"].get_converted_date()
assert ab == '06/16/2022', "Actual date: " + ab
19/15:
# ath = customers_dict["Aleisha Thompson-Heinz"].get_converted_date()
# assert ath == '06/09/2022', "Actual date: " + ath
#returns 8/22/22, her most recent transaction

ar = customers_dict["Allyson Rychlak"].get_converted_date()
assert ar == '07/19/2022', "Actual date: " + ar 
#returns 7/19/22

ab = customers_dict["Andrew Berlanstein"].get_converted_date()
assert ab == '06/16/2022', "Actual date: " + ab
19/16:
ath = customers_dict["Aleisha Thompson-Heinz"].get_converted_date()
assert ath == '06/09/2022', "Actual date: " + ath
#returns 8/22/22, her most recent transaction

ar = customers_dict["Allyson Rychlak"].get_converted_date()
assert ar == '07/19/2022', "Actual date: " + ar 
#returns 7/19/22

ab = customers_dict["Andrew Berlanstein"].get_converted_date()
assert ab == '06/16/2022', "Actual date: " + ab
19/17:
cust = customers_dict["Aleisha Thompson-Heinz"]
cust.get_dates()
19/18:
ath = customers_dict["Aleisha Thompson-Heinz"].get_converted_date()
assert ath == '06/09/2022', "Actual date: " + ath
#returns 8/22/22, her most recent transaction. she has several dutchie orders and 1 lantern order

ar = customers_dict["Allyson Rychlak"].get_converted_date()
assert ar == '07/19/2022', "Actual date: " + ar 
#returns 07/19/22. she only has 1 dutchie order and 1 lantern order

ab = customers_dict["Andrew Berlanstein"].get_converted_date()
assert ab == '06/16/2022', "Actual date: " + ab 
#returns 06/16/2022. he only has 1 dutchie order and 1 lantern order
19/19:
#nested loops are slow - see if it needs to be optimized
for k, cust in customers_dict.items():
    
    #store initial values of dates
    tr1 = cust.get_trans()[0] 
    
    for i, trans in enumerate(cust.get_trans()):
        
        source = trans.get_orderSource()
        date = trans.get_date()
        
        match source:
            case 'Dutchie':
                
                fd = cust.get_dates()['first dutchie']
                ld = cust.get_dates()['last dutchie']
                
                #initialize fd/ld or compare to existing fd/ld
                if (not fd or date < fd):
                    cust.set_dates('first dutchie', date)
                if (not ld or date > ld):
                    cust.set_dates('last dutchie', date)
                
            case 'Lantern (Drizly)':
                
                fl = cust.get_dates()['first lantern']
                ll = cust.get_dates()['last lantern']
                
                if (not fl or date < fl):
                    cust.set_dates('first lantern', date)
                elif (not ll or date > ll):
                    cust.set_dates('last lantern', date)               
                                   
            case 'Walk In':
                pass
            
            case default:
                raise ValueError('Unexpected item source')
            
        ###
        
    ###
    
    #assume they "converted" from using Lantern to Dutchie if they have
    #transactions from Dutchie after having used Lantern
    ll = cust.get_dates()['last lantern']
    ld = cust.get_dates()['last dutchie']
    fdal  = cust.get_dates()['first dutchie after lantern']
    
    #cust. must have made transactions w/ both services
    if (ll and ld and (ld > ll)):
        
        cust.set_converted(True)
        for i, trans in enumerate(cust.get_trans()):
            
            #find the minimum value of date after they last used Lantern
            tdate = trans.get_date()
            if tdate >= ll:
                
                if fdal == None:
                    cust.set_dates('first dutchie after lantern', tdate)
                    print('control statement 1')
                    
                #earlier than the date currently stored there
                elif tdate < fdal:
                    cust.set_dates('first dutchie after lantern', tdate)
                    print('control statement 2')
        
    else:
        cust.set_converted(False)
19/20:
#nested loops are slow - see if it needs to be optimized
for k, cust in customers_dict.items():
    
    #store initial values of dates
    tr1 = cust.get_trans()[0] 
    
    for i, trans in enumerate(cust.get_trans()):
        
        source = trans.get_orderSource()
        date = trans.get_date()
        
        match source:
            case 'Dutchie':
                
                fd = cust.get_dates()['first dutchie']
                ld = cust.get_dates()['last dutchie']
                
                #initialize fd/ld or compare to existing fd/ld
                if (not fd or date < fd):
                    cust.set_dates('first dutchie', date)
                if (not ld or date > ld):
                    cust.set_dates('last dutchie', date)
                
            case 'Lantern (Drizly)':
                
                fl = cust.get_dates()['first lantern']
                ll = cust.get_dates()['last lantern']
                
                if (not fl or date < fl):
                    cust.set_dates('first lantern', date)
                elif (not ll or date > ll):
                    cust.set_dates('last lantern', date)               
                                   
            case 'Walk In':
                pass
            
            case default:
                raise ValueError('Unexpected item source')
            
        ###
        
    ###
    
    #assume they "converted" from using Lantern to Dutchie if they have
    #transactions from Dutchie after having used Lantern
    ll = cust.get_dates()['last lantern']
    ld = cust.get_dates()['last dutchie']
    fdal  = cust.get_dates()['first dutchie after lantern']
    
    print("\nCustomer: ", cust.get_name())
    
    #cust. must have made transactions w/ both services
    if (ll and ld and (ld > ll)):
        
        cust.set_converted(True)
        for i, trans in enumerate(cust.get_trans()):
            
            #find the minimum value of date after they last used Lantern
            tdate = trans.get_date()
            if tdate >= ll:
                
                if fdal == None:
                    cust.set_dates('first dutchie after lantern', tdate)
                    print('control statement 1')
                    
                #earlier than the date currently stored there
                elif tdate < fdal:
                    cust.set_dates('first dutchie after lantern', tdate)
                    print('control statement 2')
        
    else:
        cust.set_converted(False)
19/21:
class Transaction:
    
    def __init__(self, date, orderSource):
        self._date = date
        self._orderSource = orderSource
        
    def get_date(self): return self._date
    def get_orderSource(self): return self._orderSource
        

class Customer:
    
    def __init__(self, name):
        #member data relating to total transactions made
        self._name = name
        self._transactions = []
        self._num_trans = 0
        self._num_dutchie = 0
        self._num_lantern = 0
        
        #member data relating to whether they've switched from L to D
        self._dates = {
            'first dutchie': None,
            'last dutchie': None,
            'first lantern': None,
            'last lantern': None,
            'first dutchie after lantern': None
        }
        self._converted = None #default, don't know if they switched        
    
    def add_transaction(self, Transaction):
        self._transactions.append(Transaction)
        self._num_trans += 1
        if Transaction._orderSource == "Dutchie":
            self._num_dutchie += 1
        elif Transaction._orderSource == "Lantern (Drizly)":
            self._num_lantern += 1
        elif Transaction._orderSource == "Walk In":
            pass
        else:
            raise ValueError("Unexpected order source encountered: ", Transaction._orderSource)
        
    def get_name(self): return self._name
    def get_trans(self): return self._transactions
    def get_num_trans(self): return self._num_trans
    def get_dates(self): return self._dates
    def get_converted(self): return self._converted
    def get_converted_date(self): return self._dates['first dutchie after lantern']
    
    def set_dates(self, key, val): self._dates[key] = val
    def set_converted(self, boolean): self._converted = boolean
19/22:
#nested loops are slow - see if it needs to be optimized
for k, cust in customers_dict.items():
    
    #store initial values of dates
    tr1 = cust.get_trans()[0] 
    
    for i, trans in enumerate(cust.get_trans()):
        
        source = trans.get_orderSource()
        date = trans.get_date()
        
        match source:
            case 'Dutchie':
                
                fd = cust.get_dates()['first dutchie']
                ld = cust.get_dates()['last dutchie']
                
                #initialize fd/ld or compare to existing fd/ld
                if (not fd or date < fd):
                    cust.set_dates('first dutchie', date)
                if (not ld or date > ld):
                    cust.set_dates('last dutchie', date)
                
            case 'Lantern (Drizly)':
                
                fl = cust.get_dates()['first lantern']
                ll = cust.get_dates()['last lantern']
                
                if (not fl or date < fl):
                    cust.set_dates('first lantern', date)
                elif (not ll or date > ll):
                    cust.set_dates('last lantern', date)               
                                   
            case 'Walk In':
                pass
            
            case default:
                raise ValueError('Unexpected item source')
            
        ###
        
    ###
    
    #assume they "converted" from using Lantern to Dutchie if they have
    #transactions from Dutchie after having used Lantern
    ll = cust.get_dates()['last lantern']
    ld = cust.get_dates()['last dutchie']
    fdal  = cust.get_dates()['first dutchie after lantern']
    
    print("\nCustomer: ", cust.get_name())
    
    #cust. must have made transactions w/ both services
    if (ll and ld and (ld > ll)):
        
        cust.set_converted(True)
        for i, trans in enumerate(cust.get_trans()):
            
            #find the minimum value of date after they last used Lantern
            tdate = trans.get_date()
            if tdate >= ll:
                
                if fdal == None:
                    cust.set_dates('first dutchie after lantern', tdate)
                    print('control statement 1')
                    
                #earlier than the date currently stored there
                elif tdate < fdal:
                    cust.set_dates('first dutchie after lantern', tdate)
                    print('control statement 2')
        
    else:
        cust.set_converted(False)
19/23:
#nested loops are slow - see if it needs to be optimized
for k, cust in customers_dict.items():
    
    #store initial values of dates
    tr1 = cust.get_trans()[0] 
    
    for i, trans in enumerate(cust.get_trans()):
        
        source = trans.get_orderSource()
        date = trans.get_date()
        
        match source:
            case 'Dutchie':
                
                fd = cust.get_dates()['first dutchie']
                ld = cust.get_dates()['last dutchie']
                
                #initialize fd/ld or compare to existing fd/ld
                if (not fd or date < fd):
                    cust.set_dates('first dutchie', date)
                if (not ld or date > ld):
                    cust.set_dates('last dutchie', date)
                
            case 'Lantern (Drizly)':
                
                fl = cust.get_dates()['first lantern']
                ll = cust.get_dates()['last lantern']
                
                if (not fl or date < fl):
                    cust.set_dates('first lantern', date)
                elif (not ll or date > ll):
                    cust.set_dates('last lantern', date)               
                                   
            case 'Walk In':
                pass
            
            case default:
                raise ValueError('Unexpected item source')
            
        ###
        
    ###
    
    #assume they "converted" from using Lantern to Dutchie if they have
    #transactions from Dutchie after having used Lantern
    ll = cust.get_dates()['last lantern']
    ld = cust.get_dates()['last dutchie']
    fdal  = cust.get_dates()['first dutchie after lantern']
    
    print("\nCustomer: ", cust.get_name())
    
    #cust. must have made transactions w/ both services
    if (ll and ld and (ld > ll)):
        
        cust.set_converted(True)
        for i, trans in enumerate(cust.get_trans()):
            
            #find the minimum value of date after they last used Lantern
            tdate = trans.get_date()
            if tdate >= ll:
                
                if fdal == None:
                    cust.set_dates('first dutchie after lantern', tdate)
                    print('control statement 1')
                    
                #earlier than the date currently stored there
                elif tdate < fdal:
                    cust.set_dates('first dutchie after lantern', tdate)
                    print('control statement 2')
        
    else:
        cust.set_converted(False)
20/1:
import numpy as np
%matplotlib inline
import matplotlib.pyplot as plt
import pandas as pd
import collections as co
import datetime as dt
20/2:
df = pd.read_csv(r"C:\Users\seanp\Downloads\Python Lessons\transactions.csv")
df
20/3:
for ind, column in enumerate(df.columns):
    print(ind, column)
20/4:
class Transaction:
    
    def __init__(self, date, orderSource):
        self._date = date
        self._orderSource = orderSource
        
    def get_date(self): return self._date
    def get_orderSource(self): return self._orderSource
        

class Customer:
    
    def __init__(self, name):
        #member data relating to total transactions made
        self._name = name
        self._transactions = []
        self._num_trans = 0
        self._num_dutchie = 0
        self._num_lantern = 0
        
        #member data relating to whether they've switched from L to D
        self._dates = {
            'first dutchie': None,
            'last dutchie': None,
            'first lantern': None,
            'last lantern': None,
            'first dutchie after lantern': None
        }
        self._converted = None #default, don't know if they switched        
    
    def add_transaction(self, Transaction):
        self._transactions.append(Transaction)
        self._num_trans += 1
        if Transaction._orderSource == "Dutchie":
            self._num_dutchie += 1
        elif Transaction._orderSource == "Lantern (Drizly)":
            self._num_lantern += 1
        elif Transaction._orderSource == "Walk In":
            pass
        else:
            raise ValueError("Unexpected order source encountered: ", Transaction._orderSource)
        
    def get_name(self): return self._name
    def get_trans(self): return self._transactions
    def get_num_trans(self): return self._num_trans
    def get_dates(self): return self._dates
    def get_converted(self): return self._converted
    def get_converted_date(self): return self._dates['first dutchie after lantern']
    
    def set_dates(self, key, val): self._dates[key] = val
    def set_converted(self, boolean): self._converted = boolean
20/5:
def standardize_date(date):
    ''' Formats a date as MM-DD-YYYY so the dates can be sorted
    alphanumerically in further data manipulation.
    '''    
    strkey = date.split('/')
    strlst = ['0' + i if len(i) < 2 else i for i in strkey]       
    newkey = '/'.join(strlst)
    return newkey

def standardize_dates(dict1):
    ''' Standardizes dates for an entire dictionary.
    '''
    dict2 = {}
    
    for i, key in enumerate(dict1.keys()):
        val = dict1[key]
        strkey = key.split('/')
        strlst = ['0' + i if len(i) < 2 else i for i in strkey]       
        newkey = '/'.join(strlst)
        dict2[newkey] = val
        
    return dict2
20/6:
customers_dict = {} #indexing Customer instances by name
dutchie_tr = {} #date + number of dutchie transactions
lantern_tr = {} #"", lantern

for ind, row in df.iterrows():

    #handle transaction data
    name = row[14]
    date = standardize_date(row[10])
    orderSource = row[22]
    t = Transaction(date, orderSource)
    
    #if we have a new customer, add to the list of customers
    if name not in customers_dict.keys():
        c = Customer(name)
        c.add_transaction(t)
        customers_dict[name] = c #key, value
        
    #otherwise, add a transaction to their name
    else:
        customers_dict[name].add_transaction(t) 
        
    #####
    
    #if dutchie transaction, add +1 to the count for this date; ditto Lantern
    if orderSource == "Dutchie":
        if date in dutchie_tr.keys():
            dutchie_tr[date] += 1
        else:
            dutchie_tr[date] = 1
        
    elif orderSource == "Lantern (Drizly)":
        if date in lantern_tr.keys():
            lantern_tr[date] += 1
        else:
            lantern_tr[date] = 1
            
    elif orderSource == "Walk In":
        pass
    
    else:
        raise ValueError("Unexpected order source: ", orderSource)
20/7:
total_transactions = 0
for k, v in customers_dict.items():
    total_transactions += v.get_num_trans()
    
assert total_transactions == 22473, f"Total: {total_transactions}"

#check the number of transactions for customers in the dataset.
#I've chosen customers who ordered on multiple days, not just once
m = customers_dict["Abby Warren"].get_num_trans()
assert m == 8, f"Num transactions: {n} "

n = customers_dict["Aashvi Shah"].get_num_trans()
assert n == 23, f"Num transactions: {n} " #32 if using new data - transactions(1).csv

s = sum(dutchie_tr.values())
assert s == 3806, f"Num Dutchie transactions: {s}"

t = sum(lantern_tr.values())
assert t == 18642, f"Num Lantern transactions: {t}"
20/8: dutchie_tr
20/9:
#sort by key, i.e. by date
dutchie_tr3 = sorted(dutchie_tr.items())
lantern_tr3 = sorted(lantern_tr.items())

#this isn't computationally efficient - optimize into one line if possible
dutchie_date = [i[0] for i in dutchie_tr3]
dutchie_orders = [j[1] for j in dutchie_tr3]
                  
lantern_date = [ii[0] for ii in lantern_tr3]
lantern_orders = [jj[1] for jj in lantern_tr3]
20/10: dutchie_date
20/11:
plt.figure()
plt.scatter(dutchie_date, dutchie_orders)
plt.scatter(lantern_date, lantern_orders)
plt.show()
20/12:
#nested loops are slow - see if it needs to be optimized
for k, cust in customers_dict.items():
    
    #store initial values of dates
    tr1 = cust.get_trans()[0] 
    
    for i, trans in enumerate(cust.get_trans()):
        
        source = trans.get_orderSource()
        date = trans.get_date()
        
        match source:
            case 'Dutchie':
                
                fd = cust.get_dates()['first dutchie']
                ld = cust.get_dates()['last dutchie']
                
                #initialize fd/ld or compare to existing fd/ld
                if (not fd or date < fd):
                    cust.set_dates('first dutchie', date)
                if (not ld or date > ld):
                    cust.set_dates('last dutchie', date)
                
            case 'Lantern (Drizly)':
                
                fl = cust.get_dates()['first lantern']
                ll = cust.get_dates()['last lantern']
                
                if (not fl or date < fl):
                    cust.set_dates('first lantern', date)
                elif (not ll or date > ll):
                    cust.set_dates('last lantern', date)               
                                   
            case 'Walk In':
                pass
            
            case default:
                raise ValueError('Unexpected item source')
            
        ###
        
    ###
    
    #assume they "converted" from using Lantern to Dutchie if they have
    #transactions from Dutchie after having used Lantern
    ll = cust.get_dates()['last lantern']
    ld = cust.get_dates()['last dutchie']
    fdal  = cust.get_dates()['first dutchie after lantern']
    
    print("\nCustomer: ", cust.get_name())
    
    #cust. must have made transactions w/ both services
    if (ll and ld and (ld > ll)):
        
        cust.set_converted(True)
        for i, trans in enumerate(cust.get_trans()):
            
            #find the minimum value of date after they last used Lantern
            tdate = trans.get_date()
            if tdate >= ll:
                
                if fdal == None:
                    cust.set_dates('first dutchie after lantern', tdate)
                    print('control statement 1')
                    
                #earlier than the date currently stored there
                elif tdate < fdal:
                    cust.set_dates('first dutchie after lantern', tdate)
                    print('control statement 2')
        
    else:
        cust.set_converted(False)
20/13:
#nested loops are slow - see if it needs to be optimized
for k, cust in customers_dict.items():
    
    #store initial values of dates
    tr1 = cust.get_trans()[0] 
    
    for i, trans in enumerate(cust.get_trans()):
        
        source = trans.get_orderSource()
        date = trans.get_date()
        
        match source:
            case 'Dutchie':
                
                fd = cust.get_dates()['first dutchie']
                ld = cust.get_dates()['last dutchie']
                
                #initialize fd/ld or compare to existing fd/ld
                if (not fd or date < fd):
                    cust.set_dates('first dutchie', date)
                if (not ld or date > ld):
                    cust.set_dates('last dutchie', date)
                
            case 'Lantern (Drizly)':
                
                fl = cust.get_dates()['first lantern']
                ll = cust.get_dates()['last lantern']
                
                if (not fl or date < fl):
                    cust.set_dates('first lantern', date)
                elif (not ll or date > ll):
                    cust.set_dates('last lantern', date)               
                                   
            case 'Walk In':
                pass
            
            case default:
                raise ValueError('Unexpected item source')
            
        ###
        
    ###
    
    #assume they "converted" from using Lantern to Dutchie if they have
    #transactions from Dutchie after having used Lantern
    ll = cust.get_dates()['last lantern']
    ld = cust.get_dates()['last dutchie']
    fdal  = cust.get_dates()['first dutchie after lantern']
        
    #cust. must have made transactions w/ both services
    if (ll and ld and (ld > ll)):
        
        print("\nCustomer: ", cust.get_name())
        cust.set_converted(True)
        for i, trans in enumerate(cust.get_trans()):
            
            #find the minimum value of date after they last used Lantern
            tdate = trans.get_date()
            if tdate >= ll:
                
                if fdal == None:
                    cust.set_dates('first dutchie after lantern', tdate)
                    print('control statement 1')
                    
                #earlier than the date currently stored there
                elif tdate < fdal:
                    cust.set_dates('first dutchie after lantern', tdate)
                    print('control statement 2')
        
    else:
        cust.set_converted(False)
20/14:
#nested loops are slow - see if it needs to be optimized
for k, cust in customers_dict.items():
    
    #store initial values of dates
    tr1 = cust.get_trans()[0] 
    
    for i, trans in enumerate(cust.get_trans()):
        
        source = trans.get_orderSource()
        date = trans.get_date()
        
        match source:
            case 'Dutchie':
                
                fd = cust.get_dates()['first dutchie']
                ld = cust.get_dates()['last dutchie']
                
                #initialize fd/ld or compare to existing fd/ld
                if (not fd or date < fd):
                    cust.set_dates('first dutchie', date)
                if (not ld or date > ld):
                    cust.set_dates('last dutchie', date)
                
            case 'Lantern (Drizly)':
                
                fl = cust.get_dates()['first lantern']
                ll = cust.get_dates()['last lantern']
                
                if (not fl or date < fl):
                    cust.set_dates('first lantern', date)
                elif (not ll or date > ll):
                    cust.set_dates('last lantern', date)               
                                   
            case 'Walk In':
                pass
            
            case default:
                raise ValueError('Unexpected item source')
            
        ###
        
    ###
    
    #assume they "converted" from using Lantern to Dutchie if they have
    #transactions from Dutchie after having used Lantern
    ll = cust.get_dates()['last lantern']
    ld = cust.get_dates()['last dutchie']
    fdal  = cust.get_dates()['first dutchie after lantern']
        
    #cust. must have made transactions w/ both services
    if (ll and ld and (ld > ll)):
        
        print("\nCustomer: ", cust.get_name())
        cust.set_converted(True)
        for i, trans in enumerate(cust.get_trans()):
            
            #find the minimum value of date after they last used Lantern
            tdate = trans.get_date()
            if tdate >= ll:
                
                print(fdal)
                if fdal == None:
                    cust.set_dates('first dutchie after lantern', tdate)
                    print('control statement 1')
                    
                #earlier than the date currently stored there
                elif tdate < fdal:
                    cust.set_dates('first dutchie after lantern', tdate)
                    print('control statement 2')
        
    else:
        cust.set_converted(False)
20/15:
#nested loops are slow - see if it needs to be optimized
for k, cust in customers_dict.items():
    
    #store initial values of dates
    tr1 = cust.get_trans()[0] 
    
    for i, trans in enumerate(cust.get_trans()):
        
        source = trans.get_orderSource()
        date = trans.get_date()
        
        match source:
            case 'Dutchie':
                
                fd = cust.get_dates()['first dutchie']
                ld = cust.get_dates()['last dutchie']
                
                #initialize fd/ld or compare to existing fd/ld
                if (not fd or date < fd):
                    cust.set_dates('first dutchie', date)
                if (not ld or date > ld):
                    cust.set_dates('last dutchie', date)
                
            case 'Lantern (Drizly)':
                
                fl = cust.get_dates()['first lantern']
                ll = cust.get_dates()['last lantern']
                
                if (not fl or date < fl):
                    cust.set_dates('first lantern', date)
                elif (not ll or date > ll):
                    cust.set_dates('last lantern', date)               
                                   
            case 'Walk In':
                pass
            
            case default:
                raise ValueError('Unexpected item source')
            
        ###
        
    ###
    
    #assume they "converted" from using Lantern to Dutchie if they have
    #transactions from Dutchie after having used Lantern
    ll = cust.get_dates()['last lantern']
    ld = cust.get_dates()['last dutchie']
    fdal  = cust.get_dates()['first dutchie after lantern']
        
    #cust. must have made transactions w/ both services
    if (ll and ld and (ld > ll)):
        
        name = cust.get_name()
        print("\nCustomer: ", name)
        cust.set_converted(True)
        for i, trans in enumerate(cust.get_trans()):
            
            #find the minimum value of date after they last used Lantern
            tdate = trans.get_date()
            if tdate >= ll:
                
                print(fdal)
                if fdal == None:
                    customers_dict[name].set_dates('first dutchie after lantern', tdate)
                    print('control statement 1')
                    
                #earlier than the date currently stored there
                elif tdate < fdal:
                    customers_dict[name].set_dates('first dutchie after lantern', tdate)
                    print('control statement 2')
        
    else:
        cust.set_converted(False)
20/16:
#nested loops are slow - see if it needs to be optimized
for k, cust in customers_dict.items():
    
    #store initial values of dates
    tr1 = cust.get_trans()[0] 
    
    for i, trans in enumerate(cust.get_trans()):
        
        source = trans.get_orderSource()
        date = trans.get_date()
        
        match source:
            case 'Dutchie':
                
                fd = cust.get_dates()['first dutchie']
                ld = cust.get_dates()['last dutchie']
                
                #initialize fd/ld or compare to existing fd/ld
                if (not fd or date < fd):
                    cust.set_dates('first dutchie', date)
                if (not ld or date > ld):
                    cust.set_dates('last dutchie', date)
                
            case 'Lantern (Drizly)':
                
                fl = cust.get_dates()['first lantern']
                ll = cust.get_dates()['last lantern']
                
                if (not fl or date < fl):
                    cust.set_dates('first lantern', date)
                elif (not ll or date > ll):
                    cust.set_dates('last lantern', date)               
                                   
            case 'Walk In':
                pass
            
            case default:
                raise ValueError('Unexpected item source')
            
        ###
        
    ###
    
    #assume they "converted" from using Lantern to Dutchie if they have
    #transactions from Dutchie after having used Lantern
    ll = cust.get_dates()['last lantern']
    ld = cust.get_dates()['last dutchie']
    fdal  = cust.get_dates()['first dutchie after lantern']
        
    #cust. must have made transactions w/ both services
    if (ll and ld and (ld > ll)):
        
        name = cust.get_name()
        print("\nCustomer: ", name)
        print("Initial value of FDAL: ", fdal)
        cust.set_converted(True)
        for i, trans in enumerate(cust.get_trans()):
            
            #find the minimum value of date after they last used Lantern
            tdate = trans.get_date()
            if tdate >= ll:
                
                print(fdal)
                if fdal == None:
                    customers_dict[name].set_dates('first dutchie after lantern', tdate)
                    print('control statement 1')
                    
                #earlier than the date currently stored there
                elif tdate < fdal:
                    customers_dict[name].set_dates('first dutchie after lantern', tdate)
                    print('control statement 2')
        
    else:
        cust.set_converted(False)
20/17:
#nested loops are slow - see if it needs to be optimized
for k, cust in customers_dict.items():
    
    #store initial values of dates
    tr1 = cust.get_trans()[0] 
    
    for i, trans in enumerate(cust.get_trans()):
        
        source = trans.get_orderSource()
        date = trans.get_date()
        
        match source:
            case 'Dutchie':
                
                fd = cust.get_dates()['first dutchie']
                ld = cust.get_dates()['last dutchie']
                
                #initialize fd/ld or compare to existing fd/ld
                if (not fd or date < fd):
                    cust.set_dates('first dutchie', date)
                if (not ld or date > ld):
                    cust.set_dates('last dutchie', date)
                
            case 'Lantern (Drizly)':
                
                fl = cust.get_dates()['first lantern']
                ll = cust.get_dates()['last lantern']
                
                if (not fl or date < fl):
                    cust.set_dates('first lantern', date)
                elif (not ll or date > ll):
                    cust.set_dates('last lantern', date)               
                                   
            case 'Walk In':
                pass
            
            case default:
                raise ValueError('Unexpected item source')
            
        ###
        
    ###
    
    #assume they "converted" from using Lantern to Dutchie if they have
    #transactions from Dutchie after having used Lantern
    ll = cust.get_dates()['last lantern']
    ld = cust.get_dates()['last dutchie']
    
    cust.set_dates('first dutchie after lantern', None)
    fdal  = cust.get_dates()['first dutchie after lantern']
        
    #cust. must have made transactions w/ both services
    if (ll and ld and (ld > ll)):
        
        name = cust.get_name()
        print("\nCustomer: ", name)
        print("Initial value of FDAL: ", fdal)
        cust.set_converted(True)
        for i, trans in enumerate(cust.get_trans()):
            
            #find the minimum value of date after they last used Lantern
            tdate = trans.get_date()
            if tdate >= ll:
                
                print(fdal)
                if fdal == None:
                    customers_dict[name].set_dates('first dutchie after lantern', tdate)
                    print('control statement 1')
                    
                #earlier than the date currently stored there
                elif tdate < fdal:
                    customers_dict[name].set_dates('first dutchie after lantern', tdate)
                    print('control statement 2')
        
    else:
        cust.set_converted(False)
20/18:
#nested loops are slow - see if it needs to be optimized
for k, cust in customers_dict.items():
    
    #store initial values of dates
    tr1 = cust.get_trans()[0] 
    
    for i, trans in enumerate(cust.get_trans()):
        
        source = trans.get_orderSource()
        date = trans.get_date()
        
        match source:
            case 'Dutchie':
                
                fd = cust.get_dates()['first dutchie']
                ld = cust.get_dates()['last dutchie']
                
                #initialize fd/ld or compare to existing fd/ld
                if (not fd or date < fd):
                    cust.set_dates('first dutchie', date)
                if (not ld or date > ld):
                    cust.set_dates('last dutchie', date)
                
            case 'Lantern (Drizly)':
                
                fl = cust.get_dates()['first lantern']
                ll = cust.get_dates()['last lantern']
                
                if (not fl or date < fl):
                    cust.set_dates('first lantern', date)
                elif (not ll or date > ll):
                    cust.set_dates('last lantern', date)               
                                   
            case 'Walk In':
                pass
            
            case default:
                raise ValueError('Unexpected item source')
            
        ###
        
    ###
    
    #assume they "converted" from using Lantern to Dutchie if they have
    #transactions from Dutchie after having used Lantern
    ll = cust.get_dates()['last lantern']
    ld = cust.get_dates()['last dutchie']
    
    cust.set_dates('first dutchie after lantern', None)
    fdal  = cust.get_dates()['first dutchie after lantern']
        
    #cust. must have made transactions w/ both services
    if (ll and ld and (ld > ll)):
        
        name = cust.get_name()
        print("\nCustomer: ", name)
        print("Initial value of FDAL: ", fdal)
        customers_dict[name].set_converted(True)
        for i, trans in enumerate(cust.get_trans()):
            
            #find the minimum value of date after they last used Lantern
            tdate = trans.get_date()
            if tdate >= ll:
                
                print(fdal)
                if fdal == None:
                    customers_dict[name].set_dates('first dutchie after lantern', tdate)
                    fdal = customers_dict[name].get_dates('first dutchie after lantern')
                    print('control statement 1')
                    
                #earlier than the date currently stored there
                elif tdate < fdal:
                    customers_dict[name].set_dates('first dutchie after lantern', tdate)
                    fdal = customers_dict[name].get_dates('first dutchie after lantern')
                    print('control statement 2')
        
    else:
        cust.set_converted(False)
20/19:
#nested loops are slow - see if it needs to be optimized
for k, cust in customers_dict.items():
    
    #store initial values of dates
    tr1 = cust.get_trans()[0] 
    
    for i, trans in enumerate(cust.get_trans()):
        
        source = trans.get_orderSource()
        date = trans.get_date()
        
        match source:
            case 'Dutchie':
                
                fd = cust.get_dates()['first dutchie']
                ld = cust.get_dates()['last dutchie']
                
                #initialize fd/ld or compare to existing fd/ld
                if (not fd or date < fd):
                    cust.set_dates('first dutchie', date)
                if (not ld or date > ld):
                    cust.set_dates('last dutchie', date)
                
            case 'Lantern (Drizly)':
                
                fl = cust.get_dates()['first lantern']
                ll = cust.get_dates()['last lantern']
                
                if (not fl or date < fl):
                    cust.set_dates('first lantern', date)
                elif (not ll or date > ll):
                    cust.set_dates('last lantern', date)               
                                   
            case 'Walk In':
                pass
            
            case default:
                raise ValueError('Unexpected item source')
            
        ###
        
    ###
    
    #assume they "converted" from using Lantern to Dutchie if they have
    #transactions from Dutchie after having used Lantern
    ll = cust.get_dates()['last lantern']
    ld = cust.get_dates()['last dutchie']
    
    cust.set_dates('first dutchie after lantern', None)
    fdal  = cust.get_dates()['first dutchie after lantern']
        
    #cust. must have made transactions w/ both services
    if (ll and ld and (ld > ll)):
        
        name = cust.get_name()
        print("\nCustomer: ", name)
        print("Initial value of FDAL: ", fdal)
        customers_dict[name].set_converted(True)
        for i, trans in enumerate(cust.get_trans()):
            
            #find the minimum value of date after they last used Lantern
            tdate = trans.get_date()
            if tdate >= ll:
                
                print(fdal)
                if fdal == None:
                    customers_dict[name].set_dates('first dutchie after lantern', tdate)
                    fdal = customers_dict[name].get_dates()['first dutchie after lantern']
                    print('control statement 1')
                    
                #earlier than the date currently stored there
                elif tdate < fdal:
                    customers_dict[name].set_dates('first dutchie after lantern', tdate)
                    fdal = customers_dict[name].get_dates()['first dutchie after lantern']
                    print('control statement 2')
        
    else:
        cust.set_converted(False)
20/20:
#nested loops are slow - see if it needs to be optimized
for k, cust in customers_dict.items():
    
    #store initial values of dates
    tr1 = cust.get_trans()[0] 
    
    for i, trans in enumerate(cust.get_trans()):
        
        source = trans.get_orderSource()
        date = trans.get_date()
        
        match source:
            case 'Dutchie':
                
                fd = cust.get_dates()['first dutchie']
                ld = cust.get_dates()['last dutchie']
                
                #initialize fd/ld or compare to existing fd/ld
                if (not fd or date < fd):
                    cust.set_dates('first dutchie', date)
                if (not ld or date > ld):
                    cust.set_dates('last dutchie', date)
                
            case 'Lantern (Drizly)':
                
                fl = cust.get_dates()['first lantern']
                ll = cust.get_dates()['last lantern']
                
                if (not fl or date < fl):
                    cust.set_dates('first lantern', date)
                elif (not ll or date > ll):
                    cust.set_dates('last lantern', date)               
                                   
            case 'Walk In':
                pass
            
            case default:
                raise ValueError('Unexpected item source')
            
        ###
        
    ###
    
    #assume they "converted" from using Lantern to Dutchie if they have
    #transactions from Dutchie after having used Lantern
    ll = cust.get_dates()['last lantern']
    ld = cust.get_dates()['last dutchie']
    
    cust.set_dates('first dutchie after lantern', None)
    fdal  = cust.get_dates()['first dutchie after lantern']
        
    #cust. must have made transactions w/ both services
    if (ll and ld and (ld > ll)):
        
        name = cust.get_name()
        print("\nCustomer: ", name)
        print("Initial value of FDAL: ", fdal)
        customers_dict[name].set_converted(True)
        for i, trans in enumerate(cust.get_trans()):
            
            #find the minimum value of date after they last used Lantern
            tdate = trans.get_date()
            if tdate >= ll:
                
                print(fdal)
                if fdal == None:
#                     customers_dict[name].set_dates('first dutchie after lantern', tdate)
#                     fdal = customers_dict[name].get_dates()['first dutchie after lantern']
                    cust.set_dates('first dutchie after lantern', tdate)
                    fdal = cust.get_dates()['first dutchie after lantern']
                    print('control statement 1')
                    
                #earlier than the date currently stored there
                elif tdate < fdal:
#                     customers_dict[name].set_dates('first dutchie after lantern', tdate)
#                     fdal = customers_dict[name].get_dates()['first dutchie after lantern']
                    cust.set_dates('first dutchie after lantern', tdate)
                    fdal = cust.get_dates()['first dutchie after lantern']
                    print('control statement 2')
        
    else:
        cust.set_converted(False)
20/21:
ath = customers_dict["Aleisha Thompson-Heinz"].get_converted_date()
assert ath == '06/09/2022', "Actual date: " + ath
#returns 8/22/22, her most recent transaction. she has several dutchie orders and 1 lantern order

ar = customers_dict["Allyson Rychlak"].get_converted_date()
assert ar == '07/19/2022', "Actual date: " + ar 
#returns 07/19/22. she only has 1 dutchie order and 1 lantern order

ab = customers_dict["Andrew Berlanstein"].get_converted_date()
assert ab == '06/16/2022', "Actual date: " + ab 
#returns 06/16/2022. he only has 1 dutchie order and 1 lantern order

#do more tests to see if they've "converted" (boolean), or test other
#dutchie/lantern users who haven't converted
20/22:
#nested loops are slow - see if it needs to be optimized
for k, cust in customers_dict.items():
    
    #store initial values of dates
    tr1 = cust.get_trans()[0] 
    
    for i, trans in enumerate(cust.get_trans()):
        
        source = trans.get_orderSource()
        date = trans.get_date()
        
        match source:
            case 'Dutchie':
                
                fd = cust.get_dates()['first dutchie']
                ld = cust.get_dates()['last dutchie']
                
                #initialize fd/ld or compare to existing fd/ld
                if (not fd or date < fd):
                    cust.set_dates('first dutchie', date)
                if (not ld or date > ld):
                    cust.set_dates('last dutchie', date)
                
            case 'Lantern (Drizly)':
                
                fl = cust.get_dates()['first lantern']
                ll = cust.get_dates()['last lantern']
                
                if (not fl or date < fl):
                    cust.set_dates('first lantern', date)
                elif (not ll or date > ll):
                    cust.set_dates('last lantern', date)               
                                   
            case 'Walk In':
                pass
            
            case default:
                raise ValueError('Unexpected item source')
            
        ###
        
    ###
    
    #assume they "converted" from using Lantern to Dutchie if they have
    #transactions from Dutchie after having used Lantern
    ll = cust.get_dates()['last lantern']
    ld = cust.get_dates()['last dutchie']
    
    cust.set_dates('first dutchie after lantern', None)
    fdal  = cust.get_dates()['first dutchie after lantern']
        
    #cust. must have made transactions w/ both services
    if (ll and ld and (ld > ll)):
        
        name = cust.get_name()
        print("\nCustomer: ", name)
        print("Initial value of FDAL: ", fdal)
        customers_dict[name].set_converted(True)
        for i, trans in enumerate(cust.get_trans()):
            
            #find the minimum value of date after they last used Lantern
            tdate = trans.get_date()
            if tdate >= ll and trans.get_orderSource() == 'Dutchie':
                
                print(fdal)
                if fdal == None:
#                     customers_dict[name].set_dates('first dutchie after lantern', tdate)
#                     fdal = customers_dict[name].get_dates()['first dutchie after lantern']
                    cust.set_dates('first dutchie after lantern', tdate)
                    fdal = cust.get_dates()['first dutchie after lantern']
                    print('control statement 1')
                    
                #earlier than the date currently stored there
                elif tdate < fdal:
#                     customers_dict[name].set_dates('first dutchie after lantern', tdate)
#                     fdal = customers_dict[name].get_dates()['first dutchie after lantern']
                    cust.set_dates('first dutchie after lantern', tdate)
                    fdal = cust.get_dates()['first dutchie after lantern']
                    print('control statement 2')
        
    else:
        cust.set_converted(False)
20/23:
ath = customers_dict["Aleisha Thompson-Heinz"].get_converted_date()
assert ath == '06/09/2022', "Actual date: " + ath
#returns 8/22/22, her most recent transaction. she has several dutchie orders and 1 lantern order

ar = customers_dict["Allyson Rychlak"].get_converted_date()
assert ar == '07/19/2022', "Actual date: " + ar 
#returns 07/19/22. she only has 1 dutchie order and 1 lantern order

ab = customers_dict["Andrew Berlanstein"].get_converted_date()
assert ab == '06/16/2022', "Actual date: " + ab 
#returns 06/16/2022. he only has 1 dutchie order and 1 lantern order

#do more tests to see if they've "converted" (boolean), or test other
#dutchie/lantern users who haven't converted
20/24:
ath = customers_dict["Aleisha Thompson-Heinz"].get_converted_date()
assert ath == '06/09/2022', "Actual date: " + ath
#returns 8/22/22, her most recent transaction. she has several dutchie orders and 1 lantern order

ar = customers_dict["Allyson Rychlak"].get_converted_date()
assert ar == '07/19/2022', "Actual date: " + ar 
#returns 07/19/22. she only has 1 dutchie order and 1 lantern order

ab = customers_dict["Andrew Berlanstein"].get_converted_date()
assert ab == '06/16/2022', "Actual date: " + ab 
#returns 06/16/2022. he only has 1 dutchie order and 1 lantern order

#do more tests to see if they've "converted" (boolean), or test other
#dutchie/lantern users who haven't converted
20/25:
#nested loops are slow - see if it needs to be optimized
for k, cust in customers_dict.items():
    
    #store initial values of dates
    tr1 = cust.get_trans()[0] 
    
    for i, trans in enumerate(cust.get_trans()):
        
        source = trans.get_orderSource()
        date = trans.get_date()
        
        match source:
            case 'Dutchie':
                
                fd = cust.get_dates()['first dutchie']
                ld = cust.get_dates()['last dutchie']
                
                #initialize fd/ld or compare to existing fd/ld
                if (not fd or date < fd):
                    cust.set_dates('first dutchie', date)
                if (not ld or date > ld):
                    cust.set_dates('last dutchie', date)
                
            case 'Lantern (Drizly)':
                
                fl = cust.get_dates()['first lantern']
                ll = cust.get_dates()['last lantern']
                
                if (not fl or date < fl):
                    cust.set_dates('first lantern', date)
                elif (not ll or date > ll):
                    cust.set_dates('last lantern', date)               
                                   
            case 'Walk In':
                pass
            
            case default:
                raise ValueError('Unexpected item source')
            
        ###
        
    ###
    
    #assume they "converted" from using Lantern to Dutchie if they have
    #transactions from Dutchie after having used Lantern
    ll = cust.get_dates()['last lantern']
    ld = cust.get_dates()['last dutchie']
    
    cust.set_dates('first dutchie after lantern', None)
    fdal  = cust.get_dates()['first dutchie after lantern']
        
    #cust. must have made transactions w/ both services
    if (ll and ld and (ld > ll)):
        
        name = cust.get_name()
        print("\nCustomer: ", name)
        print("Initial value of FDAL: ", fdal)
        cust.set_converted(True)
        
        for i, trans in enumerate(cust.get_trans()):
            
            #find the minimum value of date after they last used Lantern
            tdate = trans.get_date()
            if tdate >= ll and trans.get_orderSource() == 'Dutchie':
                
                print(fdal)
                if fdal == None:
                    cust.set_dates('first dutchie after lantern', tdate)
                    fdal = cust.get_dates()['first dutchie after lantern']
                    
                #earlier than the date currently stored there
                elif tdate < fdal:
                    cust.set_dates('first dutchie after lantern', tdate)
                    fdal = cust.get_dates()['first dutchie after lantern']
        
    else:
        cust.set_converted(False)
20/26:
#nested loops are slow - see if it needs to be optimized
for k, cust in customers_dict.items():
    
    #store initial values of dates
    tr1 = cust.get_trans()[0] 
    
    for i, trans in enumerate(cust.get_trans()):
        
        source = trans.get_orderSource()
        date = trans.get_date()
        
        match source:
            case 'Dutchie':
                
                fd = cust.get_dates()['first dutchie']
                ld = cust.get_dates()['last dutchie']
                
                #initialize fd/ld or compare to existing fd/ld
                if (not fd or date < fd):
                    cust.set_dates('first dutchie', date)
                if (not ld or date > ld):
                    cust.set_dates('last dutchie', date)
                
            case 'Lantern (Drizly)':
                
                fl = cust.get_dates()['first lantern']
                ll = cust.get_dates()['last lantern']
                
                if (not fl or date < fl):
                    cust.set_dates('first lantern', date)
                elif (not ll or date > ll):
                    cust.set_dates('last lantern', date)               
                                   
            case 'Walk In':
                pass
            
            case default:
                raise ValueError('Unexpected item source')
            
        ###
        
    ###
    
    #assume they "converted" from using Lantern to Dutchie if they have
    #transactions from Dutchie after having used Lantern
    ll = cust.get_dates()['last lantern']
    ld = cust.get_dates()['last dutchie']
    
    cust.set_dates('first dutchie after lantern', None)
    fdal  = cust.get_dates()['first dutchie after lantern']
        
    #cust. must have made transactions w/ both services
    if (ll and ld and (ld > ll)):
        
        name = cust.get_name()
        cust.set_converted(True)
        
        for i, trans in enumerate(cust.get_trans()):
            
            #find the minimum value of date after they last used Lantern
            tdate = trans.get_date()
            if tdate >= ll and trans.get_orderSource() == 'Dutchie':
                
                print(fdal)
                if fdal == None:
                    cust.set_dates('first dutchie after lantern', tdate)
                    fdal = cust.get_dates()['first dutchie after lantern']
                    
                #earlier than the date currently stored there
                elif tdate < fdal:
                    cust.set_dates('first dutchie after lantern', tdate)
                    fdal = cust.get_dates()['first dutchie after lantern']
        
    else:
        cust.set_converted(False)
20/27:
#nested loops are slow - see if it needs to be optimized
for k, cust in customers_dict.items():
    
    #store initial values of dates
    tr1 = cust.get_trans()[0] 
    
    for i, trans in enumerate(cust.get_trans()):
        
        source = trans.get_orderSource()
        date = trans.get_date()
        
        match source:
            case 'Dutchie':
                
                fd = cust.get_dates()['first dutchie']
                ld = cust.get_dates()['last dutchie']
                
                #initialize fd/ld or compare to existing fd/ld
                if (not fd or date < fd):
                    cust.set_dates('first dutchie', date)
                if (not ld or date > ld):
                    cust.set_dates('last dutchie', date)
                
            case 'Lantern (Drizly)':
                
                fl = cust.get_dates()['first lantern']
                ll = cust.get_dates()['last lantern']
                
                if (not fl or date < fl):
                    cust.set_dates('first lantern', date)
                elif (not ll or date > ll):
                    cust.set_dates('last lantern', date)               
                                   
            case 'Walk In':
                pass
            
            case default:
                raise ValueError('Unexpected item source')
            
        ###
        
    ###
    
    #assume they "converted" from using Lantern to Dutchie if they have
    #transactions from Dutchie after having used Lantern
    ll = cust.get_dates()['last lantern']
    ld = cust.get_dates()['last dutchie']
    
    cust.set_dates('first dutchie after lantern', None)
    fdal  = cust.get_dates()['first dutchie after lantern']
        
    #cust. must have made transactions w/ both services
    if (ll and ld and (ld > ll)):
        
        name = cust.get_name()
        cust.set_converted(True)
        
        for i, trans in enumerate(cust.get_trans()):
            
            #find the minimum value of date after they last used Lantern
            tdate = trans.get_date()
            if tdate >= ll and trans.get_orderSource() == 'Dutchie':
                
                if fdal == None:
                    cust.set_dates('first dutchie after lantern', tdate)
                    fdal = cust.get_dates()['first dutchie after lantern']
                    
                #earlier than the date currently stored there
                elif tdate < fdal:
                    cust.set_dates('first dutchie after lantern', tdate)
                    fdal = cust.get_dates()['first dutchie after lantern']
        
    else:
        cust.set_converted(False)
20/28:
ath = customers_dict["Aleisha Thompson-Heinz"].get_converted_date()
assert ath == '06/09/2022', "Actual date: " + ath
#returns 8/22/22, her most recent transaction. she has several dutchie orders and 1 lantern order

ar = customers_dict["Allyson Rychlak"].get_converted_date()
assert ar == '07/19/2022', "Actual date: " + ar 
#returns 07/19/22. she only has 1 dutchie order and 1 lantern order

ab = customers_dict["Andrew Berlanstein"].get_converted_date()
assert ab == '06/16/2022', "Actual date: " + ab 
#returns 06/16/2022. he only has 1 dutchie order and 1 lantern order

#do more tests to see if they've "converted" (boolean), or test other
#dutchie/lantern users who haven't converted
20/29:
ath = customers_dict["Aleisha Thompson-Heinz"].get_converted_date()
assert ath == '06/09/2022', "Actual date: " + ath
#returns 8/22/22, her most recent transaction. she has several dutchie orders and 1 lantern order

ar = customers_dict["Allyson Rychlak"].get_converted_date()
assert ar == '07/19/2022', "Actual date: " + ar 
#returns 07/19/22. she only has 1 dutchie order and 1 lantern order

ab = customers_dict["Andrew Berlanstein"].get_converted_date()
assert ab == '06/16/2022', "Actual date: " + ab 
#returns 06/16/2022. he only has 1 dutchie order and 1 lantern order

#do more tests to see if they've "converted" (boolean), or test other
#dutchie/lantern users who haven't converted

assert ar.get_converted()
assert ab.get_converted()
assert ath.get_converted()
20/30:
ath = customers_dict["Aleisha Thompson-Heinz"].get_converted_date()
assert ath == '06/09/2022', "Actual date: " + ath
#returns 8/22/22, her most recent transaction. she has several dutchie orders and 1 lantern order

ar = customers_dict["Allyson Rychlak"].get_converted_date()
assert ar == '07/19/2022', "Actual date: " + ar 
#returns 07/19/22. she only has 1 dutchie order and 1 lantern order

ab = customers_dict["Andrew Berlanstein"].get_converted_date()
assert ab == '06/16/2022', "Actual date: " + ab 
#returns 06/16/2022. he only has 1 dutchie order and 1 lantern order

#do more tests to see if they've "converted" (boolean), or test other
#dutchie/lantern users who haven't converted

assert customers_dict["Aleisha Thompson-Heinz"].get_converted()
assert customers_dict["Allyson Rychlak"].get_converted()
assert customers_dict["Andrew Berlanstein"].get_converted()
20/31:
ath = customers_dict["Aleisha Thompson-Heinz"].get_converted_date()
assert ath == '06/09/2022', "Actual date: " + ath
#returns 8/22/22, her most recent transaction. she has several dutchie orders and 1 lantern order

ar = customers_dict["Allyson Rychlak"].get_converted_date()
assert ar == '07/19/2022', "Actual date: " + ar 
#returns 07/19/22. she only has 1 dutchie order and 1 lantern order

ab = customers_dict["Andrew Berlanstein"].get_converted_date()
assert ab == '06/16/2022', "Actual date: " + ab 
#returns 06/16/2022. he only has 1 dutchie order and 1 lantern order

#do more tests to see if they've "converted" (boolean), or test other
#dutchie/lantern users who haven't converted

assert customers_dict["Aleisha Thompson-Heinz"].get_converted()
assert customers_dict["Allyson Rychlak"].get_converted()
assert customers_dict["Andrew Berlanstein"].get_converted()
assert not customers_dict["Alesha M. Gunn"].get_converted() #Lantern customer only
assert not customers_dict["Dave Read"].get_converted() #Lantern customer only
20/32:
ath = customers_dict["Aleisha Thompson-Heinz"].get_converted_date()
assert ath == '06/09/2022', "Actual date: " + ath
#returns 8/22/22, her most recent transaction. she has several dutchie orders and 1 lantern order

ar = customers_dict["Allyson Rychlak"].get_converted_date()
assert ar == '07/19/2022', "Actual date: " + ar 
#returns 07/19/22. she only has 1 dutchie order and 1 lantern order

ab = customers_dict["Andrew Berlanstein"].get_converted_date()
assert ab == '06/16/2022', "Actual date: " + ab 
#returns 06/16/2022. he only has 1 dutchie order and 1 lantern order

#do more tests to see if they've "converted" (boolean), or test other
#dutchie/lantern users who haven't converted

assert customers_dict["Aleisha Thompson-Heinz"].get_converted()
assert customers_dict["Allyson Rychlak"].get_converted()
assert customers_dict["Andrew Berlanstein"].get_converted()
assert not customers_dict["Alesha M. Gunn"].get_converted() #Lantern customer only
assert not customers_dict["Dave Read"].get_converted() #Lantern customer only
20/33:
converted_dict = {}
for k, cust in customers_dict():
    
    if not cust.get_converted():
        continue
        
    date = cust.get_converted_date()
        
    if date in converted_dict.keys():
        converted_dict[date] += 1
    else:
        converted_dict[date] = 1
20/34:
converted_dict = {}
for k, cust in customers_dict:
    
    if not cust.get_converted():
        continue
        
    date = cust.get_converted_date()
        
    if date in converted_dict.keys():
        converted_dict[date] += 1
    else:
        converted_dict[date] = 1
20/35:
converted_dict = {}
for k, cust in customers_dict.items():
    
    if not cust.get_converted():
        continue
        
    date = cust.get_converted_date()
        
    if date in converted_dict.keys():
        converted_dict[date] += 1
    else:
        converted_dict[date] = 1
20/36: converted_dict
20/37: sorted(converted_dict.items())
20/38:
ath = customers_dict["Aleisha Thompson-Heinz"].get_converted_date()
assert ath == '06/09/2022', "Actual date: " + ath
#she has several dutchie orders and 1 lantern order

ar = customers_dict["Allyson Rychlak"].get_converted_date()
assert ar == '07/19/2022', "Actual date: " + ar 
#she only has 1 dutchie order and 1 lantern order

ab = customers_dict["Andrew Berlanstein"].get_converted_date()
assert ab == '06/16/2022', "Actual date: " + ab 
#he only has 1 dutchie order and 1 lantern order

#do more tests to see if they've "converted" (boolean), or test other
#dutchie/lantern users who haven't converted

assert customers_dict["Aleisha Thompson-Heinz"].get_converted()
assert customers_dict["Allyson Rychlak"].get_converted()
assert customers_dict["Andrew Berlanstein"].get_converted()
assert not customers_dict["Alesha M. Gunn"].get_converted() #Lantern customer only
assert not customers_dict["Dave Read"].get_converted() #Dutchie customer only

assert not customers_dict["Eva Garrett"].get_converted()
20/39:
ath = customers_dict["Aleisha Thompson-Heinz"].get_converted_date()
assert ath == '06/09/2022', "Actual date: " + ath
#she has several dutchie orders and 1 lantern order

ar = customers_dict["Allyson Rychlak"].get_converted_date()
assert ar == '07/19/2022', "Actual date: " + ar 
#she only has 1 dutchie order and 1 lantern order

ab = customers_dict["Andrew Berlanstein"].get_converted_date()
assert ab == '06/16/2022', "Actual date: " + ab 
#he only has 1 dutchie order and 1 lantern order

#do more tests to see if they've "converted" (boolean), or test other
#dutchie/lantern users who haven't converted

assert customers_dict["Aleisha Thompson-Heinz"].get_converted()
assert customers_dict["Allyson Rychlak"].get_converted()
assert customers_dict["Andrew Berlanstein"].get_converted()
assert not customers_dict["Alesha M. Gunn"].get_converted() #Lantern customer only
assert not customers_dict["Dave Read"].get_converted() #Dutchie customer only

assert not customers_dict["Eva Garrett"].get_converted()
20/40:
converted_dict = {}
for k, cust in customers_dict.items():
    
    if not cust.get_converted():
        continue
        
    date = cust.get_converted_date()
    print("NAME AND DATE: ", cust.get_name(), " ", date)
        
    if date in converted_dict.keys():
        converted_dict[date] += 1
    else:
        converted_dict[date] = 1
20/41:
dates_axis = [i[0] for i in sorted_dates]
num_conversions = [i[1] for i in sorted_dates]
20/42: sorted_dates = sorted(converted_dict.items())
20/43:
dates_axis = [i[0] for i in sorted_dates]
num_conversions = [i[1] for i in sorted_dates]
20/44:
sorted_dates = sorted(converted_dict.items())
sorted_dates
20/45:
dates_axis = [i[0] for i in sorted_dates]
num_conversions = [i[1] for i in sorted_dates]
20/46:
dates_axis = [i[0] for i in sorted_dates]
num_conversions = [i[1] for i in sorted_dates]

dates_axis
num_conversions
20/47:
dates_axis = [i[0] for i in sorted_dates]
num_conversions = [i[1] for i in sorted_dates]

dates_axis
20/48:
dates_list = [i[0] for i in sorted_dates]
conversions_list = [i[1] for i in sorted_dates]

dates_list
20/49:
data = list(zip(dates_list, conversions_list))
df = pd.DataFrame(data, Columns = ['Date','Quantity'])

df['Date'] = pd.to_datetime(df['Date']) - pd.to_timedelta(7, unit='d')
df = df.groupby(['Name', pd.Grouper(key='Date', freq='W-MON')])['Quantity']
    .sum()
    .reset_index()
    .sort_values('Date')
20/50:
data = list(zip(dates_list, conversions_list))
df = pd.DataFrame(data, Columns = ['Date','Quantity'])

df['Date'] = pd.to_datetime(df['Date']) - pd.to_timedelta(7, unit='d')
df = df.groupby(['Name', pd.Grouper(key='Date', freq='W-MON')])['Quantity'] \
    .sum() \
    .reset_index() \
    .sort_values('Date')
20/51:
data = list(zip(dates_list, conversions_list))
df = pd.DataFrame(data, columns = ['Date','Quantity'])

df['Date'] = pd.to_datetime(df['Date']) - pd.to_timedelta(7, unit='d')
df = df.groupby(['Name', pd.Grouper(key='Date', freq='W-MON')])['Quantity'] \
    .sum() \
    .reset_index() \
    .sort_values('Date')
20/52:
data = list(zip(dates_list, conversions_list))
df = pd.DataFrame(data, columns = ['Date','Quantity'])

df['Date'] = pd.to_datetime(df['Date']) - pd.to_timedelta(7, unit='d')
df = df.groupby(['Quantity', pd.Grouper(key='Date', freq='W-MON')])['Quantity'] \
    .sum() \
    .reset_index() \
    .sort_values('Date')
20/53:
data = list(zip(dates_list, conversions_list))
df = pd.DataFrame(data, columns = ['Date','Quantity'])

df['Date'] = pd.to_datetime(df['Date']) - pd.to_timedelta(7, unit='d')
df = df.groupby(['Date', pd.Grouper(key='Date', freq='W-MON')])['Quantity'] \
    .sum() \
    .reset_index() \
    .sort_values('Date')
20/54:
data = list(zip(dates_list, conversions_list))
df = pd.DataFrame(data, columns = ['Date','Quantity'])

df['Date'] = pd.to_datetime(df['Date']) - pd.to_timedelta(7, unit='d')
df = df.groupby([pd.Grouper(key='Date', freq='W')])['Quantity'].sum()
20/55:
data = list(zip(dates_list, conversions_list))
df = pd.DataFrame(data, columns = ['Date','Quantity'])

df['Date'] = pd.to_datetime(df['Date']) - pd.to_timedelta(7, unit='d')
df = df.groupby([pd.Grouper(key='Date', freq='W')])['Quantity'].sum()
20/56:
data = list(zip(dates_list, conversions_list))
df = pd.DataFrame(data, columns = ['Date','Quantity'])

df['Date'] = pd.to_datetime(df['Date']) - pd.to_timedelta(7, unit='d')
df = df.groupby([pd.Grouper(key='Date', freq='W')])['Quantity'].sum()

df
20/57:
data = list(zip(dates_list, conversions_list))
df = pd.DataFrame(data, columns = ['Date','Quantity'])

df['Date'] = pd.to_datetime(df['Date']) - pd.to_timedelta(7, unit='d')
df = df.groupby([pd.Grouper(key='Date', freq='M')])['Quantity'].sum()

df
20/58:
data = list(zip(dates_list, conversions_list))
df = pd.DataFrame(data, columns = ['Date','Quantity'])

df['Date'] = pd.to_datetime(df['Date']) - pd.to_timedelta(7, unit='d')
df = df.groupby([pd.Grouper(key='Date', freq='M')])['Quantity'].sum()
20/59: df
20/60: df.to_numpy()
20/61: df['Date'].to_numpy()
20/62: df.to_numpy()
20/63: df.rows()
20/64: df.index
20/65: list(df.index)
20/66: (df.index)
20/67: df.index.strftime(“%Y-%m-%d”)
20/68: df.index.strftime('%Y-%m-%d')
20/69: df.index.strftime('%m-%d-%Y')
20/70: list(df.index.strftime('%m-%d-%Y'))
20/71: df.to_numpy()
20/72: np.array(list(df.index.strftime('%m-%d-%Y')))
20/73: np.array(df.index.strftime('%m-%d-%Y')) #row labels -> convert datatype -> store as array
20/74: np.array(df.index.strftime('%m-%d-%Y')) #row labels -> convert datatype -> store as array
20/75: np.asarray(df.index.strftime('%m-%d-%Y')) #row labels -> convert datatype -> store as array
20/76:
weeks = np.array(df.index.strftime('%m-%d-%Y')) #row labels -> convert datatype -> store as array
qtys = df.to_numpy() #saves quantities only
20/77:
weeks = np.array(df.index.strftime('%m-%d-%Y')) #row labels -> convert datatype -> store as array
qtys = df.to_numpy() #saves quantities only
20/78:
labels = np.array(df.index.strftime('%m-%d-%Y')) #row labels -> convert datatype -> store as array
qtys = df.to_numpy() #saves Quantity column only
20/79:
plt.figure()
indeces = np.arange(len(qtys))
plt.bar(indeces, qtys, label = labels)
20/80:
labels = np.array(df.index.strftime('%m-%d-%Y')) #row labels -> convert datatype -> store as array
qtys = df.to_numpy() #saves Quantity column only
20/81:
plt.figure()
indeces = np.arange(len(qtys))
plt.bar(indeces, qtys, label = labels)
20/82:
plt.figure()
indeces = np.arange(len(qtys))
plt.bar(labels, qtys)
20/83:
plt.figure()
indeces = np.arange(len(qtys))
plt.bar(labels, qtys)
plt.xlabel("Date, end of month")
plt.ylabel("Number of customers converted")
20/84:
plt.figure()
indeces = np.arange(len(qtys))
plt.bar(labels, qtys)
plt.xlabel("Date, end of month")
plt.ylabel("Number of customers converted")
plt.title("Customers Converted from Lantern to Dutchie")
20/85:
plt.figure()
indeces = np.arange(len(qtys))
plt.bar(labels, qtys, width = 1.2)
plt.xlabel("Date, end of month")
plt.ylabel("Number of customers converted")
plt.title("Customers Converted from Lantern to Dutchie")
20/86:
plt.figure(figsize = (1.5, 2.5))
indeces = np.arange(len(qtys))
plt.bar(labels, qtys, width = 1.2)
plt.xlabel("Date, end of month")
plt.ylabel("Number of customers converted")
plt.title("Customers Converted from Lantern to Dutchie")
20/87:
plt.figure(figsize = (4.5, 3.5))
indeces = np.arange(len(qtys))
plt.bar(labels, qtys, width = 1.2)
plt.xlabel("Date, end of month")
plt.ylabel("Number of customers converted")
plt.title("Customers Converted from Lantern to Dutchie")
20/88:
plt.figure(figsize = (7.5, 5))
indeces = np.arange(len(qtys))
plt.bar(labels, qtys, width = 1.2)
plt.xlabel("Date, end of month")
plt.ylabel("Number of customers converted")
plt.title("Customers Converted from Lantern to Dutchie")
20/89:
plt.figure(figsize = (8, 5))
indeces = np.arange(len(qtys))
plt.bar(labels, qtys)
plt.xlabel("Date, end of month")
plt.ylabel("Number of customers converted")
plt.title("Customers Converted from Lantern to Dutchie")
20/90:
plt.figure()
plt.scatter(dutchie_date, dutchie_orders)
plt.scatter(lantern_date, lantern_orders)
plt.xlabel("Date")
plt.ylabel("Number of recorded transactions")
plt.title("Dutchie and Lantern Purchases by Date")

plt.show()
20/91:
plt.figure()
plt.scatter(dutchie_date, dutchie_orders)
plt.scatter(lantern_date, lantern_orders)
plt.xlabel("Date")
plt.ylabel("Number of recorded transactions")
plt.title("Dutchie and Lantern Purchases by Date")
21/1:
total_transactions = 0
for k, v in customers_dict.items():
    total_transactions += v.get_num_trans()
    
assert total_transactions == 22473, f"Total: {total_transactions}"

#check the number of transactions for customers in the dataset.
#I've chosen customers who ordered on multiple days, not just once
m = customers_dict["Abby Warren"].get_num_trans()
assert m == 8, f"Num transactions: {n} "

n = customers_dict["Aashvi Shah"].get_num_trans()
assert n == 23, f"Num transactions: {n} " #32 if using new data - transactions(1).csv

s = sum(dutchie_tr.values())
assert s == 3806, f"Num Dutchie transactions: {s}"

t = sum(lantern_tr.values())
assert t == 18642, f"Num Lantern transactions: {t}"
21/2:
import numpy as np
%matplotlib inline
import matplotlib.pyplot as plt
import pandas as pd
import collections as co
import datetime as dt
21/3:
df = pd.read_csv(r"C:\Users\seanp\Downloads\Python Lessons\transactions.csv")
df
21/4:
total_transactions = 0
for k, v in customers_dict.items():
    total_transactions += v.get_num_trans()
    
assert total_transactions == 22473, f"Total: {total_transactions}"

#check the number of transactions for customers in the dataset.
#I've chosen customers who ordered on multiple days, not just once
m = customers_dict["Abby Warren"].get_num_trans()
assert m == 8, f"Num transactions: {n} "

n = customers_dict["Aashvi Shah"].get_num_trans()
assert n == 23, f"Num transactions: {n} " #32 if using new data - transactions(1).csv

s = sum(dutchie_tr.values())
assert s == 3806, f"Num Dutchie transactions: {s}"

t = sum(lantern_tr.values())
assert t == 18642, f"Num Lantern transactions: {t}"
21/5:
df = pd.read_csv(r"C:\Users\seanp\Downloads\Python Lessons\Streamlit App\transactions.csv")
df
21/6:
df = pd.read_csv(r"C:\Users\seanp\Downloads\Python Lessons\Streamlit App\transactions.csv")
df
21/7:
for ind, column in enumerate(df.columns):
    print(ind, column)
21/8:
class Transaction:
    
    def __init__(self, date, orderSource):
        self._date = date
        self._orderSource = orderSource
        
    def get_date(self): return self._date
    def get_orderSource(self): return self._orderSource
        

class Customer:
    
    def __init__(self, name):
        #member data relating to total transactions made
        self._name = name
        self._transactions = []
        self._num_trans = 0
        self._num_dutchie = 0
        self._num_lantern = 0
        
        #member data relating to whether they've switched from L to D
        self._dates = {
            'first dutchie': None,
            'last dutchie': None,
            'first lantern': None,
            'last lantern': None,
            'first dutchie after lantern': None
        }
        self._converted = None #default, don't know if they switched        
    
    def add_transaction(self, Transaction):
        self._transactions.append(Transaction)
        self._num_trans += 1
        if Transaction._orderSource == "Dutchie":
            self._num_dutchie += 1
        elif Transaction._orderSource == "Lantern (Drizly)":
            self._num_lantern += 1
        elif Transaction._orderSource == "Walk In":
            pass
        else:
            raise ValueError("Unexpected order source encountered: ", Transaction._orderSource)
        
    def get_name(self): return self._name
    def get_trans(self): return self._transactions
    def get_num_trans(self): return self._num_trans
    def get_dates(self): return self._dates
    def get_converted(self): return self._converted
    def get_converted_date(self): return self._dates['first dutchie after lantern']
    
    def set_dates(self, key, val): self._dates[key] = val
    def set_converted(self, boolean): self._converted = boolean
21/9:
def standardize_date(date):
    ''' Formats a date as MM-DD-YYYY so the dates can be sorted
    alphanumerically in further data manipulation.
    #6/9/2022
    #6/10/2022
    #06/09/2022
    #06/10/2022
    '''    
    strkey = date.split('/')
    strlst = ['0' + i if len(i) < 2 else i for i in strkey]       
    newkey = '/'.join(strlst)
    return newkey

def standardize_dates(dict1):
    ''' Standardizes dates for an entire dictionary.
    '''
    dict2 = {}
    
    for i, key in enumerate(dict1.keys()):
        val = dict1[key]
        strkey = key.split('/')
        strlst = ['0' + i if len(i) < 2 else i for i in strkey]       
        newkey = '/'.join(strlst)
        dict2[newkey] = val
        
    return dict2
21/10:
customers_dict = {} #indexing Customer instances by name
dutchie_tr = {} #date + number of dutchie transactions
lantern_tr = {} #"", lantern

for ind, row in df.iterrows():

    #handle transaction data
    name = row[14]
    date = standardize_date(row[10])
    orderSource = row[22]
    t = Transaction(date, orderSource)
    
    #if we have a new customer, add to the list of customers
    if name not in customers_dict.keys():
        c = Customer(name)
        c.add_transaction(t)
        customers_dict[name] = c #key, value
        
    #otherwise, add a transaction to their name
    else:
        customers_dict[name].add_transaction(t) 
        
    #####
    
    #if dutchie transaction, add +1 to the count for this date; ditto Lantern
    if orderSource == "Dutchie":
        if date in dutchie_tr.keys():
            dutchie_tr[date] += 1
        else:
            dutchie_tr[date] = 1
        
    elif orderSource == "Lantern (Drizly)":
        if date in lantern_tr.keys():
            lantern_tr[date] += 1
        else:
            lantern_tr[date] = 1
            
    elif orderSource == "Walk In":
        pass
    
    else:
        raise ValueError("Unexpected order source: ", orderSource)
21/11:
total_transactions = 0
for k, v in customers_dict.items():
    total_transactions += v.get_num_trans()
    
assert total_transactions == 22473, f"Total: {total_transactions}"

#check the number of transactions for customers in the dataset.
#I've chosen customers who ordered on multiple days, not just once
m = customers_dict["Abby Warren"].get_num_trans()
assert m == 8, f"Num transactions: {n} "

n = customers_dict["Aashvi Shah"].get_num_trans()
assert n == 23, f"Num transactions: {n} " #32 if using new data - transactions(1).csv

s = sum(dutchie_tr.values())
assert s == 3806, f"Num Dutchie transactions: {s}"

t = sum(lantern_tr.values())
assert t == 18642, f"Num Lantern transactions: {t}"
21/12:
total_transactions = 0
for k, v in customers_dict.items():
    total_transactions += v.get_num_trans()
    
assert total_transactions == 22473, f"Total: {total_transactions}"

#check the number of transactions for customers in the dataset.
#I've chosen customers who ordered on multiple days, not just once
m = customers_dict["Abby Warren"].get_num_trans()
assert m == 9, f"Num transactions: {n} "

n = customers_dict["Aashvi Shah"].get_num_trans()
assert n == 23, f"Num transactions: {n} " #32 if using new data - transactions(1).csv

s = sum(dutchie_tr.values())
assert s == 3806, f"Num Dutchie transactions: {s}"

t = sum(lantern_tr.values())
assert t == 18642, f"Num Lantern transactions: {t}"
21/13:
total_transactions = 0
for k, v in customers_dict.items():
    total_transactions += v.get_num_trans()
    
assert total_transactions == 22473, f"Total: {total_transactions}"

#check the number of transactions for customers in the dataset.
#I've chosen customers who ordered on multiple days, not just once
m = customers_dict["Abby Warren"].get_num_trans()
assert m == 9, f"Num transactions: {m} "

n = customers_dict["Aashvi Shah"].get_num_trans()
assert n == 23, f"Num transactions: {n} " #32 if using new data - transactions(1).csv

s = sum(dutchie_tr.values())
assert s == 3806, f"Num Dutchie transactions: {s}"

t = sum(lantern_tr.values())
assert t == 18642, f"Num Lantern transactions: {t}"
21/14:
total_transactions = 0
for k, v in customers_dict.items():
    total_transactions += v.get_num_trans()
    
assert total_transactions == 22473, f"Total: {total_transactions}"

#check the number of transactions for customers in the dataset.
#I've chosen customers who ordered on multiple days, not just once
m = customers_dict["Abby Warren"].get_num_trans()
assert m == 8, f"Num transactions: {m} "

n = customers_dict["Aashvi Shah"].get_num_trans()
assert n == 23, f"Num transactions: {n} " #32 if using new data - transactions(1).csv

s = sum(dutchie_tr.values())
assert s == 3806, f"Num Dutchie transactions: {s}"

t = sum(lantern_tr.values())
assert t == 18642, f"Num Lantern transactions: {t}"
21/15: dutchie_tr
21/16:
#sort by key, i.e. by date
dutchie_tr3 = sorted(dutchie_tr.items())
lantern_tr3 = sorted(lantern_tr.items())

#this isn't computationally efficient - optimize into one line if possible
dutchie_date = [i[0] for i in dutchie_tr3]
dutchie_orders = [j[1] for j in dutchie_tr3]
                  
lantern_date = [ii[0] for ii in lantern_tr3]
lantern_orders = [jj[1] for jj in lantern_tr3]
21/17: dutchie_tr3
21/18:
ath = customers_dict["Aleisha Thompson-Heinz"].get_converted_date()
assert ath == '06/09/2022', "Actual date: " + ath
#she has several dutchie orders and 1 lantern order

ar = customers_dict["Allyson Rychlak"].get_converted_date()
assert ar == '07/19/2022', "Actual date: " + ar 
#she only has 1 dutchie order and 1 lantern order

ab = customers_dict["Andrew Berlanstein"].get_converted_date()
assert ab == '06/16/2022', "Actual date: " + ab 
#he only has 1 dutchie order and 1 lantern order

#do more tests to see if they've "converted" (boolean), or test other
#dutchie/lantern users who haven't converted

assert customers_dict["Aleisha Thompson-Heinz"].get_converted()
assert customers_dict["Allyson Rychlak"].get_converted()
assert customers_dict["Andrew Berlanstein"].get_converted()
assert not customers_dict["Alesha M. Gunn"].get_converted() #Lantern customer only
assert not customers_dict["Dave Read"].get_converted() #Dutchie customer only
assert not customers_dict["Eva Garrett"].get_converted() #used Dutchie, went back to Lantern
21/19:
#nested loops are slow - see if it needs to be optimized
for k, cust in customers_dict.items():
    
    for trans in cust.get_trans():
        
        source = trans.get_orderSource()
        date = trans.get_date()
        
        match source:
            case 'Dutchie':
                
                fd = cust.get_dates()['first dutchie'] 
                ld = cust.get_dates()['last dutchie']
                
                #initialize fd/ld or compare to existing fd/ld
                if (not fd or date < fd):
                    cust.set_dates('first dutchie', date)
                if (not ld or date > ld):
                    cust.set_dates('last dutchie', date)
                
            case 'Lantern (Drizly)':
                
                fl = cust.get_dates()['first lantern']
                ll = cust.get_dates()['last lantern']
                
                if (not fl or date < fl):
                    cust.set_dates('first lantern', date)
                elif (not ll or date > ll):
                    cust.set_dates('last lantern', date)               
                                   
            case 'Walk In':
                pass
                
            case default:
                raise ValueError('Unexpected item source')
            
        ###
        
    ###
    
    #assume they "converted" from using Lantern to Dutchie if they have
    #transactions from Dutchie after having used Lantern
    ll = cust.get_dates()['last lantern']
    ld = cust.get_dates()['last dutchie']
    
    cust.set_dates('first dutchie after lantern', None)
    fdal  = cust.get_dates()['first dutchie after lantern']
        
    #cust. must have made transactions w/ both services
    if (ll and ld and (ld > ll)):
        
        name = cust.get_name()
        cust.set_converted(True)
        
        for trans in cust.get_trans():
            
            #find the minimum value of date after they last used Lantern
            tdate = trans.get_date()
            if tdate >= ll and trans.get_orderSource() == 'Dutchie':
                
                if fdal == None:
                    cust.set_dates('first dutchie after lantern', tdate)
                    fdal = cust.get_dates()['first dutchie after lantern']
                    
                #earlier than the date currently stored there
                elif tdate < fdal:
                    cust.set_dates('first dutchie after lantern', tdate)
                    fdal = cust.get_dates()['first dutchie after lantern']
        
    else:
        cust.set_converted(False)
21/20:
ath = customers_dict["Aleisha Thompson-Heinz"].get_converted_date()
assert ath == '06/09/2022', "Actual date: " + ath
#she has several dutchie orders and 1 lantern order

ar = customers_dict["Allyson Rychlak"].get_converted_date()
assert ar == '07/19/2022', "Actual date: " + ar 
#she only has 1 dutchie order and 1 lantern order

ab = customers_dict["Andrew Berlanstein"].get_converted_date()
assert ab == '06/16/2022', "Actual date: " + ab 
#he only has 1 dutchie order and 1 lantern order

#do more tests to see if they've "converted" (boolean), or test other
#dutchie/lantern users who haven't converted

assert customers_dict["Aleisha Thompson-Heinz"].get_converted()
assert customers_dict["Allyson Rychlak"].get_converted()
assert customers_dict["Andrew Berlanstein"].get_converted()
assert not customers_dict["Alesha M. Gunn"].get_converted() #Lantern customer only
assert not customers_dict["Dave Read"].get_converted() #Dutchie customer only
assert not customers_dict["Eva Garrett"].get_converted() #used Dutchie, went back to Lantern
21/21:
data = list(zip(dates_list, conversions_list))
df = pd.DataFrame(data, columns = ['Date','Quantity'])

df['Date'] = pd.to_datetime(df['Date']) - pd.to_timedelta(7, unit='d')
df = df.groupby([pd.Grouper(key='Date', freq='W')])['Quantity'].sum()
21/22:
converted_dict = {}
for k, cust in customers_dict.items():
    
    if not cust.get_converted():
        continue
        
    date = cust.get_converted_date()
    #print("NAME AND DATE: ", cust.get_name(), " ", date)
        
    if date in converted_dict.keys():
        converted_dict[date] += 1
    else:
        converted_dict[date] = 1
21/23:
sorted_dates = sorted(converted_dict.items())
sorted_dates
21/24:
dates_list = [i[0] for i in sorted_dates]
conversions_list = [i[1] for i in sorted_dates]

dates_list
21/25:
data = list(zip(dates_list, conversions_list))
df = pd.DataFrame(data, columns = ['Date','Quantity'])

df['Date'] = pd.to_datetime(df['Date']) - pd.to_timedelta(7, unit='d')
df = df.groupby([pd.Grouper(key='Date', freq='W')])['Quantity'].sum()
21/26: df
22/1:
# ##############################################################################################
# # If you're using Google Colab, uncomment this section by selecting the whole section and press
# # ctrl+'/' (Linux/Windows) or cmd+'/' (MacOS) on your and keyboard. Run it before you start 
# # programming, this will enable the nice LaTeX "display()" function for you. If you're using 
# # the local Jupyter environment, leave it alone
# ##############################################################################################


def custom_latex_printer(exp,**options):
    from google.colab.output._publish import javascript
    url = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.1.1/latest.js?config=TeX-AMS_HTML"
    javascript(url=url)
    return sym.printing.latex(exp,**options)
sym.init_printing(use_latex="mathjax",latex_printer=custom_latex_printer)
22/2:
#IMPORT ALL NECESSARY PACKAGES AT THE TOP OF THE CODE
import sympy as sym
import numpy as np
import matplotlib.pyplot as plt
22/3:
# ##############################################################################################
# # If you're using Google Colab, uncomment this section by selecting the whole section and press
# # ctrl+'/' (Linux/Windows) or cmd+'/' (MacOS) on your and keyboard. Run it before you start 
# # programming, this will enable the nice LaTeX "display()" function for you. If you're using 
# # the local Jupyter environment, leave it alone
# ##############################################################################################


def custom_latex_printer(exp,**options):
    from google.colab.output._publish import javascript
    url = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.1.1/latest.js?config=TeX-AMS_HTML"
    javascript(url=url)
    return sym.printing.latex(exp,**options)
sym.init_printing(use_latex="mathjax",latex_printer=custom_latex_printer)
22/4:
####################################
# Part 1: compute derivative of f

# define your symbolic variable here
x = sym.symbols('x')

# define the function f
f = sym.sin(x) # if you're using Jupyter-Notebook, try "display(f)"

# compute derivative of f
# (uncomment next line and add your code)
df = f.diff(x)

# output resutls
print("derivative of f: ")
display(df)

####################################
# Part 2: compute directional derivative of f

# define dummy variable epsilon, and the direction v
# note 1: here the character 'r' means raw string
# note 2: here I define the symbol for epsilon with 
#          the name "\epsilon", this is for LaTeX printing
#          later. In your case, you can give it any other 
#          name you want. 
eps, v = sym.symbols(r'\epsilon, v') 

# add epsilon into function f
new_f = (x + v*eps)**2

# take derivative of the new function w.r.t. epsilon
df_eps = new_f.diff(eps)

# output this derivative
print("derivative of f wrt eps: ")
display(df_eps)

# now, as you've seen the class, we need evaluate for eps=0 to ...
# ... get the directional derivative. To do this, we need to ... 
# ... use SymPy's built-in substitution method "subs()" to ...
# ... replace the epsilon symbol with 0
new_df = df_eps.subs(eps, 0)

# output directional derivative
print("directional derivative of f on v: ")
display(new_df)
22/5:
# ##############################################################################################
# # If you're using Google Colab, uncomment this section by selecting the whole section and press
# # ctrl+'/' (Linux/Windows) or cmd+'/' (MacOS) on your and keyboard. Run it before you start 
# # programming, this will enable the nice LaTeX "display()" function for you. If you're using 
# # the local Jupyter environment, leave it alone
# ##############################################################################################


# def custom_latex_printer(exp,**options):
#     from google.colab.output._publish import javascript
#     url = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.1.1/latest.js?config=TeX-AMS_HTML"
#     javascript(url=url)
#     return sym.printing.latex(exp,**options)
# sym.init_printing(use_latex="mathjax",latex_printer=custom_latex_printer)
23/1:
#IMPORT ALL NECESSARY PACKAGES AT THE TOP OF THE CODE
import sympy as sym
import numpy as np
import matplotlib.pyplot as plt
23/2:
# ##############################################################################################
# # If you're using Google Colab, uncomment this section by selecting the whole section and press
# # ctrl+'/' (Linux/Windows) or cmd+'/' (MacOS) on your and keyboard. Run it before you start 
# # programming, this will enable the nice LaTeX "display()" function for you. If you're using 
# # the local Jupyter environment, leave it alone
# ##############################################################################################


# def custom_latex_printer(exp,**options):
#     from google.colab.output._publish import javascript
#     url = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.1.1/latest.js?config=TeX-AMS_HTML"
#     javascript(url=url)
#     return sym.printing.latex(exp,**options)
# sym.init_printing(use_latex="mathjax",latex_printer=custom_latex_printer)
23/3:
####################################
# Part 1: compute derivative of f

# define your symbolic variable here
x = sym.symbols('x')

# define the function f
f = sym.sin(x) # if you're using Jupyter-Notebook, try "display(f)"

# compute derivative of f
# (uncomment next line and add your code)
df = f.diff(x)

# output resutls
print("derivative of f: ")
display(df)

####################################
# Part 2: compute directional derivative of f

# define dummy variable epsilon, and the direction v
# note 1: here the character 'r' means raw string
# note 2: here I define the symbol for epsilon with 
#          the name "\epsilon", this is for LaTeX printing
#          later. In your case, you can give it any other 
#          name you want. 
eps, v = sym.symbols(r'\epsilon, v') 

# add epsilon into function f
new_f = (x + v*eps)**2

# take derivative of the new function w.r.t. epsilon
df_eps = new_f.diff(eps)

# output this derivative
print("derivative of f wrt eps: ")
display(df_eps)

# now, as you've seen the class, we need evaluate for eps=0 to ...
# ... get the directional derivative. To do this, we need to ... 
# ... use SymPy's built-in substitution method "subs()" to ...
# ... replace the epsilon symbol with 0
new_df = df_eps.subs(eps, 0)

# output directional derivative
print("directional derivative of f on v: ")
display(new_df)
23/4:
####################################
# Part 1: compute derivative of f

# define your symbolic variable here
x = sym.symbols('x')

# define the function f
f = sym.sin(x) # if you're using Jupyter-Notebook, try "display(f)"

# compute derivative of f
# (uncomment next line and add your code)
df = f.diff(x)

# output resutls
print("derivative of f: ")
display(df)

####################################
# Part 2: compute directional derivative of f

# define dummy variable epsilon, and the direction v
23/5:
####################################
# Part 1: compute derivative of f

# define your symbolic variable here
x = sym.symbols('x')

# define the function f
f = sym.sin(x) # if you're using Jupyter-Notebook, try "display(f)"

# compute derivative of f
# (uncomment next line and add your code)
df = f.diff(x)

# output resutls
print("derivative of f: ")
display(df)

####################################
# Part 2: compute directional derivative of f

# define dummy variable epsilon, and the direction v
eps, v = sym.symbols(r'\epsilon, v')

fnew = sym.sin(x + eps*v)
dfnew = fnew.diff(x)
display(dfnew)
23/6:
####################################
# Part 1: compute derivative of f

# define your symbolic variable here
x = sym.symbols('x')

# define the function f
f = sym.sin(x) # if you're using Jupyter-Notebook, try "display(f)"

# compute derivative of f
# (uncomment next line and add your code)
df = f.diff(x)

# output resutls
print("derivative of f: ")
display(df)

####################################
# Part 2: compute directional derivative of f

# define dummy variable epsilon, and the direction v
eps, v = sym.symbols(r'\epsilon, v')

fnew = sym.sin(x + eps*v)
dfdx = fnew.diff(x)
display(dfdx)

dfde = fnew.diff(eps)
display(dfde)
23/7:
####################################
# Part 1: compute derivative of f

# define your symbolic variable here
x = sym.symbols('x')

# define the function f
f = sym.sin(x) # if you're using Jupyter-Notebook, try "display(f)"

# compute derivative of f
# (uncomment next line and add your code)
df = f.diff(x)

# output resutls
print("derivative of f: ")
display(df)

####################################
# Part 2: compute directional derivative of f

# define dummy variable epsilon, and the direction v
eps, v = sym.symbols(r'\epsilon, v')

fnew = sym.sin(x + eps*v)

#differentiate w.r.t. the scaling factor
dfde = fnew.diff(eps)
print("derivative of f wrt epsilon:")
display(dfde)

#evaluated at epsilon = 0, this gives the directional deriv in v direction
dfnew = dfde.subs(r'\epsilon', 0)
display(dfnew)
23/8:
####################################
# Part 1: compute derivative of f

# define your symbolic variable here
x = sym.symbols('x')

# define the function f
f = sym.sin(x) # if you're using Jupyter-Notebook, try "display(f)"

# compute derivative of f
# (uncomment next line and add your code)
df = f.diff(x)

# output resutls
print("derivative of f: ")
display(df)

####################################
# Part 2: compute directional derivative of f

# define dummy variable epsilon, and the direction v
eps, v = sym.symbols(r'\epsilon, v')

fnew = sym.sin(x + eps*v)

#differentiate w.r.t. the scaling factor
dfde = fnew.diff(eps)
print("derivative of f wrt epsilon:")
display(dfde)

#evaluated at epsilon = 0, this gives the directional deriv in v direction
#dfnew = dfde.subs(r'\epsilon', 0)
print('evaluated at epsilon = 0: ')
display(dfde.subs(r'\epsilon', 0))
23/9:
####################################
# Part 1: compute derivative of f

# define your symbolic variable here
x = sym.symbols('x')

# define the function f
f = sym.sin(x) # if you're using Jupyter-Notebook, try "display(f)"

# compute derivative of f
# (uncomment next line and add your code)
df = f.diff(x)

# output resutls
print("derivative of f: ")
display(df)

####################################
# Part 2: compute directional derivative of f

# define dummy variable epsilon, and the direction v
eps, v = sym.symbols(r'\epsilon, v')

fnew = sym.sin(x + eps*v)

#differentiate w.r.t. the scaling factor
dfde = fnew.diff(eps)
print("derivative of f wrt epsilon:")
display(dfde)

#evaluated at epsilon = 0, this gives the directional deriv in v direction
#dfnew = dfde.subs(r'\epsilon', 0)
print('evaluated at epsilon = 0: ')
#display(dfde.subs(r'\epsilon', 0))
display(dfde.subs(eps, 0))
23/10:
####################################
# Part 1: compute derivative of f

# define your symbolic variable here
x = sym.symbols('x')

# define the function f
f = sym.sin(x) # if you're using Jupyter-Notebook, try "display(f)"

# compute derivative of f
# (uncomment next line and add your code)
df = f.diff(x)

# output resutls
print("derivative of f: ")
display(df)

####################################
# Part 2: compute directional derivative of f

# define dummy variable epsilon, and the direction v
eps, v = sym.symbols(r'\epsilon, v')

fnew = sym.sin(x + eps*v)

#differentiate w.r.t. the scaling factor
dfde = fnew.diff(eps)
print("derivative of f wrt epsilon:")
display(dfde)

#evaluated at epsilon = 0, this gives the directional deriv in v direction
dfnew = dfde.subs(eps, 0)
print('evaluated at epsilon = 0: ')
display(dfnew)
23/11:
####################################
# Part 1: compute derivative of f

# define your symbolic variable here
x = sym.symbols('x')

# define the function f
f = sym.sin(x) # if you're using Jupyter-Notebook, try "display(f)"

# compute derivative of f
# (uncomment next line and add your code)
df = f.diff(x)

# output resutls
print("derivative of f: ")
display(df)

####################################
# Part 2: compute directional derivative of f

# define dummy variable epsilon, and the direction v
eps, v = sym.symbols(r'\epsilon, v')

fnew = sym.sin(x + eps*v)

#differentiate w.r.t. the scaling factor
dfde = fnew.diff(eps)
print("derivative of f wrt epsilon:")
display(dfde)

#evaluated at epsilon = 0, this gives the directional deriv in v direction
dfnew = dfde.subs(eps, 0)
print('directional derivative of f in v direction: ')
display(dfnew)
23/12:
def integrate(func, xspan, step_size):
    '''
    Numerical integration with Euler's method

    Parameters:
    ====================
    func: Python function
        func is the function you want to integrate for
    xspan: list
        xspan is a list of two elements, representing 
        the start and end of integration
    step_size:
        a smaller step_size will give a more accurate result

    Returns:
    int_val:
        result of the integration
    ====================
    '''
    x = np.arange(xspan[0], xspan[1], step_size)
    int_val = 0
    for xi in x:
        int_val += func(xi) * step_size
    return int_val

# # a simple test
# def square(x):
#     return x**2
# print( integrate(func=square, xspan=[0, 1], step_size=0.01) )
# # or you just call the function without indicating parameters
# # print( integrate(square, [0, 1], 0.01) )


#for x(t) = cos(t) and J(x(t)) = int{0}{pi/2} (1/2*x(t)^2) dt:

def integrand1(t):
    return 0.5 * (np.cos(t))*2

tspan = [0, np.pi/2.0]
step = 0.001
res = integrate(integrand, tspan, step)

print(f'Result: {res}')
print(f'Result*8: {res*8}')
23/13:
def integrate(func, xspan, step_size):
    '''
    Numerical integration with Euler's method

    Parameters:
    ====================
    func: Python function
        func is the function you want to integrate for
    xspan: list
        xspan is a list of two elements, representing 
        the start and end of integration
    step_size:
        a smaller step_size will give a more accurate result

    Returns:
    int_val:
        result of the integration
    ====================
    '''
    x = np.arange(xspan[0], xspan[1], step_size)
    int_val = 0
    for xi in x:
        int_val += func(xi) * step_size
    return int_val

# # a simple test
# def square(x):
#     return x**2
# print( integrate(func=square, xspan=[0, 1], step_size=0.01) )
# # or you just call the function without indicating parameters
# # print( integrate(square, [0, 1], 0.01) )


#for x(t) = cos(t) and J(x(t)) = int{0}{pi/2} (1/2*x(t)^2) dt:

def integrand(t):
    return 0.5 * (np.cos(t))*2

tspan = [0, np.pi/2.0]
step = 0.001
res = integrate(integrand, tspan, step)

print(f'Result: {res}')
print(f'Result*8: {res*8}')
23/14:
def integrate(func, xspan, step_size):
    '''
    Numerical integration with Euler's method

    Parameters:
    ====================
    func: Python function
        func is the function you want to integrate for
    xspan: list
        xspan is a list of two elements, representing 
        the start and end of integration
    step_size:
        a smaller step_size will give a more accurate result

    Returns:
    int_val:
        result of the integration
    ====================
    '''
    x = np.arange(xspan[0], xspan[1], step_size)
    int_val = 0
    for xi in x:
        int_val += func(xi) * step_size
    return int_val

# # a simple test
# def square(x):
#     return x**2
# print( integrate(func=square, xspan=[0, 1], step_size=0.01) )
# # or you just call the function without indicating parameters
# # print( integrate(square, [0, 1], 0.01) )


#for x(t) = cos(t) and J(x(t)) = int{0}{pi/2} (1/2*x(t)^2) dt:

def integrand(t):
    return 0.5 * (np.cos(t))**2

tspan = [0, np.pi/2.0]
step = 0.001
res = integrate(integrand, tspan, step)

print(f'Result: {res}')
print(f'Result*8: {res*8}')
23/15:
def integrate(func, xspan, step_size):
    '''
    Numerical integration with Euler's method

    Parameters:
    ====================
    func: Python function
        func is the function you want to integrate for
    xspan: list
        xspan is a list of two elements, representing 
        the start and end of integration
    step_size:
        a smaller step_size will give a more accurate result

    Returns:
    int_val:
        result of the integration
    ====================
    '''
    x = np.arange(xspan[0], xspan[1], step_size)
    int_val = 0
    for xi in x:
        int_val += func(xi) * step_size
    return int_val

# # a simple test
# def square(x):
#     return x**2
# print( integrate(func=square, xspan=[0, 1], step_size=0.01) )
# # or you just call the function without indicating parameters
# # print( integrate(square, [0, 1], 0.01) )


#for x(t) = cos(t) and J(x(t)) = int{0}{pi/2} (1/2*x(t)^2) dt:

def integrand(t):
    return 0.5 * (np.cos(t))**2

tspan = [0, np.pi/2.0]
step = 0.0001
res = integrate(integrand, tspan, step)

print(f'Result: {res}')
print(f'Result*8: {res*8}')
23/16:
def integrate(func, xspan, step_size):
    '''
    Numerical integration with Euler's method

    Parameters:
    ====================
    func: Python function
        func is the function you want to integrate for
    xspan: list
        xspan is a list of two elements, representing 
        the start and end of integration
    step_size:
        a smaller step_size will give a more accurate result

    Returns:
    int_val:
        result of the integration
    ====================
    '''
    x = np.arange(xspan[0], xspan[1], step_size)
    int_val = 0
    for xi in x:
        int_val += func(xi) * step_size
    return int_val

# # a simple test
# def square(x):
#     return x**2
# print( integrate(func=square, xspan=[0, 1], step_size=0.01) )
# # or you just call the function without indicating parameters
# # print( integrate(square, [0, 1], 0.01) )


#for x(t) = cos(t) and J(x(t)) = int{0}{pi/2} (1/2*x(t)^2) dt:

def integrand(t):
    return 0.5 * (np.cos(t))**2

tspan = [0, np.pi/2.0]
step = 0.00005
res = integrate(integrand, tspan, step)

print(f'Result: {res}')
print(f'Result*8: {res*8}')
23/17:
def integrate(func, xspan, step_size):
    '''
    Numerical integration with Euler's method

    Parameters:
    ====================
    func: Python function
        func is the function you want to integrate for
    xspan: list
        xspan is a list of two elements, representing 
        the start and end of integration
    step_size:
        a smaller step_size will give a more accurate result

    Returns:
    int_val:
        result of the integration
    ====================
    '''
    x = np.arange(xspan[0], xspan[1], step_size)
    int_val = 0
    for xi in x:
        int_val += func(xi) * step_size
    return int_val

# # a simple test
# def square(x):
#     return x**2
# print( integrate(func=square, xspan=[0, 1], step_size=0.01) )
# # or you just call the function without indicating parameters
# # print( integrate(square, [0, 1], 0.01) )


#for x(t) = cos(t) and J(x(t)) = int{0}{pi/2} (1/2*x(t)^2) dt:

def integrand(t):
    return 0.5 * (np.cos(t))**2

tspan = [0, np.pi/2.0]
step = 0.0001
res = integrate(integrand, tspan, step)

print(f'Result: {res}')
print(f'Result*8: {res*8}')
23/18:
def integrate(func, xspan, step_size):
    '''
    Numerical integration with Euler's method

    Parameters:
    ====================
    func: Python function
        func is the function you want to integrate for
    xspan: list
        xspan is a list of two elements, representing 
        the start and end of integration
    step_size:
        a smaller step_size will give a more accurate result

    Returns:
    int_val:
        result of the integration
    ====================
    '''
    x = np.arange(xspan[0], xspan[1], step_size)
    int_val = 0
    for xi in x:
        int_val += func(xi) * step_size
    return int_val

# # a simple test
# def square(x):
#     return x**2
# print( integrate(func=square, xspan=[0, 1], step_size=0.01) )
# # or you just call the function without indicating parameters
# # print( integrate(square, [0, 1], 0.01) )


#for x(t) = cos(t) and J(x(t)) = int{0}{pi/2} (1/2*x(t)^2) dt:

def integrand(t):
    return 0.5 * (np.cos(t))**2

tspan = [0, np.pi/2.0]
step = 0.0001
res = integrate(integrand, tspan, step)

print("Analytical solution for J(x(t)):")
print(f'Result: {res}')
print(f'Result*8: {res*8}')
23/19:
def integrate(func, xspan, step_size):
    '''
    Numerical integration with Euler's method

    Parameters:
    ====================
    func: Python function
        func is the function you want to integrate for
    xspan: list
        xspan is a list of two elements, representing 
        the start and end of integration
    step_size:
        a smaller step_size will give a more accurate result

    Returns:
    int_val:
        result of the integration
    ====================
    '''
    x = np.arange(xspan[0], xspan[1], step_size)
    int_val = 0
    for xi in x:
        int_val += func(xi) * step_size
    return int_val

# # a simple test
# def square(x):
#     return x**2
# print( integrate(func=square, xspan=[0, 1], step_size=0.01) )
# # or you just call the function without indicating parameters
# # print( integrate(square, [0, 1], 0.01) )


#for x(t) = cos(t) and J(x(t)) = int{0}{pi/2} (1/2*x(t)^2) dt:

def integrand(t):
    return 0.5 * (np.cos(t))**2

tspan = [0, np.pi/2.0]
step = 0.0001
res = integrate(integrand, tspan, step)

print("Analytical solution for J(x(t)):")
print(f'Result: {res}')
print(f'Result * 8: {res*8}')
23/20:
def integrate(func, xspan, step_size):
    '''
    Numerical integration with Euler's method

    Parameters:
    ====================
    func: Python function
        func is the function you want to integrate for
    xspan: list
        xspan is a list of two elements, representing 
        the start and end of integration
    step_size:
        a smaller step_size will give a more accurate result

    Returns:
    int_val:
        result of the integration
    ====================
    '''
    x = np.arange(xspan[0], xspan[1], step_size)
    int_val = 0
    for xi in x:
        int_val += func(xi) * step_size
    return int_val

# # a simple test
# def square(x):
#     return x**2
# print( integrate(func=square, xspan=[0, 1], step_size=0.01) )
# # or you just call the function without indicating parameters
# # print( integrate(square, [0, 1], 0.01) )


#for x(t) = cos(t) and J(x(t)) = int{0}{pi/2} (1/2*x(t)^2) dt:

def integrand(t):
    return 0.5 * (np.cos(t))**2

tspan = [0, np.pi/2.0]
step = 0.00005
res = integrate(integrand, tspan, step)

print("Analytical solution for J(x(t)):")
print(f'Result: {res}')
print(f'Result * 8: {res*8}')
23/21:
def integrate(func, xspan, step_size):
    '''
    Numerical integration with Euler's method

    Parameters:
    ====================
    func: Python function
        func is the function you want to integrate for
    xspan: list
        xspan is a list of two elements, representing 
        the start and end of integration
    step_size:
        a smaller step_size will give a more accurate result

    Returns:
    int_val:
        result of the integration
    ====================
    '''
    x = np.arange(xspan[0], xspan[1], step_size)
    int_val = 0
    for xi in x:
        int_val += func(xi) * step_size
    return int_val

#for x(t) = cos(t) and J(x(t)) = int{0}{pi/2} (1/2*x(t)^2) dt:

def integrand0(t):
    return 0.5 * (np.cos(t))**2

tspan = [0, np.pi/2.0]
step = 0.00005
res = integrate(integrand0, tspan, step)

print("Analytical solution for J(x(t)):")
print(f'Result: {res}')
print(f'Result * 8: {res*8}')
23/22:
#analytical form of integration: int{0}{pi/2}[ cos(t)sin(t)dt  ]
#can't integrate until that point because of the epsilon variable

def integrand1(t):
    return np.sin(t) * np.cos(t)

bounds = [0, np.pi/2.0]
step = 0.001

intval = integrate(integrand1, bounds, step)
print(f"Analytical integration: {intval}")
23/23:
t = sym.symbols('t')
# define function x and y
x = sym.Function('x')(t)
y = sym.Function('y')(t)
# define J(x(t), y(t))
J = sym.integrate(x**2 + x*y, [t, 0, sym.pi])
print('J(x(t), y(t)) = ')
display(J)

# take the time derivative of J(x(t))
dJdx = J.diff(x)
print('derivative of J(x(t), y(t)) wrt x(t): ')
display(dJdx)

# now, we have x(t)=sin(t) and y(t)=cos(t), we substitute them 
# in, and evaluate the integration
dJdx_subs = dJdx.subs({x:sym.sin(t), y:sym.cos(t)})
print('derivative of J, after substitution: ')
display(dJdx_subs)
print('evaluation of derivative of J, after substitution: ')
display(sym.N(dJdx_subs))
23/24:
def integrate(func, xspan, step_size):
    '''
    Numerical integration with Euler's method

    Parameters:
    ====================
    func: Python function
        func is the function you want to integrate for
    xspan: list
        xspan is a list of two elements, representing 
        the start and end of integration
    step_size:
        a smaller step_size will give a more accurate result

    Returns:
    int_val:
        result of the integration
    ====================
    '''
    x = np.arange(xspan[0], xspan[1], step_size)
    int_val = 0
    for xi in x:
        int_val += func(xi) * step_size
    return int_val

#for x(t) = cos(t) and J(x(t)) = int{0}{pi/2} (1/2*x(t)^2) dt:

def integrand0(t):
    return 0.5 * (np.cos(t))**2

tspan = [0, np.pi/2.0]
step = 0.00005
res = integrate(integrand0, tspan, step)

print("Analytical solution for J(x(t)):")
print(f'Result: {res}')
print(f'Result * 8: {res*8}')
print(f'Pi/8: {np.pi/8.0})
23/25:
def integrate(func, xspan, step_size):
    '''
    Numerical integration with Euler's method

    Parameters:
    ====================
    func: Python function
        func is the function you want to integrate for
    xspan: list
        xspan is a list of two elements, representing 
        the start and end of integration
    step_size:
        a smaller step_size will give a more accurate result

    Returns:
    int_val:
        result of the integration
    ====================
    '''
    x = np.arange(xspan[0], xspan[1], step_size)
    int_val = 0
    for xi in x:
        int_val += func(xi) * step_size
    return int_val

#for x(t) = cos(t) and J(x(t)) = int{0}{pi/2} (1/2*x(t)^2) dt:

def integrand0(t):
    return 0.5 * (np.cos(t))**2

tspan = [0, np.pi/2.0]
step = 0.00005
res = integrate(integrand0, tspan, step)

print("Analytical solution for J(x(t)):")
print(f'Result: {res}')
print(f'Result * 8: {res*8}')
print(f'Pi/8: {np.pi/8.0}'')
23/26:
def integrate(func, xspan, step_size):
    '''
    Numerical integration with Euler's method

    Parameters:
    ====================
    func: Python function
        func is the function you want to integrate for
    xspan: list
        xspan is a list of two elements, representing 
        the start and end of integration
    step_size:
        a smaller step_size will give a more accurate result

    Returns:
    int_val:
        result of the integration
    ====================
    '''
    x = np.arange(xspan[0], xspan[1], step_size)
    int_val = 0
    for xi in x:
        int_val += func(xi) * step_size
    return int_val

#for x(t) = cos(t) and J(x(t)) = int{0}{pi/2} (1/2*x(t)^2) dt:

def integrand0(t):
    return 0.5 * (np.cos(t))**2

tspan = [0, np.pi/2.0]
step = 0.00005
res = integrate(integrand0, tspan, step)

print("Analytical solution for J(x(t)):")
print(f'Result: {res}')
print(f'Result * 8: {res*8}')
print(f'Pi/8: {np.pi/8.0}')
23/27:
def integrate(func, xspan, step_size):
    '''
    Numerical integration with Euler's method

    Parameters:
    ====================
    func: Python function
        func is the function you want to integrate for
    xspan: list
        xspan is a list of two elements, representing 
        the start and end of integration
    step_size:
        a smaller step_size will give a more accurate result

    Returns:
    int_val:
        result of the integration
    ====================
    '''
    x = np.arange(xspan[0], xspan[1], step_size)
    int_val = 0
    for xi in x:
        int_val += func(xi) * step_size
    return int_val

#for x(t) = cos(t) and J(x(t)) = int{0}{pi/2} (1/2*x(t)^2) dt:

def integrand0(t):
    return 0.5 * (np.cos(t))**2

tspan = [0, np.pi/2.0]
step = 0.00005
res = integrate(integrand0, tspan, step)

print("Analytical solution for J(x(t)):")
print(f'Result: {res}')
print(f'Result * 8: {res*8}')
print(f'np.pi/8: {np.pi/8.0}')
23/28:
# You can start your implementation here :)
eps, t = sym.symbols(r'\epsilon, t')

#J(x(t))
x = sym.Function('x')(t)
v = sym.Function('v')(t)
J = sym.Function('J')(x)

#form of J(x(t)) function
J = sym.integrate(0.5 * x**2, [t, 0, sym.pi/2.0])
display(J)
23/29:
# You can start your implementation here :)
eps, t = sym.symbols(r'\epsilon, t')

#J(x(t))
x = sym.Function('x')(t)
v = sym.Function('v')(t)
J = sym.Function('J')(x)

#form of J(x(t)) function
J = sym.integrate(0.5 * x**2, [t, 0, sym.pi/2])
display(J)
23/30:
# You can start your implementation here :)
eps, t = sym.symbols(r'\epsilon, t')

#J(x(t))
x = sym.Function('x')(t)
v = sym.Function('v')(t)
J = sym.Function('J')(x)

#form of J(x(t)) function
J = sym.integrate(1/2 * x**2, [t, 0, sym.pi/2])
display(J)
23/31:
# You can start your implementation here :)
eps, t = sym.symbols(r'\epsilon, t')

#J(x(t))
x = sym.Function('x')(t)
v = sym.Function('v')(t)
J = sym.Function('J')(x)

#form of J(x(t)) function
J = sym.integrate(0.5 * x**2, [t, 0, sym.pi/2])
display(J)
23/32:
# You can start your implementation here :)
eps, t = sym.symbols(r'\epsilon, t')

#J(x(t))
x = sym.Function('x')(t)
v = sym.Function('v')(t)
J = sym.Function('J')(x)

#functions that go into J(x(t)
f_x = 0.5 * x**2
f_x_dir = 0.5 * (x + eps * v) **2

#form of J(x(t)) function
J = sym.integrate(f_x, [t, 0, sym.pi/2])
display(J)

#substitute in x + eps*v


#differentiate wrt epsilon


#substitute in x(t) = cos(t), v = sin(t)
23/33:
# You can start your implementation here :)
eps, t = sym.symbols(r'\epsilon, t')

#J(x(t))
x = sym.Function('x')(t)
v = sym.Function('v')(t)
J = sym.Function('J')(x)

#functions that go into J(x(t)
f_x = 0.5 * x**2
f_x_dir = 0.5 * (x + eps * v) **2

#form of J(x(t)) function
J = sym.integrate(f_x, [t, 0, sym.pi/2])
display(J)

#substitute in x + eps*v
J = J.subs(f_x, f_x_dir)
display(J)

#differentiate wrt epsilon


#substitute in x(t) = cos(t), v = sin(t)
23/34:
# You can start your implementation here :)
eps, t = sym.symbols(r'\epsilon, t')

#J(x(t))
x = sym.Function('x')(t)
v = sym.Function('v')(t)
J = sym.Function('J')(x)

#functions that go into J(x(t)
f_x = 0.5 * x**2
f_x_dir = 0.5 * (x + eps * v) **2

#form of J(x(t)) function
J = sym.integrate(f_x, [t, 0, sym.pi/2])
display(J)

#substitute in x + eps*v
J_dir = J.subs(f_x, f_x_dir)
display(J_dir)

#differentiate wrt epsilon


#substitute in x(t) = cos(t), v = sin(t)
23/35:
# You can start your implementation here :)
eps, t = sym.symbols(r'\epsilon, t')

#J(x(t))
x = sym.Function('x')(t)
v = sym.Function('v')(t)

#functions that go into J(x(t)
f_x = 0.5 * x**2
f_x_dir = 0.5 * (x + eps * v) **2

#form of J(x(t)) function
J = sym.integrate(f_x, [t, 0, sym.pi/2])
display(J)

#substitute in x + eps*v
J_dir = J.subs(f_x, f_x_dir)
display(J_dir) #---> why does it still show x^2(t)?

#differentiate wrt epsilon


#substitute in x(t) = cos(t), v = sin(t)
23/36:
# You can start your implementation here :)
eps, t = sym.symbols(r'\epsilon, t')

#J(x(t))
x = sym.Function('x')(t)
v = sym.Function('v')(t)

#functions that go into J(x(t)
f_x = 0.5 * x**2
f_x_dir = 0.5 * (x + eps * v) **2

#form of J(x(t)) function
J = sym.integrate(f_x, [t, 0, sym.pi/2])
display(J)

#substitute in x + eps*v
#J_dir = J.subs(f_x, f_x_dir)
J_dir = sym.integrate(f_x_dir, [t, 0, sym.pi/2])
display(J_dir) #---> why does it still show x^2(t)?

#differentiate wrt epsilon


#substitute in x(t) = cos(t), v = sin(t)
23/37:
# You can start your implementation here :)
eps, t = sym.symbols(r'\epsilon, t')

#J(x(t))
x = sym.Function('x')(t)
v = sym.Function('v')(t)

#functions that go into J(x(t)
f_x = 0.5 * x**2
f_x_dir = 0.5 * (x + eps * v) **2

#form of J(x(t)) function
J = sym.integrate(f_x, [t, 0, sym.pi/2])
display(J)

#substitute in x + eps*v
#J_dir = J.subs(f_x, f_x_dir)
J_dir = sym.integrate(f_x_dir, [t, 0, sym.pi/2])
J_dir_sim = sym.simplify(J_dir)
display(J_dir_sim) #---> why does it still show x^2(t)?

#differentiate wrt epsilon


#substitute in x(t) = cos(t), v = sin(t)
23/38:
# You can start your implementation here :)
eps, t = sym.symbols(r'\epsilon, t')

#J(x(t))
x = sym.Function('x')(t)
v = sym.Function('v')(t)

#functions that go into J(x(t)
f_x = 0.5 * x**2
f_x_dir = 0.5 * (x + eps * v) **2

#form of J(x(t)) function
J = sym.integrate(f_x, [t, 0, sym.pi/2])
display(J)

#substitute in x + eps*v
#J_dir = J.subs(f_x, f_x_dir)
J_dir = sym.integrate(f_x_dir, [t, 0, sym.pi/2])
display(J_dir) #---> why does it still show x^2(t)?

#differentiate wrt epsilon


#substitute in x(t) = cos(t), v = sin(t)
23/39:
# You can start your implementation here :)
eps, t = sym.symbols(r'\epsilon, t')

#J(x(t))
x = sym.Function('x')(t)
v = sym.Function('v')(t)

#functions that go into J(x(t)
f_x = 0.5 * x**2
f_x_dir = 0.5 * (x + eps * v) **2

#form of J(x(t)) function
J = sym.integrate(f_x, [t, 0, sym.pi/2])
display(J)

#substitute in x + eps*v
#J_dir = J.subs(f_x, f_x_dir)
J_dir = sym.integrate(f_x_dir, [t, 0, sym.pi/2])
display(J_dir) #---> why does it still show x^2(t)?

#differentiate wrt epsilon
dJde = J_dir.diff(eps)
display(dJde)

#substitute in x(t) = cos(t), v = sin(t)
23/40:
# You can start your implementation here :)
eps, t = sym.symbols(r'\epsilon, t')

#J(x(t))
x = sym.Function('x')(t)
v = sym.Function('v')(t)

#functions that go into J(x(t)
f_x = 0.5 * x**2
f_x_dir = 0.5 * (x + eps * v) **2

#form of J(x(t)) function
J = sym.integrate(f_x, [t, 0, sym.pi/2])
display(J)

#substitute in x + eps*v
#J_dir = J.subs(f_x, f_x_dir)
J_dir = sym.integrate(f_x_dir, [t, 0, sym.pi/2])
display(J_dir) #---> why does it still show x^2(t)?

#differentiate wrt epsilon
dJde = J_dir.diff(eps)
display(dJde)

#evaluate at epsilon = 0 
dJ_new = dJde.subs(eps, 0)
display(dJ_new)

#substitute in x(t) = cos(t), v = sin(t)
23/41:
# You can start your implementation here :)
eps, t = sym.symbols(r'\epsilon, t')

#J(x(t))
x = sym.Function('x')(t)
v = sym.Function('v')(t)

#functions that go into J(x(t)
f_x = 0.5 * x**2
f_x_dir = 0.5 * (x + eps * v) **2

#form of J(x(t)) function
J = sym.integrate(f_x, [t, 0, sym.pi/2])
display(J)

#substitute in x + eps*v
#J_dir = J.subs(f_x, f_x_dir)
J_dir = sym.integrate(f_x_dir, [t, 0, sym.pi/2])
display(J_dir) #---> why does it still show x^2(t)?

#differentiate wrt epsilon
dJde = J_dir.diff(eps)
display(dJde)

#evaluate at epsilon = 0 
dJ_new = dJde.subs(eps, 0)
display(dJ_new)

#substitute in x(t) = cos(t), v = sin(t)
dJ_subbed = dJ_new.subs({x: sym.cos(t), y: sym.sin(t)})
display(dJ_subbed)
23/42:
# You can start your implementation here :)
eps, t = sym.symbols(r'\epsilon, t')

#J(x(t))
x = sym.Function('x')(t)
v = sym.Function('v')(t)

#functions that go into J(x(t)
f_x = 0.5 * x**2
f_x_dir = 0.5 * (x + eps * v) **2

#form of J(x(t)) function
J = sym.integrate(f_x, [t, 0, sym.pi/2])
print('J(x(t)): ')
display(J)

#substitute in x + eps*v
#J_dir = J.subs(f_x, f_x_dir)
J_dir = sym.integrate(f_x_dir, [t, 0, sym.pi/2])
display(r'J(x(t) + \epsilon * v(t)): ')
display(J_dir) #---> why does it still show x^2(t)?

#differentiate wrt epsilon
dJde = J_dir.diff(eps)
display(dJde)

#evaluate at epsilon = 0 
dJ_new = dJde.subs(eps, 0)
display(dJ_new)

#substitute in x(t) = cos(t), v = sin(t)
dJ_subbed = dJ_new.subs({x: sym.cos(t), y: sym.sin(t)})
display(dJ_subbed)
23/43:
# You can start your implementation here :)
eps, t = sym.symbols(r'\epsilon, t')

#J(x(t))
x = sym.Function('x')(t)
v = sym.Function('v')(t)

#functions that go into J(x(t)
f_x = 0.5 * x**2
f_x_dir = 0.5 * (x + eps * v) **2

#form of J(x(t)) function
J = sym.integrate(f_x, [t, 0, sym.pi/2])
print('J(x(t)): ')
display(J)

#substitute in x + eps*v
#J_dir = J.subs(f_x, f_x_dir)
J_dir = sym.integrate(f_x_dir, [t, 0, sym.pi/2])
print('J(x(t) + eps*v(t)): ')
display(J_dir) #---> why does it still show x^2(t)?

#differentiate wrt epsilon
dJde = J_dir.diff(eps)
display(dJde)

#evaluate at epsilon = 0 
dJ_new = dJde.subs(eps, 0)
display(dJ_new)

#substitute in x(t) = cos(t), v = sin(t)
dJ_subbed = dJ_new.subs({x: sym.cos(t), y: sym.sin(t)})
display(dJ_subbed)
23/44:
# You can start your implementation here :)
eps, t = sym.symbols(r'\epsilon, t')

#J(x(t))
x = sym.Function('x')(t)
v = sym.Function('v')(t)

#functions that go into J(x(t)
f_x = 0.5 * x**2
f_x_dir = 0.5 * (x + eps * v) **2

#form of J(x(t)) function
J = sym.integrate(f_x, [t, 0, sym.pi/2])
print('J(x(t)): ')
display(J)

#substitute in x + eps*v
#J_dir = J.subs(f_x, f_x_dir)
J_dir = sym.integrate(f_x_dir, [t, 0, sym.pi/2])
print('J(x(t) + eps*v(t)): ')
display(J_dir) #---> why does it still show x^2(t)?

#differentiate wrt epsilon
dJde = J_dir.diff(eps)
print('d/dEps (J(x+eps*v)): ')
display(dJde)

#evaluate at epsilon = 0 
dJ_new = dJde.subs(eps, 0)
display(dJ_new)

#substitute in x(t) = cos(t), v = sin(t)
dJ_subbed = dJ_new.subs({x: sym.cos(t), y: sym.sin(t)})
display(dJ_subbed)
23/45:
# You can start your implementation here :)
eps, t = sym.symbols(r'\epsilon, t')

#J(x(t))
x = sym.Function('x')(t)
v = sym.Function('v')(t)

#functions that go into J(x(t)
f_x = 0.5 * x**2
f_x_dir = 0.5 * (x + eps * v) **2

#form of J(x(t)) function
J = sym.integrate(f_x, [t, 0, sym.pi/2])
print('J(x(t)): ')
display(J)

#substitute in x + eps*v
#J_dir = J.subs(f_x, f_x_dir)
J_dir = sym.integrate(f_x_dir, [t, 0, sym.pi/2])
print('J(x(t) + eps*v(t)): ')
display(J_dir) #---> why does it still show x^2(t)?

#differentiate wrt epsilon
dJde = J_dir.diff(eps)
print('d/dEps (J(x+eps*v)): ')
display(dJde)

#evaluate at epsilon = 0 
dJ_new = dJde.subs(eps, 0)
print('Directional derivative of J: ')
display(dJ_new)

#substitute in x(t) = cos(t), v = sin(t)
dJ_subbed = dJ_new.subs({x: sym.cos(t), y: sym.sin(t)})
display(dJ_subbed)
23/46:
# You can start your implementation here :)
eps, t = sym.symbols(r'\epsilon, t')

#J(x(t))
x = sym.Function('x')(t)
v = sym.Function('v')(t)

#functions that go into J(x(t)
f_x = 0.5 * x**2
f_x_dir = 0.5 * (x + eps * v) **2

#form of J(x(t)) function
J = sym.integrate(f_x, [t, 0, sym.pi/2])
print('J(x(t)): ')
display(J)

#substitute in x + eps*v
#J_dir = J.subs(f_x, f_x_dir)
J_dir = sym.integrate(f_x_dir, [t, 0, sym.pi/2])
print('J(x(t) + eps*v(t)): ')
display(J_dir) #---> why does it still show x^2(t)?

#differentiate wrt epsilon
dJde = J_dir.diff(eps)
print('d/dEps (J(x+eps*v)): ')
display(dJde)

#evaluate at epsilon = 0 
dJ_new = dJde.subs(eps, 0)
print('Directional derivative of J: ')
display(dJ_new)

#substitute in x(t) = cos(t), v = sin(t)
dJ_subbed = dJ_new.subs({x: sym.cos(t), v: sym.sin(t)})
display(dJ_subbed)
23/47:
# You can start your implementation here :)
eps, t = sym.symbols(r'\epsilon, t')

#J(x(t))
x = sym.Function('x')(t)
v = sym.Function('v')(t)

#functions that go into J(x(t)
f_x = 0.5 * x**2
f_x_dir = 0.5 * (x + eps * v) **2

#form of J(x(t)) function
J = sym.integrate(f_x, [t, 0, sym.pi/2])
print('J(x(t)): ')
display(J)

#substitute in x + eps*v
#J_dir = J.subs(f_x, f_x_dir)
J_dir = sym.integrate(f_x_dir, [t, 0, sym.pi/2])
print('J(x(t) + eps*v(t)): ')
display(J_dir) #---> why does it still show x^2(t)?

#differentiate wrt epsilon
dJde = J_dir.diff(eps)
print('d/dEps (J(x+eps*v)): ')
display(dJde)

#evaluate at epsilon = 0 
dJ_new = dJde.subs(eps, 0)
print('Directional derivative of J: ')
display(dJ_new)

#substitute in x(t) = cos(t), v = sin(t)
dJ_subbed = dJ_new.subs({x: sym.cos(t), v: sym.sin(t)})
dJ_subbed = sym.simplify(dJ_subbed)
display(dJ_subbed)
23/48:
# You can start your implementation here :)
eps, t = sym.symbols(r'\epsilon, t')

#J(x(t))
x = sym.Function('x')(t)
v = sym.Function('v')(t)

#functions that go into J(x(t)
f_x = 0.5 * x**2
f_x_dir = 0.5 * (x + eps * v) **2

#form of J(x(t)) function
J = sym.integrate(f_x, [t, 0, sym.pi/2])
print('J(x(t)): ')
display(J)

#substitute in x + eps*v
#J_dir = J.subs(f_x, f_x_dir)
J_dir = sym.integrate(f_x_dir, [t, 0, sym.pi/2])
print('J(x(t) + eps*v(t)): ')
display(J_dir) #---> why does it still show x^2(t)?

#differentiate wrt epsilon
dJde = J_dir.diff(eps)
print('d/dEps (J(x+eps*v)): ')
display(dJde)

#evaluate at epsilon = 0 
dJ_new = dJde.subs(eps, 0)
print('Directional derivative of J: ')
display(dJ_new)

#substitute in x(t) = cos(t), v = sin(t)
dJ_subbed = dJ_new.subs({x: sym.cos(t), v: sym.sin(t)})
print('Directional derivative of J after substitution: ')
display(dJ_subbed)

#solve.
display(dJ_subbed.evalf())
23/49:
# You can start your implementation here :)
eps, t = sym.symbols(r'\epsilon, t')

#J(x(t))
x = sym.Function('x')(t)
v = sym.Function('v')(t)

#functions that go into J(x(t)
f_x = 0.5 * x**2
f_x_dir = 0.5 * (x + eps * v) **2

#form of J(x(t)) function
J = sym.integrate(f_x, [t, 0, sym.pi/2])
print('J(x(t)): ')
display(J)

#substitute in x + eps*v
#J_dir = J.subs(f_x, f_x_dir)
J_dir = sym.integrate(f_x_dir, [t, 0, sym.pi/2])
print('J(x(t) + eps*v(t)): ')
display(J_dir) #---> why does it still show x^2(t)?

#differentiate wrt epsilon
dJde = J_dir.diff(eps)
print('d/dEps (J(x+eps*v)): ')
display(dJde)

#evaluate at epsilon = 0 
dJ_new = dJde.subs(eps, 0)
print('Directional derivative of J: ')
display(dJ_new)

#substitute in x(t) = cos(t), v = sin(t)
dJ_subbed = dJ_new.subs({x: sym.cos(t), v: sym.sin(t)})
print('Directional derivative of J after substitution: ')
display(dJ_subbed)

#solve.
print('Evaluation of DJ(x(t))*v after substitution: ')
display(dJ_subbed.evalf())
23/50:
# from sympy.abc import x, y # it's same as defining x, y using symbols() OR
x, y = sym.symbols(r'x,y')

# define an equation
eqn = sym.Eq(x**3 * 2*sym.sin(4*x), x*y)
print('Original equation')
display(eqn)

# solve this equation for y
y_sol = sym.solve(eqn, y) # this method returns a list, 
                             # which may include multiple solutions
print('Symbolic solutions')
print(y_sol)
y_expr = y_sol[0] # in this case we just have one solution

# lambdify the expression wrt symbol x
func = sym.lambdify(x, y_expr)
print('Test: func(1.0) = ', func(1.0))

##############
# now it's time to plot it from 0 to pi

# generate list of values from 0 to pi
x_list = np.linspace(0, np.pi, 100) 

# evaluate function at those values
f_list = func(x_list)

# plot it
plt.plot(x_list, f_list)
plt.show()
23/51:
#setup expression, symbols
x, y = sym.symbols('x, y')
eqn = sym.Eq(x*y + sym.sin(x), x + y)
print('Original equation: ')
display(eqn)


#solve()



#lambdify()



#np arrays, then plot
23/52:
#setup expression, symbols
x, y = sym.symbols('x, y')
eqn = sym.Eq(x*y + sym.sin(x), x + y)
print('Original equation: ')
display(eqn)

#solve()
y_sol = sym.solve(eqn, y)
print('Symbolic solutions: ')
print(y_sol)

#lambdify()



#np arrays, then plot
23/53:
#setup expression, symbols
x, y = sym.symbols('x, y')
eqn = sym.Eq(x*y + sym.sin(x), x + y)
print('Original equation: ')
display(eqn)

#solve()
y_sol = sym.solve(eqn, y)
print('Symbolic solutions: ')
print(y_sol)

#lambdify()
new_fun = sym.lambdify(x, y_sol[0])
print(f'Test of lambdified function: {new_fun(np.pi/2)}')
print(f'Expected value: 1')

#np arrays, then plot
23/54:
#setup expression, symbols
x, y = sym.symbols('x, y')
eqn = sym.Eq(x*y + sym.sin(x), x + y)
print('Original equation: ')
display(eqn)

#solve()
y_sol = sym.solve(eqn, y)
print('Symbolic solutions: ')
print(y_sol)

#lambdify()
new_fun = sym.lambdify(x, y_sol[0])
print(f'\nTest of lambdified function: {new_fun(np.pi/2)}')
print(f'Expected value: 1')

#np arrays, then plot
23/55:
#setup expression, symbols
x, y = sym.symbols('x, y')
eqn = sym.Eq(x*y + sym.sin(x), x + y)
print('Original equation: ')
display(eqn)

#solve()
y_sol = sym.solve(eqn, y)
print('Symbolic solutions: ')
print(y_sol)

#lambdify()
new_fun = sym.lambdify(x, y_sol[0])
print(f'\nTest of lambdified function: {new_fun(np.pi/2)}')
print(f'Expected value: 1.0')

#np arrays, then plot
23/56:
#setup expression, symbols
x, y = sym.symbols('x, y')
eqn = sym.Eq(x*y + sym.sin(x), x + y)
print('Original equation: ')
display(eqn)

#solve()
y_sol = sym.solve(eqn, y)
print('Symbolic solutions: ')
print(y_sol)

#lambdify()
new_func = sym.lambdify(x, y_sol[0])
print(f'\nTest of lambdified function: {new_func(np.pi/2)}')
print(f'Expected value: 1.0')

#np arrays, then plot
x_list = np.arange(0, 10, 0.01)
y_list = new_func(x_list)

fig1 = plt.figure()
plt.plot(x_list, y_list)
plt.show()
23/57:
#setup expression, symbols
x, y = sym.symbols('x, y')
eqn = sym.Eq(x*y + sym.sin(x), x + y)
print('Original equation: ')
display(eqn)

#solve()
y_sol = sym.solve(eqn, y)
print('Symbolic solutions: ')
print(y_sol)

#lambdify()
new_func = sym.lambdify(x, y_sol[0])
print(f'\nTest of lambdified function: {new_func(np.pi/2)}')
print(f'Expected value: 1.0')

#np arrays, then plot
x_list = np.arange(0, np.pi, 0.01)
y_list = new_func(x_list)

fig1 = plt.figure()
plt.plot(x_list, y_list)
plt.show()
23/58:
#setup expression, symbols
x, y = sym.symbols('x, y')
eqn = sym.Eq(x*y + sym.sin(x), x + y)
print('Original equation: ')
display(eqn)

#solve()
y_sol = sym.solve(eqn, y)
print('Symbolic solutions: ')
print(y_sol)

#lambdify()
new_func = sym.lambdify(x, y_sol[0])
print(f'\nTest of lambdified function: {new_func(np.pi/2)}')
print(f'Expected value: 1.0')

#np arrays, then plot
x_list = np.arange(0, 10, 0.01)
y_list = new_func(x_list)

fig1 = plt.figure()
plt.plot(x_list, y_list)
plt.show()
23/59:
#setup expression, symbols
x, y = sym.symbols('x, y')
eqn = sym.Eq(x*y + sym.sin(x), x + y)
print('Original equation: ')
display(eqn)

#solve()
y_sol = sym.solve(eqn, y)
print('Symbolic solutions: ')
print(y_sol)

#lambdify()
new_func = sym.lambdify(x, y_sol[0])
print(f'\nTest of lambdified function: {new_func(np.pi/2)}')
print(f'Expected value: 1.0')

#np arrays, then plot
x_list = np.linspace(0, np.pi, 1000)
y_list = new_func(x_list)

fig1 = plt.figure()
plt.plot(x_list, y_list)
plt.show()
23/60:
#setup expression, symbols
x, y = sym.symbols('x, y')
eqn = sym.Eq(x*y + sym.sin(x), x + y)
print('Original equation: ')
display(eqn)

#solve()
y_sol = sym.solve(eqn, y)
print('Symbolic solutions: ')
print(y_sol)

#lambdify()
new_func = sym.lambdify(x, y_sol[0])
print(f'\nTest of lambdified function: {new_func(np.pi/2)}')
print(f'Expected value: 1.0')

#np arrays, then plot
x_list = np.arange(0, np.pi, 0.01)
y_list = new_func(x_list)

fig1 = plt.figure()
plt.plot(x_list, y_list)
plt.show()
23/61:
#setup expression, symbols
x, y = sym.symbols('x, y')
eqn = sym.Eq(x*y + sym.sin(x), x + y)
print('Original equation: ')
display(eqn)

#solve()
y_sol = sym.solve(eqn, y)
print('Symbolic solutions: ')
print(y_sol)

#lambdify()
new_func = sym.lambdify(x, y_sol[0])
print(f'\nTest of lambdified function: {new_func(np.pi/2)}')
print(f'Expected value: 1.0')

#np arrays, then plot
x_list = np.arange(0, np.pi, 0.01)
try:
    y_list = new_func(x_list)
except RuntimeWarning:
    pass

fig1 = plt.figure()
plt.plot(x_list, y_list)
plt.show()
23/62:
#setup expression, symbols
x, y = sym.symbols('x, y')
eqn = sym.Eq(x*y + sym.sin(x), x + y)
print('Original equation: ')
display(eqn)

#solve()
y_sol = sym.solve(eqn, y)
print('Symbolic solutions: ')
print(y_sol)

#lambdify()
new_func = sym.lambdify(x, y_sol[0])
print(f'\nTest of lambdified function: {new_func(np.pi/2)}')
print(f'Expected value: 1.0')

#np arrays, then plot
x_list = np.arange(0, np.pi, 0.01)
y_list = new_func(x_list)


fig1 = plt.figure()
plt.plot(x_list, y_list)
plt.show()
24/1:
#analytical form of integration: int{0}{pi/2}[ cos(t)sin(t)dt  ]
#can't integrate until that point because of the epsilon variable

def integrand1(t):
    return np.sin(t) * np.cos(t)

bounds = [0, np.pi/2.0]
step = 0.001

intval = integrate(integrand1, bounds, step)
print(f"Analytical integration: {intval}")
print(f"Expected answer: {0.5}")
25/1:
#IMPORT ALL NECESSARY PACKAGES AT THE TOP OF THE CODE
import sympy as sym
import numpy as np
import matplotlib.pyplot as plt
25/2:
# ##############################################################################################
# # If you're using Google Colab, uncomment this section by selecting the whole section and press
# # ctrl+'/' (Linux/Windows) or cmd+'/' (MacOS) on your and keyboard. Run it before you start 
# # programming, this will enable the nice LaTeX "display()" function for you. If you're using 
# # the local Jupyter environment, leave it alone
# ##############################################################################################


# def custom_latex_printer(exp,**options):
#     from google.colab.output._publish import javascript
#     url = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.1.1/latest.js?config=TeX-AMS_HTML"
#     javascript(url=url)
#     return sym.printing.latex(exp,**options)
# sym.init_printing(use_latex="mathjax",latex_printer=custom_latex_printer)
25/3:
####################################
# Part 1: compute derivative of f

# define your symbolic variable here
x = sym.symbols('x')

# define the function f
f = sym.sin(x) # if you're using Jupyter-Notebook, try "display(f)"

# compute derivative of f
# (uncomment next line and add your code)
df = f.diff(x)

# output resutls
print("derivative of f: ")
display(df)

####################################
# Part 2: compute directional derivative of f

# define dummy variable epsilon, and the direction v
eps, v = sym.symbols(r'\epsilon, v')

fnew = sym.sin(x + eps*v)

#differentiate w.r.t. the scaling factor
dfde = fnew.diff(eps)
print("derivative of f wrt epsilon:")
display(dfde)

#evaluated at epsilon = 0, this gives the directional deriv in v direction
dfnew = dfde.subs(eps, 0)
print('directional derivative of f in v direction: ')
display(dfnew)
25/4:
def integrate(func, xspan, step_size):
    '''
    Numerical integration with Euler's method

    Parameters:
    ====================
    func: Python function
        func is the function you want to integrate for
    xspan: list
        xspan is a list of two elements, representing 
        the start and end of integration
    step_size:
        a smaller step_size will give a more accurate result

    Returns:
    int_val:
        result of the integration
    ====================
    '''
    x = np.arange(xspan[0], xspan[1], step_size)
    int_val = 0
    for xi in x:
        int_val += func(xi) * step_size
    return int_val

#for x(t) = cos(t) and J(x(t)) = int{0}{pi/2} (1/2*x(t)^2) dt:

def integrand0(t):
    return 0.5 * (np.cos(t))**2

tspan = [0, np.pi/2.0]
step = 0.00005
res = integrate(integrand0, tspan, step)

print("Analytical solution for J(x(t)):")
print(f'Result: {res}')
print(f'Result * 8: {res*8}')
print(f'np.pi/8: {np.pi/8.0}')
25/5:
#analytical form of integration: int{0}{pi/2}[ cos(t)sin(t)dt  ]
#can't integrate until that point because of the epsilon variable

def integrand1(t):
    return np.sin(t) * np.cos(t)

bounds = [0, np.pi/2.0]
step = 0.001

intval = integrate(integrand1, bounds, step)
print(f"Analytical integration: {intval}")
print(f"Expected answer: {0.5}")
25/6:
t = sym.symbols('t')
# define function x and y
x = sym.Function('x')(t)
y = sym.Function('y')(t)
# define J(x(t), y(t))
J = sym.integrate(x**2 + x*y, [t, 0, sym.pi])
print('J(x(t), y(t)) = ')
display(J)

# take the time derivative of J(x(t))
dJdx = J.diff(x)
print('derivative of J(x(t), y(t)) wrt x(t): ')
display(dJdx)

# now, we have x(t)=sin(t) and y(t)=cos(t), we substitute them 
# in, and evaluate the integration
dJdx_subs = dJdx.subs({x:sym.sin(t), y:sym.cos(t)})
print('derivative of J, after substitution: ')
display(dJdx_subs)
print('evaluation of derivative of J, after substitution: ')
display(sym.N(dJdx_subs))
25/7:
# You can start your implementation here :)
eps, t = sym.symbols(r'\epsilon, t')

#J(x(t))
x = sym.Function('x')(t)
v = sym.Function('v')(t)

#functions that go into J(x(t)
f_x = 0.5 * x**2
f_x_dir = 0.5 * (x + eps * v) **2

#form of J(x(t)) function
J = sym.integrate(f_x, [t, 0, sym.pi/2])
print('J(x(t)): ')
display(J)

#substitute in x + eps*v
#J_dir = J.subs(f_x, f_x_dir)
J_dir = sym.integrate(f_x_dir, [t, 0, sym.pi/2])
print('J(x(t) + eps*v(t)): ')
display(J_dir) #---> why does it still show x^2(t)?

#differentiate wrt epsilon
dJde = J_dir.diff(eps)
print('d/dEps (J(x+eps*v)): ')
display(dJde)

#evaluate at epsilon = 0 
dJ_new = dJde.subs(eps, 0)
print('Directional derivative of J: ')
display(dJ_new)

#substitute in x(t) = cos(t), v = sin(t)
dJ_subbed = dJ_new.subs({x: sym.cos(t), v: sym.sin(t)})
print('Directional derivative of J after substitution: ')
display(dJ_subbed)

#solve.
print('Evaluation of DJ(x(t))*v after substitution: ')
display(dJ_subbed.evalf())
25/8:
# from sympy.abc import x, y # it's same as defining x, y using symbols() OR
x, y = sym.symbols(r'x,y')

# define an equation
eqn = sym.Eq(x**3 * 2*sym.sin(4*x), x*y)
print('Original equation')
display(eqn)

# solve this equation for y
y_sol = sym.solve(eqn, y) # this method returns a list, 
                             # which may include multiple solutions
print('Symbolic solutions')
print(y_sol)
y_expr = y_sol[0] # in this case we just have one solution

# lambdify the expression wrt symbol x
func = sym.lambdify(x, y_expr)
print('Test: func(1.0) = ', func(1.0))

##############
# now it's time to plot it from 0 to pi

# generate list of values from 0 to pi
x_list = np.linspace(0, np.pi, 100) 

# evaluate function at those values
f_list = func(x_list)

# plot it
plt.plot(x_list, f_list)
plt.show()
25/9: # You can start your implementation here :)
25/10:
#setup expression, symbols
x, y = sym.symbols('x, y')
eqn = sym.Eq(x*y + sym.sin(x), x + y)
print('Original equation: ')
display(eqn)

#solve()
y_sol = sym.solve(eqn, y)
print('Symbolic solutions: ')
print(y_sol)

#lambdify()
new_func = sym.lambdify(x, y_sol[0])
print(f'\nTest of lambdified function: {new_func(np.pi/2)}')
print(f'Expected value: 1.0')

#np arrays, then plot
x_list = np.arange(0, np.pi, 0.01)
y_list = new_func(x_list)


fig1 = plt.figure()
plt.plot(x_list, y_list)
plt.show()
25/11:
# You can start your implementation here :)
eps, t = sym.symbols(r'\epsilon, t')

#J(x(t))
x = sym.Function('x')(t)
v = sym.Function('v')(t)

#functions that go into J(x(t)
f_x = 0.5 * x**2
f_x_dir = 0.5 * (x + eps * v) **2

#form of J(x(t)) function
J = sym.integrate(f_x, [t, 0, sym.pi/2])
print('J(x(t)): ')
display(J)

#substitute in x + eps*v
J_dir = J.subs(f_x, f_x_dir)
#J_dir = sym.integrate(f_x_dir, [t, 0, sym.pi/2])
print('J(x(t) + eps*v(t)): ')
display(J_dir) #---> why does it still show x^2(t)?



# #differentiate wrt epsilon
# dJde = J_dir.diff(eps)
# print('d/dEps (J(x+eps*v)): ')
# display(dJde)

# #evaluate at epsilon = 0 
# dJ_new = dJde.subs(eps, 0)
# print('Directional derivative of J: ')
# display(dJ_new)

# #substitute in x(t) = cos(t), v = sin(t)
# dJ_subbed = dJ_new.subs({x: sym.cos(t), v: sym.sin(t)})
# print('Directional derivative of J after substitution: ')
# display(dJ_subbed)

# #solve.
# print('Evaluation of DJ(x(t))*v after substitution: ')
# display(dJ_subbed.evalf())
25/12:
# You can start your implementation here :)
eps, t = sym.symbols(r'\epsilon, t')

#J(x(t))
x = sym.Function('x')(t)
v = sym.Function('v')(t)

#functions that go into J(x(t)
f_x = 0.5 * x**2
f_x_dir = 0.5 * (x + eps * v) **2

print("F_x_dir:")
display(f_x_dir)

#form of J(x(t)) function
J = sym.integrate(f_x, [t, 0, sym.pi/2])
print('J(x(t)): ')
display(J)

#substitute in x + eps*v
J_dir = J.subs(f_x, f_x_dir)
#J_dir = sym.integrate(f_x_dir, [t, 0, sym.pi/2])
print('J(x(t) + eps*v(t)): ')
display(J_dir) #---> why does it still show x^2(t)?



# #differentiate wrt epsilon
# dJde = J_dir.diff(eps)
# print('d/dEps (J(x+eps*v)): ')
# display(dJde)

# #evaluate at epsilon = 0 
# dJ_new = dJde.subs(eps, 0)
# print('Directional derivative of J: ')
# display(dJ_new)

# #substitute in x(t) = cos(t), v = sin(t)
# dJ_subbed = dJ_new.subs({x: sym.cos(t), v: sym.sin(t)})
# print('Directional derivative of J after substitution: ')
# display(dJ_subbed)

# #solve.
# print('Evaluation of DJ(x(t))*v after substitution: ')
# display(dJ_subbed.evalf())
25/13:
# You can start your implementation here :)
eps, t = sym.symbols(r'\epsilon, t')

#J(x(t))
x = sym.Function('x')(t)
v = sym.Function('v')(t)

#functions that go into J(x(t)
f_x = 0.5 * x**2
f_x_dir = 0.5 * (x + eps * v) **2

print("F_x_dir:")
display(f_x_dir)

#form of J(x(t)) function
J = sym.integrate(f_x, [t, 0, sym.pi/2])
print('J(x(t)): ')
display(J)

#substitute in x + eps*v
#J_dir = J.subs(f_x, f_x_dir)
J_dir = J.subs(x, (x + eps * v))



#J_dir = sym.integrate(f_x_dir, [t, 0, sym.pi/2])
print('J(x(t) + eps*v(t)): ')
display(J_dir) #---> why does it still show x^2(t)?



# #differentiate wrt epsilon
# dJde = J_dir.diff(eps)
# print('d/dEps (J(x+eps*v)): ')
# display(dJde)

# #evaluate at epsilon = 0 
# dJ_new = dJde.subs(eps, 0)
# print('Directional derivative of J: ')
# display(dJ_new)

# #substitute in x(t) = cos(t), v = sin(t)
# dJ_subbed = dJ_new.subs({x: sym.cos(t), v: sym.sin(t)})
# print('Directional derivative of J after substitution: ')
# display(dJ_subbed)

# #solve.
# print('Evaluation of DJ(x(t))*v after substitution: ')
# display(dJ_subbed.evalf())
25/14:
# You can start your implementation here :)
eps, t = sym.symbols(r'\epsilon, t')

#J(x(t))
x = sym.Function('x')(t)
v = sym.Function('v')(t)

#functions that go into J(x(t)
f_x = 0.5 * x**2
f_x_dir = 0.5 * (x + eps * v) **2

print("F_x_dir:")
display(f_x_dir)

#form of J(x(t)) function
J = sym.integrate(f_x, [t, 0, sym.pi/2])
print('J(x(t)): ')
display(J)

#substitute in x + eps*v
#J_dir = J.subs(f_x, f_x_dir)
J_dir = J.subs(x, (x + eps * v))

#J_dir = sym.integrate(f_x_dir, [t, 0, sym.pi/2])
print('J(x(t) + eps*v(t)): ')
display(J_dir) #---> why does it still show x^2(t)?



#differentiate wrt epsilon
dJde = J_dir.diff(eps)
print('d/dEps (J(x+eps*v)): ')
display(dJde)

#evaluate at epsilon = 0 
dJ_new = dJde.subs(eps, 0)
print('Directional derivative of J: ')
display(dJ_new)

#substitute in x(t) = cos(t), v = sin(t)
dJ_subbed = dJ_new.subs({x: sym.cos(t), v: sym.sin(t)})
print('Directional derivative of J after substitution: ')
display(dJ_subbed)

#solve.
print('Evaluation of DJ(x(t))*v after substitution: ')
display(dJ_subbed.evalf())
25/15:
# You can start your implementation here :)

eps, t = sym.symbols(r'\epsilon, t')

#J(x(t))
x = sym.Function('x')(t)
v = sym.Function('v')(t)

#functions that go into J(x(t)
f_x = 0.5 * x**2
f_x_dir = 0.5 * (x + eps * v) **2

print("F_x_dir:")
display(f_x_dir)

#form of J(x(t)) function
J = sym.integrate(f_x, [t, 0, sym.pi/2])
print('J(x(t)): ')
display(J)

#substitute in x + eps*v
J_dir = J.subs(x, (x + eps * v))
print('J(x(t) + eps*v(t)): ')
display(J_dir)

#differentiate wrt epsilon
dJde = J_dir.diff(eps)
print('d/dEps (J(x+eps*v)): ')
display(dJde)

#evaluate at epsilon = 0 
dJ_new = dJde.subs(eps, 0)
print('Directional derivative of J * v: ')
display(dJ_new)

#substitute in x(t) = cos(t), v = sin(t)
dJ_subbed = dJ_new.subs({x: sym.cos(t), v: sym.sin(t)})
print('Derivative of J  in v direction after substitution: ')
display(dJ_subbed)

#solve.
print('Evaluation of DJ(x(t))*v after substitution: ')
display(dJ_subbed.evalf())
25/16:
# You can start your implementation here :)

eps, t = sym.symbols(r'\epsilon, t')

#J(x(t))
x = sym.Function('x')(t)
v = sym.Function('v')(t)

#functions that go into J(x(t)
f_x = 0.5 * x**2
f_x_dir = 0.5 * (x + eps * v) **2

print("F_x_dir:")
display(f_x_dir)

#form of J(x(t)) function
J = sym.integrate(f_x, [t, 0, sym.pi/2])
print('J(x(t)): ')
display(J)

#substitute in x + eps*v
J_dir = J.subs(x, (x + eps * v))
print('J(x(t) + eps*v(t)): ')
display(J_dir)

#differentiate wrt epsilon
dJde = J_dir.diff(eps)
print('d/dEps (J(x+eps*v)): ')
display(dJde)

#evaluate at epsilon = 0 
dJ_new = dJde.subs(eps, 0)
print('Directional derivative of J * v: ')
display(dJ_new)

#substitute in x(t) = cos(t), v = sin(t)
dJ_subbed = dJ_new.subs({x: sym.cos(t), v: sym.sin(t)})
print('Derivative of J in v direction after substitution: ')
display(dJ_subbed)

#solve.
print('Evaluation of DJ(x(t))*v after substitution: ')
display(dJ_subbed.evalf())
25/17: For Problem 2 written work, see PDF
25/18:
# You can start your implementation here :)

eps, t = sym.symbols(r'\epsilon, t')

#function representations
x = sym.Function('x')(t)
v = sym.Function('v')(t)
f_x = 0.5 * x**2

#form of J(x(t)) 
J = sym.integrate(f_x, [t, 0, sym.pi/2])
print('J(x(t)): ')
display(J)

#substitute in x + eps*v
J_dir = J.subs(x, (x + eps * v))
print('J(x(t) + eps*v(t)): ')
display(J_dir)

#differentiate wrt epsilon
dJde = J_dir.diff(eps)
print('d/dEps (J(x+eps*v)): ')
display(dJde)

#evaluate at epsilon = 0 
dJ_new = dJde.subs(eps, 0)
print('Directional derivative of J * v: ')
display(dJ_new)

#substitute in x(t) = cos(t), v = sin(t)
dJ_subbed = dJ_new.subs({x: sym.cos(t), v: sym.sin(t)})
print('Derivative of J in v direction after substitution: ')
display(dJ_subbed)

#solve.
print('Evaluation of DJ(x(t))*v after substitution: ')
display(dJ_subbed.evalf())
25/19:
#example code

# from sympy.abc import x, y # it's same as defining x, y using symbols() OR
x, y = sym.symbols(r'x,y')

# define an equation
eqn = sym.Eq(x**3 * 2*sym.sin(4*x), x*y)
print('Original equation')
display(eqn)

# solve this equation for y
y_sol = sym.solve(eqn, y) # this method returns a list, 
                             # which may include multiple solutions
print('Symbolic solutions')
print(y_sol)
y_expr = y_sol[0] # in this case we just have one solution

# lambdify the expression wrt symbol x
func = sym.lambdify(x, y_expr)
print('Test: func(1.0) = ', func(1.0))

##############
# now it's time to plot it from 0 to pi

# generate list of values from 0 to pi
x_list = np.linspace(0, np.pi, 100) 

# evaluate function at those values
f_list = func(x_list)

# plot it
plt.plot(x_list, f_list)
plt.show()
26/1:
#IMPORT ALL NECESSARY PACKAGES AT THE TOP OF THE CODE
import sympy as sym
import numpy as np
import matplotlib.pyplot as plt
26/2:
# ##############################################################################################
# # If you're using Google Colab, uncomment this section by selecting the whole section and press
# # ctrl+'/' (Linux/Windows) or cmd+'/' (MacOS) on your and keyboard. Run it before you start 
# # programming, this will enable the nice LaTeX "display()" function for you. If you're using 
# # the local Jupyter environment, leave it alone
# ##############################################################################################


# def custom_latex_printer(exp,**options):
#     from google.colab.output._publish import javascript
#     url = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.1.1/latest.js?config=TeX-AMS_HTML"
#     javascript(url=url)
#     return sym.printing.latex(exp,**options)
# sym.init_printing(use_latex="mathjax",latex_printer=custom_latex_printer)
26/3:
####################################
# Part 1: compute derivative of f

# define your symbolic variable here
x = sym.symbols('x')

# define the function f
f = sym.sin(x) # if you're using Jupyter-Notebook, try "display(f)"

# compute derivative of f
# (uncomment next line and add your code)
df = f.diff(x)

# output resutls
print("derivative of f: ")
display(df)

####################################
# Part 2: compute directional derivative of f

# define dummy variable epsilon, and the direction v
eps, v = sym.symbols(r'\epsilon, v')

fnew = sym.sin(x + eps*v)

#differentiate w.r.t. the scaling factor
dfde = fnew.diff(eps)
print("derivative of f wrt epsilon:")
display(dfde)

#evaluated at epsilon = 0, this gives the directional deriv in v direction
dfnew = dfde.subs(eps, 0)
print('directional derivative of f in v direction: ')
display(dfnew)
26/4:
def integrate(func, xspan, step_size):
    '''
    Numerical integration with Euler's method

    Parameters:
    ====================
    func: Python function
        func is the function you want to integrate for
    xspan: list
        xspan is a list of two elements, representing 
        the start and end of integration
    step_size:
        a smaller step_size will give a more accurate result

    Returns:
    int_val:
        result of the integration
    ====================
    '''
    x = np.arange(xspan[0], xspan[1], step_size)
    int_val = 0
    for xi in x:
        int_val += func(xi) * step_size
    return int_val
26/5:
#my implementation: 

#given x(t) = cos(t) and J(x(t)) = int{0}{pi/2} (1/2*x(t)^2) dt:

def integrand0(t):
    return 0.5 * (np.cos(t))**2

tspan = [0, np.pi/2.0]
step = 0.00005
res = integrate(integrand0, tspan, step)

print("Analytical solution for J(x(t)):")
print(f'Result: {res}')
print(f'Result * 8: {res*8}')
print(f'np.pi/8: {np.pi/8.0}')
26/6:
#analytical form of integration: int{0}{pi/2}[ cos(t)sin(t)dt  ]

#numerical integration below

def integrand1(t):
    return np.sin(t) * np.cos(t)

bounds = [0, np.pi/2.0]
step = 0.001

intval = integrate(integrand1, bounds, step)
print(f"Analytical integration: {intval}")
print(f"Expected answer: {0.5}")
26/7:
#example code:

t = sym.symbols('t')
# define function x and y
x = sym.Function('x')(t)
y = sym.Function('y')(t)
# define J(x(t), y(t))
J = sym.integrate(x**2 + x*y, [t, 0, sym.pi])
print('J(x(t), y(t)) = ')
display(J)

# take the time derivative of J(x(t))
dJdx = J.diff(x)
print('derivative of J(x(t), y(t)) wrt x(t): ')
display(dJdx)

# now, we have x(t)=sin(t) and y(t)=cos(t), we substitute them 
# in, and evaluate the integration
dJdx_subs = dJdx.subs({x:sym.sin(t), y:sym.cos(t)})
print('derivative of J, after substitution: ')
display(dJdx_subs)
print('evaluation of derivative of J, after substitution: ')
display(sym.N(dJdx_subs))
26/8:
# You can start your implementation here :)

eps, t = sym.symbols(r'\epsilon, t')

#function representations
x = sym.Function('x')(t)
v = sym.Function('v')(t)
f_x = 0.5 * x**2

#form of J(x(t)) 
J = sym.integrate(f_x, [t, 0, sym.pi/2])
print('J(x(t)): ')
display(J)

#substitute in x + eps*v
J_dir = J.subs(x, (x + eps * v))
print('J(x(t) + eps*v(t)): ')
display(J_dir)

#differentiate wrt epsilon
dJde = J_dir.diff(eps)
print('d/dEps (J(x+eps*v)): ')
display(dJde)

#evaluate at epsilon = 0 
dJ_new = dJde.subs(eps, 0)
print('Directional derivative of J * v: ')
display(dJ_new)

#substitute in x(t) = cos(t), v = sin(t)
dJ_subbed = dJ_new.subs({x: sym.cos(t), v: sym.sin(t)})
print('Derivative of J in v direction after substitution: ')
display(dJ_subbed)

#solve.
print('Evaluation of DJ(x(t))*v after substitution: ')
display(dJ_subbed.evalf())
26/9:
#example code

# from sympy.abc import x, y # it's same as defining x, y using symbols() OR
x, y = sym.symbols(r'x,y')

# define an equation
eqn = sym.Eq(x**3 * 2*sym.sin(4*x), x*y)
print('Original equation')
display(eqn)

# solve this equation for y
y_sol = sym.solve(eqn, y) # this method returns a list, 
                             # which may include multiple solutions
print('Symbolic solutions')
print(y_sol)
y_expr = y_sol[0] # in this case we just have one solution

# lambdify the expression wrt symbol x
func = sym.lambdify(x, y_expr)
print('Test: func(1.0) = ', func(1.0))

##############
# now it's time to plot it from 0 to pi

# generate list of values from 0 to pi
x_list = np.linspace(0, np.pi, 100) 

# evaluate function at those values
f_list = func(x_list)

# plot it
plt.plot(x_list, f_list)
plt.show()
26/10:
# You can start your implementation here :)

#setup expression, symbols
x, y = sym.symbols('x, y')
eqn = sym.Eq(x*y + sym.sin(x), x + y)
print('Original equation: ')
display(eqn)

#solve()
y_sol = sym.solve(eqn, y)
print('Symbolic solutions: ')
print(y_sol)

#lambdify()
new_func = sym.lambdify(x, y_sol[0])
print(f'\nTest of lambdified function: {new_func(np.pi/2)}')
print(f'Expected value: 1.0')

#np arrays, then plot
x_list = np.arange(0, np.pi, 0.01)
y_list = new_func(x_list)


fig1 = plt.figure()
plt.plot(x_list, y_list)
plt.show()
26/11:
#IMPORT ALL NECESSARY PACKAGES AT THE TOP OF THE CODE
import sympy as sym
import numpy as np
import matplotlib.pyplot as plt

from IPython.display import Markdown, display

# How to print in bold.You could wrap the "display(Markdown())""
# in a function if you want a more concise alternative. 

# answer = 42

# display(Markdown("**Hello World: {}**".format(answer)))
26/12:
####################################
# Part 1: compute derivative of f

# define your symbolic variable here
x = sym.symbols('x')

# define the function f
f = sym.sin(x) # if you're using Jupyter-Notebook, try "display(f)"

# compute derivative of f
# (uncomment next line and add your code)
df = f.diff(x)

# output resutls
print("derivative of f: ")
display(df)

####################################
# Part 2: compute directional derivative of f

# define dummy variable epsilon, and the direction v
eps, v = sym.symbols(r'\epsilon, v')

fnew = sym.sin(x + eps*v)

#differentiate w.r.t. the scaling factor
dfde = fnew.diff(eps)
print("derivative of f wrt epsilon:")
display(dfde)

#evaluated at epsilon = 0, this gives the directional deriv in v direction
dfnew = dfde.subs(eps, 0)
display(Markdown("**directional derivative of f in v direction: {}**".format(dfnew))
display(dfnew)
26/13:
####################################
# Part 1: compute derivative of f

# define your symbolic variable here
x = sym.symbols('x')

# define the function f
f = sym.sin(x) # if you're using Jupyter-Notebook, try "display(f)"

# compute derivative of f
# (uncomment next line and add your code)
df = f.diff(x)

# output resutls
print("derivative of f: ")
display(df)

####################################
# Part 2: compute directional derivative of f

# define dummy variable epsilon, and the direction v
eps, v = sym.symbols(r'\epsilon, v')

fnew = sym.sin(x + eps*v)

#differentiate w.r.t. the scaling factor
dfde = fnew.diff(eps)
print("derivative of f wrt epsilon:")
display(dfde)

#evaluated at epsilon = 0, this gives the directional deriv in v direction
dfnew = dfde.subs(eps, 0)
display(Markdown("**directional derivative of f in v direction: {}**".format(dfnew)))
display(dfnew)
26/14:
####################################
# Part 1: compute derivative of f

# define your symbolic variable here
x = sym.symbols('x')

# define the function f
f = sym.sin(x) # if you're using Jupyter-Notebook, try "display(f)"

# compute derivative of f
# (uncomment next line and add your code)
df = f.diff(x)

# output resutls
print("derivative of f: ")
display(df)

####################################
# Part 2: compute directional derivative of f

# define dummy variable epsilon, and the direction v
eps, v = sym.symbols(r'\epsilon, v')

fnew = sym.sin(x + eps*v)

#differentiate w.r.t. the scaling factor
dfde = fnew.diff(eps)
print("derivative of f wrt epsilon:")
display(dfde)

#evaluated at epsilon = 0, this gives the directional deriv in v direction
dfnew = dfde.subs(eps, 0)
display(Markdown("**directional derivative of f in v direction:**")
display(dfnew)
26/15:
####################################
# Part 1: compute derivative of f

# define your symbolic variable here
x = sym.symbols('x')

# define the function f
f = sym.sin(x) # if you're using Jupyter-Notebook, try "display(f)"

# compute derivative of f
# (uncomment next line and add your code)
df = f.diff(x)

# output resutls
print("derivative of f: ")
display(df)

####################################
# Part 2: compute directional derivative of f

# define dummy variable epsilon, and the direction v
eps, v = sym.symbols(r'\epsilon, v')

fnew = sym.sin(x + eps*v)

#differentiate w.r.t. the scaling factor
dfde = fnew.diff(eps)
print("derivative of f wrt epsilon:")
display(dfde)

#evaluated at epsilon = 0, this gives the directional deriv in v direction
dfnew = dfde.subs(eps, 0)
display(Markdown("**directional derivative of f in v direction:**"))
display(dfnew)
26/16:
#analytical form of integration: int{0}{pi/2}[ cos(t)sin(t)dt  ]

#numerical integration below

def integrand1(t):
    return np.sin(t) * np.cos(t)

bounds = [0, np.pi/2.0]
step = 0.001

intval = integrate(integrand1, bounds, step)
print(f"Expected answer: {0.5}")
display(Markdown("**Analytical integration: {intval}**")
26/17:
#analytical form of integration: int{0}{pi/2}[ cos(t)sin(t)dt  ]

#numerical integration below

def integrand1(t):
    return np.sin(t) * np.cos(t)

bounds = [0, np.pi/2.0]
step = 0.001

intval = integrate(integrand1, bounds, step)
print(f"Expected answer: {0.5}")
display(Markdown("**Analytical integration: {intval}**"))
26/18:
#analytical form of integration: int{0}{pi/2}[ cos(t)sin(t)dt  ]

#numerical integration below

def integrand1(t):
    return np.sin(t) * np.cos(t)

bounds = [0, np.pi/2.0]
step = 0.001

intval = integrate(integrand1, bounds, step)
print(f"Expected answer: {0.5}")
display(Markdown(f"**Analytical integration: {intval}**"))
26/19:
#example code:

t = sym.symbols('t')
# define function x and y
x = sym.Function('x')(t)
y = sym.Function('y')(t)
# define J(x(t), y(t))
J = sym.integrate(x**2 + x*y, [t, 0, sym.pi])
print('J(x(t), y(t)) = ')
display(J)

# take the time derivative of J(x(t))
dJdx = J.diff(x)
print('derivative of J(x(t), y(t)) wrt x(t): ')
display(dJdx)

# now, we have x(t)=sin(t) and y(t)=cos(t), we substitute them 
# in, and evaluate the integration
dJdx_subs = dJdx.subs({x:sym.sin(t), y:sym.cos(t)})
print('derivative of J, after substitution: ')
display(dJdx_subs)
display(Markdown('**evaluation of derivative of J, after substitution: **'))
display(sym.N(dJdx_subs))
26/20:
#example code:

t = sym.symbols('t')
# define function x and y
x = sym.Function('x')(t)
y = sym.Function('y')(t)
# define J(x(t), y(t))
J = sym.integrate(x**2 + x*y, [t, 0, sym.pi])
print('J(x(t), y(t)) = ')
display(J)

# take the time derivative of J(x(t))
dJdx = J.diff(x)
print('derivative of J(x(t), y(t)) wrt x(t): ')
display(dJdx)

# now, we have x(t)=sin(t) and y(t)=cos(t), we substitute them 
# in, and evaluate the integration
dJdx_subs = dJdx.subs({x:sym.sin(t), y:sym.cos(t)})
print('derivative of J, after substitution: ')
display(dJdx_subs)
display(Markdown("**evaluation of derivative of J, after substitution: **"))
display(sym.N(dJdx_subs))
26/21:
#example code:

t = sym.symbols('t')
# define function x and y
x = sym.Function('x')(t)
y = sym.Function('y')(t)
# define J(x(t), y(t))
J = sym.integrate(x**2 + x*y, [t, 0, sym.pi])
print('J(x(t), y(t)) = ')
display(J)

# take the time derivative of J(x(t))
dJdx = J.diff(x)
print('derivative of J(x(t), y(t)) wrt x(t): ')
display(dJdx)

# now, we have x(t)=sin(t) and y(t)=cos(t), we substitute them 
# in, and evaluate the integration
dJdx_subs = dJdx.subs({x:sym.sin(t), y:sym.cos(t)})
print('derivative of J, after substitution: ')
display(dJdx_subs)
display(Markdown("** evaluation of derivative of J, after substitution: **"))
display(sym.N(dJdx_subs))
26/22:
#example code:

t = sym.symbols('t')
# define function x and y
x = sym.Function('x')(t)
y = sym.Function('y')(t)
# define J(x(t), y(t))
J = sym.integrate(x**2 + x*y, [t, 0, sym.pi])
print('J(x(t), y(t)) = ')
display(J)

# take the time derivative of J(x(t))
dJdx = J.diff(x)
print('derivative of J(x(t), y(t)) wrt x(t): ')
display(dJdx)

# now, we have x(t)=sin(t) and y(t)=cos(t), we substitute them 
# in, and evaluate the integration
dJdx_subs = dJdx.subs({x:sym.sin(t), y:sym.cos(t)})
print('derivative of J, after substitution: ')
display(dJdx_subs)
display(Markdown("**evaluation of derivative of J, after substitution:**"))
display(sym.N(dJdx_subs))
26/23:
# You can start your implementation here :)

eps, t = sym.symbols(r'\epsilon, t')

#function representations
x = sym.Function('x')(t)
v = sym.Function('v')(t)
f_x = 0.5 * x**2

#form of J(x(t)) 
J = sym.integrate(f_x, [t, 0, sym.pi/2])
print('J(x(t)): ')
display(J)

#substitute in x + eps*v
J_dir = J.subs(x, (x + eps * v))
print('J(x(t) + eps*v(t)): ')
display(J_dir)

#differentiate wrt epsilon
dJde = J_dir.diff(eps)
print('d/dEps (J(x+eps*v)): ')
display(dJde)

#evaluate at epsilon = 0 
dJ_new = dJde.subs(eps, 0)
print('Directional derivative of J * v: ')
display(dJ_new)

#substitute in x(t) = cos(t), v = sin(t)
dJ_subbed = dJ_new.subs({x: sym.cos(t), v: sym.sin(t)})
print('Derivative of J in v direction after substitution: ')
display(dJ_subbed)

#solve.
display(Markdown("**Evaluation of DJ(x(t))*v after substitution: **"))
display(dJ_subbed.evalf())
26/24:
# You can start your implementation here :)

eps, t = sym.symbols(r'\epsilon, t')

#function representations
x = sym.Function('x')(t)
v = sym.Function('v')(t)
f_x = 0.5 * x**2

#form of J(x(t)) 
J = sym.integrate(f_x, [t, 0, sym.pi/2])
print('J(x(t)): ')
display(J)

#substitute in x + eps*v
J_dir = J.subs(x, (x + eps * v))
print('J(x(t) + eps*v(t)): ')
display(J_dir)

#differentiate wrt epsilon
dJde = J_dir.diff(eps)
print('d/dEps (J(x+eps*v)): ')
display(dJde)

#evaluate at epsilon = 0 
dJ_new = dJde.subs(eps, 0)
print('Directional derivative of J * v: ')
display(dJ_new)

#substitute in x(t) = cos(t), v = sin(t)
dJ_subbed = dJ_new.subs({x: sym.cos(t), v: sym.sin(t)})
print('Derivative of J in v direction after substitution: ')
display(dJ_subbed)

#solve.
display(Markdown("** Evaluation of DJ(x(t))*v after substitution: **"))
display(dJ_subbed.evalf())
26/25:
# You can start your implementation here :)

eps, t = sym.symbols(r'\epsilon, t')

#function representations
x = sym.Function('x')(t)
v = sym.Function('v')(t)
f_x = 0.5 * x**2

#form of J(x(t)) 
J = sym.integrate(f_x, [t, 0, sym.pi/2])
print('J(x(t)): ')
display(J)

#substitute in x + eps*v
J_dir = J.subs(x, (x + eps * v))
print('J(x(t) + eps*v(t)): ')
display(J_dir)

#differentiate wrt epsilon
dJde = J_dir.diff(eps)
print('d/dEps (J(x+eps*v)): ')
display(dJde)

#evaluate at epsilon = 0 
dJ_new = dJde.subs(eps, 0)
print('Directional derivative of J * v: ')
display(dJ_new)

#substitute in x(t) = cos(t), v = sin(t)
dJ_subbed = dJ_new.subs({x: sym.cos(t), v: sym.sin(t)})
print('Derivative of J in v direction after substitution: ')
display(dJ_subbed)

#solve.
display(Markdown("** Evaluation of DJ(x(t))*v after substitution: ** "))
display(dJ_subbed.evalf())
26/26:
# You can start your implementation here :)

eps, t = sym.symbols(r'\epsilon, t')

#function representations
x = sym.Function('x')(t)
v = sym.Function('v')(t)
f_x = 0.5 * x**2

#form of J(x(t)) 
J = sym.integrate(f_x, [t, 0, sym.pi/2])
print('J(x(t)): ')
display(J)

#substitute in x + eps*v
J_dir = J.subs(x, (x + eps * v))
print('J(x(t) + eps*v(t)): ')
display(J_dir)

#differentiate wrt epsilon
dJde = J_dir.diff(eps)
print('d/dEps (J(x+eps*v)): ')
display(dJde)

#evaluate at epsilon = 0 
dJ_new = dJde.subs(eps, 0)
print('Directional derivative of J * v: ')
display(dJ_new)

#substitute in x(t) = cos(t), v = sin(t)
dJ_subbed = dJ_new.subs({x: sym.cos(t), v: sym.sin(t)})
print('Derivative of J in v direction after substitution: ')
display(dJ_subbed)

#solve.
display(Markdown(" **Evaluation of DJ(x(t))*v after substitution:** "))
display(dJ_subbed.evalf())
26/27:
# You can start your implementation here :)

#setup expression, symbols
x, y = sym.symbols('x, y')
eqn = sym.Eq(x*y + sym.sin(x), x + y)
print('Original equation: ')
display(eqn)

#solve()
y_sol = sym.solve(eqn, y)
display(Markdown(" **Symbolic solutions: \ {y_sol}** ")
print(y_sol)

#lambdify()
new_func = sym.lambdify(x, y_sol[0])
print(f'\nTest of lambdified function: {new_func(np.pi/2)}')
print(f'Expected value: 1.0')

#np arrays, then plot
x_list = np.arange(0, np.pi, 0.01)
y_list = new_func(x_list)


fig1 = plt.figure()
plt.plot(x_list, y_list)
plt.show()
26/28:
# You can start your implementation here :)

#setup expression, symbols
x, y = sym.symbols('x, y')
eqn = sym.Eq(x*y + sym.sin(x), x + y)
print('Original equation: ')
display(eqn)

#solve()
y_sol = sym.solve(eqn, y)
display(Markdown(" **Symbolic solutions: \ {y_sol}** "))
print(y_sol)

#lambdify()
new_func = sym.lambdify(x, y_sol[0])
print(f'\nTest of lambdified function: {new_func(np.pi/2)}')
print(f'Expected value: 1.0')

#np arrays, then plot
x_list = np.arange(0, np.pi, 0.01)
y_list = new_func(x_list)


fig1 = plt.figure()
plt.plot(x_list, y_list)
plt.show()
26/29:
# You can start your implementation here :)

#setup expression, symbols
x, y = sym.symbols('x, y')
eqn = sym.Eq(x*y + sym.sin(x), x + y)
print('Original equation: ')
display(eqn)

#solve()
y_sol = sym.solve(eqn, y)
display(Markdown(f" **Symbolic solutions: \ {y_sol}** "))
print(y_sol)

#lambdify()
new_func = sym.lambdify(x, y_sol[0])
print(f'\nTest of lambdified function: {new_func(np.pi/2)}')
print(f'Expected value: 1.0')

#np arrays, then plot
x_list = np.arange(0, np.pi, 0.01)
y_list = new_func(x_list)


fig1 = plt.figure()
plt.plot(x_list, y_list)
plt.show()
26/30:
# You can start your implementation here :)

#setup expression, symbols
x, y = sym.symbols('x, y')
eqn = sym.Eq(x*y + sym.sin(x), x + y)
print('Original equation: ')
display(eqn)

#solve()
y_sol = sym.solve(eqn, y)
display(Markdown(f" **Symbolic solutions: <br> {y_sol}** "))
print(y_sol)

#lambdify()
new_func = sym.lambdify(x, y_sol[0])
print(f'\nTest of lambdified function: {new_func(np.pi/2)}')
print(f'Expected value: 1.0')

#np arrays, then plot
x_list = np.arange(0, np.pi, 0.01)
y_list = new_func(x_list)


fig1 = plt.figure()
plt.plot(x_list, y_list)
plt.show()
26/31:
# You can start your implementation here :)

#setup expression, symbols
x, y = sym.symbols('x, y')
eqn = sym.Eq(x*y + sym.sin(x), x + y)
print('Original equation: ')
display(eqn)

#solve()
y_sol = sym.solve(eqn, y)
display(Markdown(f" **Symbolic solutions: <br> {y_sol}** "))

#lambdify()
new_func = sym.lambdify(x, y_sol[0])
print(f'\nTest of lambdified function: {new_func(np.pi/2)}')
print(f'Expected value: 1.0')

#np arrays, then plot
x_list = np.arange(0, np.pi, 0.01)
y_list = new_func(x_list)


fig1 = plt.figure()
plt.plot(x_list, y_list)
plt.show()
27/1:
#IMPORT ALL NECESSARY PACKAGES AT THE TOP OF THE CODE
import sympy as sym
import numpy as np
import matplotlib.pyplot as plt

from IPython.display import Markdown, display

# How to print in bold.You could wrap the "display(Markdown())""
# in a function if you want a more concise alternative. 

# answer = 42

# display(Markdown("**Hello World: {}**".format(answer)))
27/2:
# ##############################################################################################
# # If you're using Google Colab, uncomment this section by selecting the whole section and press
# # ctrl+'/' (Linux/Windows) or cmd+'/' (MacOS) on your and keyboard. Run it before you start 
# # programming, this will enable the nice LaTeX "display()" function for you. If you're using 
# # the local Jupyter environment, leave it alone
# ##############################################################################################


# def custom_latex_printer(exp,**options):
#     from google.colab.output._publish import javascript
#     url = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.1.1/latest.js?config=TeX-AMS_HTML"
#     javascript(url=url)
#     return sym.printing.latex(exp,**options)
# sym.init_printing(use_latex="mathjax",latex_printer=custom_latex_printer)
27/3:
####################################
# Part 1: compute derivative of f

# define your symbolic variable here
x = sym.symbols('x')

# define the function f
f = sym.sin(x) # if you're using Jupyter-Notebook, try "display(f)"

# compute derivative of f
# (uncomment next line and add your code)
df = f.diff(x)

# output resutls
print("derivative of f: ")
display(df)

####################################
# Part 2: compute directional derivative of f

# define dummy variable epsilon, and the direction v
eps, v = sym.symbols(r'\epsilon, v')

fnew = sym.sin(x + eps*v)

#differentiate w.r.t. the scaling factor
dfde = fnew.diff(eps)
print("derivative of f wrt epsilon:")
display(dfde)

#evaluated at epsilon = 0, this gives the directional deriv in v direction
dfnew = dfde.subs(eps, 0)
display(Markdown("**directional derivative of f in v direction:**"))
display(dfnew)
27/4:
def integrate(func, xspan, step_size):
    '''
    Numerical integration with Euler's method

    Parameters:
    ====================
    func: Python function
        func is the function you want to integrate for
    xspan: list
        xspan is a list of two elements, representing 
        the start and end of integration
    step_size:
        a smaller step_size will give a more accurate result

    Returns:
    int_val:
        result of the integration
    ====================
    '''
    x = np.arange(xspan[0], xspan[1], step_size)
    int_val = 0
    for xi in x:
        int_val += func(xi) * step_size
    return int_val
27/5:
#my implementation: 

#given x(t) = cos(t) and J(x(t)) = int{0}{pi/2} (1/2*x(t)^2) dt:

def integrand0(t):
    return 0.5 * (np.cos(t))**2

tspan = [0, np.pi/2.0]
step = 0.00005
res = integrate(integrand0, tspan, step)

print("Analytical solution for J(x(t)):")
print(f'Result: {res}')
print(f'Result * 8: {res*8}')
print(f'np.pi/8: {np.pi/8.0}')
27/6:
#analytical form of integration: int{0}{pi/2}[ cos(t)sin(t)dt  ]

#numerical integration below

def integrand1(t):
    return np.sin(t) * np.cos(t)

bounds = [0, np.pi/2.0]
step = 0.001

intval = integrate(integrand1, bounds, step)
print(f"Expected answer: {0.5}")
display(Markdown(f"**Analytical integration: {intval}**"))
27/7:
#example code:

t = sym.symbols('t')
# define function x and y
x = sym.Function('x')(t)
y = sym.Function('y')(t)
# define J(x(t), y(t))
J = sym.integrate(x**2 + x*y, [t, 0, sym.pi])
print('J(x(t), y(t)) = ')
display(J)

# take the time derivative of J(x(t))
dJdx = J.diff(x)
print('derivative of J(x(t), y(t)) wrt x(t): ')
display(dJdx)

# now, we have x(t)=sin(t) and y(t)=cos(t), we substitute them 
# in, and evaluate the integration
dJdx_subs = dJdx.subs({x:sym.sin(t), y:sym.cos(t)})
print('derivative of J, after substitution: ')
display(dJdx_subs)
display(Markdown("**evaluation of derivative of J, after substitution:**"))
display(sym.N(dJdx_subs))
27/8:
# You can start your implementation here :)

eps, t = sym.symbols(r'\epsilon, t')

#function representations
x = sym.Function('x')(t)
v = sym.Function('v')(t)
f_x = 0.5 * x**2

#form of J(x(t)) 
J = sym.integrate(f_x, [t, 0, sym.pi/2])
print('J(x(t)): ')
display(J)

#substitute in x + eps*v
J_dir = J.subs(x, (x + eps * v))
print('J(x(t) + eps*v(t)): ')
display(J_dir)

#differentiate wrt epsilon
dJde = J_dir.diff(eps)
print('d/dEps (J(x+eps*v)): ')
display(dJde)

#evaluate at epsilon = 0 
dJ_new = dJde.subs(eps, 0)
print('Directional derivative of J * v: ')
display(dJ_new)

#substitute in x(t) = cos(t), v = sin(t)
dJ_subbed = dJ_new.subs({x: sym.cos(t), v: sym.sin(t)})
print('Derivative of J in v direction after substitution: ')
display(dJ_subbed)

#solve.
display(Markdown(" **Evaluation of DJ(x(t))*v after substitution:** "))
display(dJ_subbed.evalf())
27/9:
#example code

# from sympy.abc import x, y # it's same as defining x, y using symbols() OR
x, y = sym.symbols(r'x,y')

# define an equation
eqn = sym.Eq(x**3 * 2*sym.sin(4*x), x*y)
print('Original equation')
display(eqn)

# solve this equation for y
y_sol = sym.solve(eqn, y) # this method returns a list, 
                             # which may include multiple solutions
print('Symbolic solutions')
print(y_sol)
y_expr = y_sol[0] # in this case we just have one solution

# lambdify the expression wrt symbol x
func = sym.lambdify(x, y_expr)
print('Test: func(1.0) = ', func(1.0))

##############
# now it's time to plot it from 0 to pi

# generate list of values from 0 to pi
x_list = np.linspace(0, np.pi, 100) 

# evaluate function at those values
f_list = func(x_list)

# plot it
plt.plot(x_list, f_list)
plt.show()
27/10:
# You can start your implementation here :)

#setup expression, symbols
x, y = sym.symbols('x, y')
eqn = sym.Eq(x*y + sym.sin(x), x + y)
print('Original equation: ')
display(eqn)

#solve()
y_sol = sym.solve(eqn, y)
display(Markdown(f" **Symbolic solutions: <br> {y_sol}** "))

#lambdify()
new_func = sym.lambdify(x, y_sol[0])
print(f'\nTest of lambdified function: {new_func(np.pi/2)}')
print(f'Expected value: 1.0')

#np arrays, then plot
x_list = np.arange(0, np.pi, 0.01)
y_list = new_func(x_list)


fig1 = plt.figure()
plt.plot(x_list, y_list)
plt.show()
28/1:
import sympy as sym
from sympy.abc import x, y, z, t, s
from sympy import Matrix
from sympy import Function, Symbol
from sympy import diff, integrate

t=Symbol(’t’)
s=Symbol(’s’)
f=Function(’f’)(s)
g=Function(’g’)(s)

# define a vector
w = Matrix([ x, y, z])

#define a function X of the vector w
X=w.T*w
diffX=(w.T*w).jacobian(w)
print(’The derivative of X is’,diffX)

#define a function Y of the function f
Y=(f**2)
diffY=Y.diff(s)
print(’The derivative of Y is’,diffY)

#define a function Z of the integral of a function and see if sympy applies
Leibniz rule
Z=integrate(f**2,[s,0,t])
diffZ=Z.diff(t)
print(’The derivative of Z is’,diffZ)
28/2:
import sympy as sym
from sympy.abc import x, y, z, t, s
from sympy import Matrix
from sympy import Function, Symbol
from sympy import diff, integrate

t=Symbol('t')
s=Symbol('s')
f=Function('f')(s)
g=Function('g')(s)

# define a vector
w = Matrix([ x, y, z])

#define a function X of the vector w
X=w.T*w
diffX=(w.T*w).jacobian(w)
print('The derivative of X is',diffX)

#define a function Y of the function f
Y=(f**2)
diffY=Y.diff(s)
print('The derivative of Y is',diffY)

#define a function Z of the integral of a function and see if sympy applies
Leibniz rule
Z=integrate(f**2,[s,0,t])
diffZ=Z.diff(t)
print('The derivative of Z is',diffZ)
28/3:
import sympy as sym
from sympy.abc import x, y, z, t, s
from sympy import Matrix
from sympy import Function, Symbol
from sympy import diff, integrate

t=Symbol('t')
s=Symbol('s')
f=Function('f')(s)
g=Function('g')(s)

# define a vector
w = Matrix([ x, y, z])

#define a function X of the vector w
X=w.T*w
diffX=(w.T*w).jacobian(w)
print('The derivative of X is',diffX)

#define a function Y of the function f
Y=(f**2)
diffY=Y.diff(s)
print('The derivative of Y is',diffY)

#define a function Z of the integral of a function and see if sympy applies
#Leibniz rule
Z=integrate(f**2,[s,0,t])
diffZ=Z.diff(t)
print('The derivative of Z is',diffZ)
28/4:
#IMPORT ALL NECESSARY PACKAGES AT THE TOP OF THE CODE
import sympy as sym
import numpy as np
import matplotlib.pyplot as plt

from IPython.display import Markdown, display

# How to print in bold.You could wrap the "display(Markdown())""
# in a function if you want a more concise alternative. 

# answer = 42

# display(Markdown("**Hello World: {}**".format(answer)))
28/5:
import sympy as sym
from sympy.abc import x, y, z, t, s
from sympy import Matrix
from sympy import Function, Symbol
from sympy import diff, integrate

t=Symbol('t')
s=Symbol('s')
f=Function('f')(s)
g=Function('g')(s)

# define a vector
w = Matrix([ x, y, z])

#define a function X of the vector w
X=w.T*w
diffX=(w.T*w).jacobian(w)
print('The derivative of X is',diffX)

#define a function Y of the function f
Y=(f**2)
diffY=Y.diff(s)
print('The derivative of Y is',diffY)

#define a function Z of the integral of a function and see if sympy applies
#Leibniz rule
Z=integrate(f**2,[s,0,t])
diffZ=Z.diff(t)
print('The derivative of Z is',diffZ)
28/6:
import sympy as sym
from sympy.abc import x, y, z, t, s
from sympy import Matrix
from sympy import Function, Symbol
from sympy import diff, integrate

t=Symbol('t')
s=Symbol('s')
f=Function('f')(s)
g=Function('g')(s)

# define a vector
w = Matrix([ x, y, z])

#define a function X of the vector w
X=w.T*w
diffX=(w.T*w).jacobian(w)
print('The derivative of X is')
display(diffX)

#define a function Y of the function f
Y=(f**2)
diffY=Y.diff(s)
print('The derivative of Y is')
display(diffY)

#define a function Z of the integral of a function and see if sympy applies
#Leibniz rule
Z=integrate(f**2,[s,0,t])
diffZ=Z.diff(t)
print('The derivative of Z is')
display(diffZ)
30/1:
# You can start your implementation here :)

#grab variables
# from sympy.abc import x, y, z or do sym.symbols
x1, x2 = sym.symbols(r'x1, x2') #state variables
k1, k2, m1, m2 = sym.symbols(r'k1, k2, m1, m2') # constants
x1dd = sym.Function(x1, x2) 
x2dd = sym.Function(x1, x2)

#write equations of x1** and x2** in terms of state variables
x1dd = (1/m1) * (k2 * x2) - (1/m1) * (k1 + k2) * x1
display(x1dd)


#subs()titute in values for things


# method 1: the numerical function will take variables one by one


# method 2: the numerical function will take variables cotained in one list/array
30/2:
#IMPORT ALL NECESSARY PACKAGES AT THE TOP OF THE CODE
import sympy as sym
import numpy as np
import matplotlib.pyplot as plt

from IPython.display import Markdown, display
30/3:
from IPython.core.display import HTML
display(HTML("<table><tr><td><img src='https://github.com/MuchenSun/ME314pngs/raw/master/2mass_spring.png' width=500' height='350'></table>"))
30/4:
# from sympy.abc import x, y, z or
x,y,z = sym.symbols(r'x,y,z')
expr = sym.sin(x) * y**2 * z + x*z + x/z**2
print('\033[1mExample expression: ')
display(expr)

# method 1: the numerical function will take variables one by one
func = sym.lambdify([x, y, z], expr)
print('\n\033[1mTest at x=1, y=2, z=3: \033[0m{:.2f}'.format(func(1, 2, 3)))

# method 2: the numerical function will take variables cotained in one list/array
func = sym.lambdify([[x, y, z]], expr)
print('\033[1mTest at x=1, y=2, z=3: \033[0m{:.2f}'.format(func([1, 2, 3])))
30/5:
# You can start your implementation here :)

#grab variables
# from sympy.abc import x, y, z or do sym.symbols
x1, x2 = sym.symbols(r'x1, x2') #state variables
k1, k2, m1, m2 = sym.symbols(r'k1, k2, m1, m2') # constants
x1dd = sym.Function(x1, x2) 
x2dd = sym.Function(x1, x2)

#write equations of x1** and x2** in terms of state variables
x1dd = (1/m1) * (k2 * x2) - (1/m1) * (k1 + k2) * x1
display(x1dd)


#subs()titute in values for things


# method 1: the numerical function will take variables one by one


# method 2: the numerical function will take variables cotained in one list/array
30/6:
# You can start your implementation here :)

#grab variables
# from sympy.abc import x, y, z or do sym.symbols
x1, x2 = sym.symbols(r'x1, x2') #state variables
k1, k2, m1, m2 = sym.symbols(r'k1, k2, m1, m2') # constants
x1dd = sym.Function((x1, x2)) 
x2dd = sym.Function((x1, x2))

#write equations of x1** and x2** in terms of state variables
x1dd = (1/m1) * (k2 * x2) - (1/m1) * (k1 + k2) * x1
display(x1dd)


#subs()titute in values for things


# method 1: the numerical function will take variables one by one


# method 2: the numerical function will take variables cotained in one list/array
30/7:
# You can start your implementation here :)

#grab variables
# from sympy.abc import x, y, z or do sym.symbols
x1, x2 = sym.symbols(r'x1, x2') #state variables
k1, k2, m1, m2 = sym.symbols(r'k1, k2, m1, m2') # constants
x1dd = sym.Function('x1') 
x2dd = sym.Function('x1')

#write equations of x1** and x2** in terms of state variables
x1dd = (1/m1) * (k2 * x2) - (1/m1) * (k1 + k2) * x1
display(x1dd)


#subs()titute in values for things


# method 1: the numerical function will take variables one by one


# method 2: the numerical function will take variables cotained in one list/array
30/8:
# You can start your implementation here :)

#grab variables
# from sympy.abc import x, y, z or do sym.symbols
x1, x2 = sym.symbols(r'x1, x2') #state variables
k1, k2, m1, m2 = sym.symbols(r'k1, k2, m1, m2') # constants
x1dd = sym.Function('x1') 
x2dd = sym.Function('x2')

#write equations of x1** and x2** in terms of state variables
x1dd = (1/m1) * (k2 * x2) - (1/m1) * (k1 + k2) * x1
x2dd = -(1/m2) * (x2 - x1)

display(x1dd)
display(x2dd)

#subs()titute in values for things


# method 1: the numerical function will take variables one by one


# method 2: the numerical function will take variables cotained in one list/array
30/9:
# You can start your implementation here :)

#1. grab variables
x1, x2 = sym.symbols(r'x1, x2') #state variables
k1, k2, m1, m2 = sym.symbols(r'k1, k2, m1, m2') # constants
x1dd = sym.Function('x1') 
x2dd = sym.Function('x2')

#2. write expressions of x1** and x2** in terms of state variables
x1dd = (1/m1) * (k2 * x2) - (1/m1) * (k1 + k2) * x1
x2dd = -(1/m2) * (x2 - x1)

display(x1dd)
display(x2dd)

#3. subs()titute in values for things
accel1 = x1dd.subs({
    k1: 0.5
    k2: 0.8
    m1: 1
    m2: 2
}) #all in SI units; N/m and kg


#4. lambdify and input values



# method 1: the numerical function will take variables one by one


# method 2: the numerical function will take variables cotained in one list/array
30/10:
# You can start your implementation here :)

#1. grab variables
x1, x2 = sym.symbols(r'x1, x2') #state variables
k1, k2, m1, m2 = sym.symbols(r'k1, k2, m1, m2') # constants
x1dd = sym.Function('x1') 
x2dd = sym.Function('x2')

#2. write expressions of x1** and x2** in terms of state variables
x1dd = (1/m1) * (k2 * x2) - (1/m1) * (k1 + k2) * x1
x2dd = -(1/m2) * (x2 - x1)

display(x1dd)
display(x2dd)

#3. subs()titute in values for things
accel1 = x1dd.subs({
    k1: 0.5,
    k2: 0.8,
    m1: 1,
    m2: 2
}) #all in SI units; N/m and kg


#4. lambdify and input values



# method 1: the numerical function will take variables one by one


# method 2: the numerical function will take variables cotained in one list/array
30/11:
# You can start your implementation here :)

#1. grab variables
x1, x2 = sym.symbols(r'x1, x2') #state variables
k1, k2, m1, m2 = sym.symbols(r'k1, k2, m1, m2') # constants
x1dd = sym.Function('x1') 
x2dd = sym.Function('x2')

#2. write expressions of x1** and x2** in terms of state variables
x1dd = (1/m1) * (k2 * x2) - (1/m1) * (k1 + k2) * x1
x2dd = -(1/m2) * (x2 - x1)

display(x1dd)
display(x2dd)

#3. subs()titute in values for things
accel1 = x1dd.subs({
    k1: 0.5,
    k2: 0.8,
    m1: 1,
    m2: 2
}) #all in SI units; N/m and kg

display(accel1)
#display(accel2)

#4. lambdify and input values



# method 1: the numerical function will take variables one by one


# method 2: the numerical function will take variables cotained in one list/array
30/12:
# You can start your implementation here :)

#1. grab variables
x1, x2 = sym.symbols(r'x1, x2') #state variables
k1, k2, m1, m2 = sym.symbols(r'k1, k2, m1, m2') # constants
x1dd = sym.Function('x1') 
x2dd = sym.Function('x2')

#2. write expressions of x1** and x2** in terms of state variables
x1dd = (1/m1) * (k2 * x2) - (1/m1) * (k1 + k2) * x1
x2dd = -(1/m2) * (x2 - x1)

display(x1dd)
display(x2dd)

#3. subs()titute in values for things
accel1 = x1dd.subs({
    k1: 0.5,
    k2: 0.8,
    m1: 1,
    m2: 2
}) #all in SI units; N/m and kg

accel2 = x2dd.subs({
    k1: 0.5,
    k2: 0.8,
    m1: 1,
    m2: 2
}) #all in SI units; N/m and kg

#4. lambdify and input values
npaccel1 = sym.lambdify(accel1)
npaccel2 = sym.lambdify(accel1)



# method 1: the numerical function will take variables one by one


# method 2: the numerical function will take variables cotained in one list/array
30/13:
# You can start your implementation here :)

#1. grab variables
x1, x2 = sym.symbols(r'x1, x2') #state variables
k1, k2, m1, m2 = sym.symbols(r'k1, k2, m1, m2') # constants
x1dd = sym.Function('x1') 
x2dd = sym.Function('x2')

#2. write expressions of x1** and x2** in terms of state variables
x1dd = (1/m1) * (k2 * x2) - (1/m1) * (k1 + k2) * x1
x2dd = -(1/m2) * (x2 - x1)

display(x1dd)
display(x2dd)

#3. subs()titute in values for things
accel1 = x1dd.subs({
    k1: 0.5,
    k2: 0.8,
    m1: 1,
    m2: 2
}) #all in SI units; N/m and kg

accel2 = x2dd.subs({
    k1: 0.5,
    k2: 0.8,
    m1: 1,
    m2: 2
}) #all in SI units; N/m and kg

#4. lambdify and input values
npaccel1 = sym.lambdify([x1, x2], accel1)
npaccel2 = sym.lambdify([x1, x2], accel1)



# method 1: the numerical function will take variables one by one


# method 2: the numerical function will take variables cotained in one list/array
30/14:
# You can start your implementation here :)

#1. grab variables
x1, x2 = sym.symbols(r'x1, x2') #state variables
k1, k2, m1, m2 = sym.symbols(r'k1, k2, m1, m2') # constants
x1dd = sym.Function('x1') 
x2dd = sym.Function('x2')

#2. write expressions of x1** and x2** in terms of state variables
x1dd = (1/m1) * (k2 * x2) - (1/m1) * (k1 + k2) * x1
x2dd = -(1/m2) * (x2 - x1)

display(x1dd)
display(x2dd)

#3. subs()titute in values for things
accel1 = x1dd.subs({
    k1: 0.5,
    k2: 0.8,
    m1: 1,
    m2: 2
}) #all in SI units; N/m and kg

accel2 = x2dd.subs({
    k1: 0.5,
    k2: 0.8,
    m1: 1,
    m2: 2
}) #all in SI units; N/m and kg

#4. lambdify functions and input values, method 1: take variables one by one

npaccel1 = sym.lambdify([x1, x2], accel1)
npaccel2 = sym.lambdify([x1, x2], accel1)

ans1 = npaccel1([1, 3])
ans2 = npaccel2([1, 3])

#check with hand calcs
assert(ans1 == -1.1, f"Accel 1: {ans1}")
assert(ans1 ==  2.0, f"Accel 2: {ans2}")
30/15:
# You can start your implementation here :)

#1. grab variables
x1, x2 = sym.symbols(r'x1, x2') #state variables
k1, k2, m1, m2 = sym.symbols(r'k1, k2, m1, m2') # constants
x1dd = sym.Function('x1') 
x2dd = sym.Function('x2')

#2. write expressions of x1** and x2** in terms of state variables
x1dd = (1/m1) * (k2 * x2) - (1/m1) * (k1 + k2) * x1
x2dd = -(1/m2) * (x2 - x1)

display(x1dd)
display(x2dd)

#3. subs()titute in values for things
accel1 = x1dd.subs({
    k1: 0.5,
    k2: 0.8,
    m1: 1,
    m2: 2
}) #all in SI units; N/m and kg

accel2 = x2dd.subs({
    k1: 0.5,
    k2: 0.8,
    m1: 1,
    m2: 2
}) #all in SI units; N/m and kg

#4. lambdify functions and input values, method 1: take variables one by one

npaccel1 = sym.lambdify([x1, x2], accel1)
npaccel2 = sym.lambdify([x1, x2], accel1)

ans1 = npaccel1(1, 3)
ans2 = npaccel2(1, 3)

#check NP answer with hand calcs
assert ans1 == -1.1, f"Accel 1: {ans1}" 
assert ans2 ==  2.0, f"Accel 2: {ans2}"
30/16:
# You can start your implementation here :)

#1. grab variables
x1, x2 = sym.symbols(r'x1, x2') #state variables
k1, k2, m1, m2 = sym.symbols(r'k1, k2, m1, m2') # constants
x1dd = sym.Function('x1') 
x2dd = sym.Function('x2')

#2. write expressions of x1** and x2** in terms of state variables
x1dd = (1/m1) * (k2 * x2) - (1/m1) * (k1 + k2) * x1
x2dd = -(1/m2) * (x2 - x1)

display(x1dd)
display(x2dd)

#3. subs()titute in values for things
accel1 = x1dd.subs({
    k1: 0.5,
    k2: 0.8,
    m1: 1,
    m2: 2
}) #all in SI units; N/m and kg

accel2 = x2dd.subs({
    k1: 0.5,
    k2: 0.8,
    m1: 1,
    m2: 2
}) #all in SI units; N/m and kg

#4. lambdify functions and input values, method 1: take variables one by one

npaccel1 = sym.lambdify([x1, x2], accel1)
npaccel2 = sym.lambdify([x1, x2], accel1)

ans1 = npaccel1(1, 3)
ans2 = npaccel2(1, 3)

#check NP answer with hand calcs
assert ans1 == 1.1, f"Accel 1: {ans1}" 
assert ans2 == 2.0, f"Accel 2: {ans2}"
30/17:
# You can start your implementation here :)

#1. grab variables
x1, x2 = sym.symbols(r'x1, x2') #state variables
k1, k2, m1, m2 = sym.symbols(r'k1, k2, m1, m2') # constants
x1dd = sym.Function('x1') 
x2dd = sym.Function('x2')

#2. write expressions of x1** and x2** in terms of state variables
x1dd = (1/m1) * (k2 * x2) - (1/m1) * (k1 + k2) * x1
x2dd = -(1/m2) * (x2 - x1)

display(x1dd)
display(x2dd)

#3. subs()titute in values for things
accel1 = x1dd.subs({
    k1: 0.5,
    k2: 0.8,
    m1: 1,
    m2: 2
}) #all in SI units; N/m and kg

accel2 = x2dd.subs({
    k1: 0.5,
    k2: 0.8,
    m1: 1,
    m2: 2
}) #all in SI units; N/m and kg

#4. lambdify functions and input values, method 1: take variables one by one

npaccel1 = sym.lambdify([x1, x2], accel1)
npaccel2 = sym.lambdify([x1, x2], accel1)

ans1 = npaccel1(1, 3)
ans2 = npaccel2(1, 3)

#check NP answer with hand calcs
assert np.isclose(ans1, 1.1), f"Accel 1: {ans1}" 
assert np.isclose(ans2, 2.0), f"Accel 2: {ans2}"
30/18:
# You can start your implementation here :)

#1. grab variables
x1, x2 = sym.symbols(r'x1, x2') #state variables
k1, k2, m1, m2 = sym.symbols(r'k1, k2, m1, m2') # constants
x1dd = sym.Function('x1') 
x2dd = sym.Function('x2')

#2. write expressions of x1** and x2** in terms of state variables
x1dd = (1/m1) * (k2 * x2) - (1/m1) * (k1 + k2) * x1
x2dd = -(1/m2) * (x2 - x1)

display(x1dd)
display(x2dd)

#3. subs()titute in values for things
accel1 = x1dd.subs({
    k1: 0.5,
    k2: 0.8,
    m1: 1,
    m2: 2
}) #all in SI units; N/m and kg

accel2 = x2dd.subs({
    k1: 0.5,
    k2: 0.8,
    m1: 1,
    m2: 2
}) #all in SI units; N/m and kg

#4. lambdify functions and input values, method 1: take variables one by one

npaccel1 = sym.lambdify([x1, x2], accel1)
npaccel2 = sym.lambdify([x1, x2], accel2)

ans1 = npaccel1(1, 3)
ans2 = npaccel2(1, 3)

#check NP answer with hand calcs
assert np.isclose(ans1, 1.1), f"Accel 1: {ans1}" 
assert np.isclose(ans2, 2.0), f"Accel 2: {ans2}"
30/19:
# You can start your implementation here :)

#1. grab variables
x1, x2 = sym.symbols(r'x1, x2') #state variables
k1, k2, m1, m2 = sym.symbols(r'k1, k2, m1, m2') # constants
x1dd = sym.Function('x1') 
x2dd = sym.Function('x2')

#2. write expressions of x1** and x2** in terms of state variables
x1dd = (1/m1) * (k2 * x2) - (1/m1) * (k1 + k2) * x1
x2dd = -(k2/m2) * (x2 - x1)

display(x1dd)
display(x2dd)

#3. subs()titute in values for things
accel1 = x1dd.subs({
    k1: 0.5,
    k2: 0.8,
    m1: 1,
    m2: 2
}) #all in SI units; N/m and kg

accel2 = x2dd.subs({
    k1: 0.5,
    k2: 0.8,
    m1: 1,
    m2: 2
}) #all in SI units; N/m and kg

#4. lambdify functions and input values, method 1: take variables one by one

npaccel1 = sym.lambdify([x1, x2], accel1)
npaccel2 = sym.lambdify([x1, x2], accel2)

ans1 = npaccel1(1, 3)
ans2 = npaccel2(1, 3)

#check NP answer with hand calcs
assert np.isclose(ans1, 1.1), f"Accel 1: {ans1}" 
assert np.isclose(ans2, 2.0), f"Accel 2: {ans2}"
30/20:
# You can start your implementation here :)

#1. grab variables
x1, x2 = sym.symbols(r'x1, x2') #state variables
k1, k2, m1, m2 = sym.symbols(r'k1, k2, m1, m2') # constants
x1dd = sym.Function('x1') 
x2dd = sym.Function('x2')

#2. write expressions of x1** and x2** in terms of state variables
x1dd = (1/m1) * (k2 * x2) - (1/m1) * (k1 + k2) * x1
x2dd = -(k2/m2) * (x2 - x1)

display(x1dd)
display(x2dd)

#3. subs()titute in values for things
accel1 = x1dd.subs({
    k1: 0.5,
    k2: 0.8,
    m1: 1,
    m2: 2
}) #all in SI units; N/m and kg

accel2 = x2dd.subs({
    k1: 0.5,
    k2: 0.8,
    m1: 1,
    m2: 2
}) #all in SI units; N/m and kg

#4. lambdify functions and input values, method 1: take variables one by one

npaccel1 = sym.lambdify([x1, x2], accel1)
npaccel2 = sym.lambdify([x1, x2], accel2)

ans1 = npaccel1(1, 3)
ans2 = npaccel2(1, 3)

#check NP answer with hand calcs
assert np.isclose(ans1, 1.1), f"Accel 1: {ans1}" 
assert np.isclose(ans2, -0.8), f"Accel 2: {ans2}"
30/21:
# You can start your implementation here :)

#1. grab variables
x1, x2 = sym.symbols(r'x1, x2') #state variables
k1, k2, m1, m2 = sym.symbols(r'k1, k2, m1, m2') # constants
x1dd = sym.Function('x1') 
x2dd = sym.Function('x2')

#2. write expressions of x1** and x2** in terms of state variables
x1dd = (1/m1) * (k2 * x2) - (1/m1) * (k1 + k2) * x1
x2dd = -(k2/m2) * (x2 - x1)

print("Acceleration for mass 1:")
display(x1dd)
print("Acceleration for mass 2:")
display(x2dd)

#3. subs()titute in values for things
accel1 = x1dd.subs({
    k1: 0.5,
    k2: 0.8,
    m1: 1,
    m2: 2
}) #all in SI units; N/m and kg

accel2 = x2dd.subs({
    k1: 0.5,
    k2: 0.8,
    m1: 1,
    m2: 2
}) #all in SI units; N/m and kg

#4. lambdify functions and input values, method 1: take variables one by one

npaccel1 = sym.lambdify([x1, x2], accel1)
npaccel2 = sym.lambdify([x1, x2], accel2)

ans1 = npaccel1(1, 3)
ans2 = npaccel2(1, 3)

#check NP answer with hand calcs
assert np.isclose(ans1, 1.1), f"Accel 1: {ans1}" 
assert np.isclose(ans2, -0.8), f"Accel 2: {ans2}"
30/22:
# You can start your implementation here :)

#1. grab variables/constants
t = sym.symbols(r't') #independent variable
k1, k2, m1, m2 = sym.symbols(r'k1, k2, m1, m2') #constants

#2. define two system states as functions
x1 = sym.Function('x1')(t)
x2 = sym.Function('x2')(t)

# wrap system states into one vector (in SymPy would be Matrix)
q = sym.Matrix([x1, x2])

# define an expression in terms of x1(t) and x2(t)



# compute derivative wrt a vector, method 1
# wrap the expression into a SymPy Matrix
# SymPy Matrix has built-in method for Jacobian
#note that dJdq is 1-by-2 vector, not 2-by-1 as q

# compute derivative wrt a vector, method 2: do it one by one
# transpose so dimension can match

# compute derivative wrt a vector, method 3: do it one by one ... but in a "fancy" way
30/23:
# You can start your implementation here :)

#1. grab variables
t = sym.symbols(r't') #independent variable
k1, k2, m1, m2 = sym.symbols(r'k1, k2, m1, m2') #constant

#2. define position, velocity, accel for masses 1 and 2 as functions
x1 = sym.Function('t')
x2 = sym.Function('t')

x1d = x1.diff('t')
x1dd = x1d.diff('t') #will need acceleration later
x2d = x2.diff('t')
x2dd = x2d.diff('t')

# now write down an expression in terms of position and velocity
KE1 = (m1/2.0) * (x1d)**2
KE2 = (m2/2.0) * (x2d)**2
KE_sys = KE1 + KE2

U1  = (k1/2.0) * (x1) **2
U2  = (k2/2.0) * (x2) **2
U_sys = U1 + U2

lagrangian = KE_sys - U_sys
display(lagrangian)



# you can take the derivative of this expression wrt to time t
# or you can take the derivative wrt the functions: x, xdot, xddot
30/24:
# You can start your implementation here :)

#1. grab variables
t = sym.symbols(r't') #independent variable
k1, k2, m1, m2 = sym.symbols(r'k1, k2, m1, m2') #constant

#2. define position, velocity, accel for masses 1 and 2 as functions
x1 = sym.Function('x1')(t)
x2 = sym.Function('x2')(t)

x1d = x1.diff('t')
x1dd = x1d.diff('t') #will need acceleration later
x2d = x2.diff('t')
x2dd = x2d.diff('t')

# now write down an expression in terms of position and velocity
KE1 = (m1/2.0) * (x1d)**2
KE2 = (m2/2.0) * (x2d)**2
KE_sys = KE1 + KE2

U1  = (k1/2.0) * (x1) **2
U2  = (k2/2.0) * (x2) **2
U_sys = U1 + U2

lagrangian = KE_sys - U_sys
display(lagrangian)



# you can take the derivative of this expression wrt to time t
# or you can take the derivative wrt the functions: x, xdot, xddot
30/25:
# You can start your implementation here :)

#1. grab variables
t = sym.symbols(r't') #independent variable
k1, k2, m1, m2 = sym.symbols(r'k1, k2, m1, m2') #constant

#2. define position, velocity, accel for masses 1 and 2 as functions
x1 = sym.Function('x1')(t)
x2 = sym.Function('x2')(t)

x1d = x1.diff('t')
x1dd = x1d.diff('t') #will need acceleration later
x2d = x2.diff('t')
x2dd = x2d.diff('t')

# now write down an expression in terms of position and velocity
KE1 = (m1/2.0) * (x1d)**2
KE2 = (m2/2.0) * (x2d)**2
KE_sys = KE1 + KE2

U1  = (k1/2.0) * (x1) **2
U2  = (k2/2.0) * (x2 - x1) **2
U_sys = U1 + U2

lagrangian = KE_sys - U_sys
display(lagrangian)



# you can take the derivative of this expression wrt to time t
# or you can take the derivative wrt the functions: x, xdot, xddot
30/26:
# You can start your implementation here :)

#1. grab variables
t = sym.symbols(r't') #independent variable
k1, k2, m1, m2 = sym.symbols(r'k1, k2, m1, m2') #constant

#2. define position, velocity, accel for masses 1 and 2 as functions
x1 = sym.Function('x1')(t)
x2 = sym.Function('x2')(t)

x1d = x1.diff('t')
x1dd = x1d.diff('t') #will need acceleration later
x2d = x2.diff('t')
x2dd = x2d.diff('t')

# now write down an expression in terms of position and velocity
KE1 = (m1/2.0) * (x1d)**2
KE2 = (m2/2.0) * (x2d)**2
KE_sys = KE1 + KE2

U1  = (k1/2.0) * (x1) **2
U2  = (k2/2.0) * (x2 - x1) **2
U_sys = U1 + U2

lagrangian = KE_sys - U_sys
print('Lagrangian function:')
display(lagrangian)



# you can take the derivative of this expression wrt to time t
# or you can take the derivative wrt the functions: x, xdot, xddot
30/27:
# You can start your implementation here :)

#equation setup continued from previous problem

#4.  wrap system states into one vector (in SymPy would be Matrix)
q = sym.Matrix([x1, x2])
qd = q.diff(t)
qdd = qd.diff(t)

#5. create function of interest in terms of state variables x1, x2
#   --> we have already done this, it's the Lagrangian equation in this case

#6. compute deriv(function) wrt. state variables vector
L_mat = sym.Matrix([L]) # wrap the expression into a SymPy Matrix
dL_dq = L_mat.jacobian(q) #jacobian = deriv of matrix wrt. state vector

print("dL/dQ term:")
display(dL/dq)

#7. repeat for second term in E-L equations, then construct equation
dL_dqdot = L_mat.jacobian(qd)
LHS = dL_dq - dL_dqdot.diff(t)
RHS = 0
eqn = sym.Eq(LHS, RHS)
30/28:
# You can start your implementation here :)

#equation setup continued from previous problem

#4.  wrap system states into one vector (in SymPy would be Matrix)
q = sym.Matrix([x1, x2])
qd = q.diff(t)
qdd = qd.diff(t)

#5. create function of interest in terms of state variables x1, x2
#   --> we have already done this, it's the Lagrangian equation in this case

#6. compute deriv(function) wrt. state variables vector
L_mat = sym.Matrix([lagrangian]) # wrap the expression into a SymPy Matrix
dL_dq = L_mat.jacobian(q) #jacobian = deriv of matrix wrt. state vector

print("dL/dQ term:")
display(dL/dq)

#7. repeat for second term in E-L equations, then construct equation
dL_dqdot = L_mat.jacobian(qd)
LHS = dL_dq - dL_dqdot.diff(t)
RHS = 0
eqn = sym.Eq(LHS, RHS)
30/29:
# You can start your implementation here :)

#equation setup continued from previous problem

#4.  wrap system states into one vector (in SymPy would be Matrix)
q = sym.Matrix([x1, x2])
qd = q.diff(t)
qdd = qd.diff(t)

#5. create function of interest in terms of state variables x1, x2
#   --> we have already done this, it's the Lagrangian equation in this case

#6. compute deriv(function) wrt. state variables vector
L_mat = sym.Matrix([lagrangian]) # wrap the expression into a SymPy Matrix
dL_dq = L_mat.jacobian(q) #jacobian = deriv of matrix wrt. state vector

print("dL/dQ term:")
display(dL_dq)

#7. repeat for second term in E-L equations, then construct equation
dL_dqdot = L_mat.jacobian(qd)
LHS = dL_dq - dL_dqdot.diff(t)
RHS = 0
eqn = sym.Eq(LHS, RHS)
30/30:
# You can start your implementation here :)

#equation setup continued from previous problem

#4.  wrap system states into one vector (in SymPy would be Matrix)
q = sym.Matrix([x1, x2])
qd = q.diff(t)
qdd = qd.diff(t)

#5. create function of interest in terms of state variables x1, x2
#   --> we have already done this, it's the Lagrangian equation in this case

#6. compute deriv(function) wrt. state variables vector
L_mat = sym.Matrix([lagrangian]) # wrap the expression into a SymPy Matrix
dL_dq = L_mat.jacobian(q) #jacobian = deriv of matrix wrt. state vector

print("dL/dQ term:")
display(dL_dq)

#7. repeat for second term in E-L equations, then construct equation
dL_dqdot = L_mat.jacobian(qd)
LHS = dL_dq - dL_dqdot.diff(t)
RHS = 0
eqn = sym.Eq(LHS, RHS)

print("dL/dQdot term:")
display(dL_dqdot)
print("Lagrangian equations:")
display(eqn)
30/31:
# You can start your implementation here :)

#equation setup continued from previous problem

#4.  wrap system states into one vector (in SymPy would be Matrix)
q = sym.Matrix([x1, x2])
qd = q.diff(t)
qdd = qd.diff(t)

#5. create function of interest in terms of state variables x1, x2
#   --> we have already done this, it's the Lagrangian equation in this case

#6. compute deriv(function) wrt. state variables vector
L_mat = sym.Matrix([lagrangian]) # wrap the expression into a SymPy Matrix
dL_dq = L_mat.jacobian(q) #jacobian = deriv of matrix wrt. state vector

print("dL/dQ term:")
display(dL_dq)

#7. repeat for second term in E-L equations, then construct equation
dL_dqdot = L_mat.jacobian(qd)
LHS = dL_dq - dL_dqdot.diff(t)
RHS = 0
eqn = sym.Eq(LHS, RHS)

print("dL/dQdot term:")
display(dL_dqdot)
print("Lagrangian equations:")
display(LHS)
30/32:
# You can start your implementation here :)

#equation setup continued from previous problem

#4.  wrap system states into one vector (in SymPy would be Matrix)
q = sym.Matrix([x1, x2])
qd = q.diff(t)
qdd = qd.diff(t)

#5. create function of interest in terms of state variables x1, x2
#   --> we have already done this, it's the Lagrangian equation in this case

#6. compute deriv(function) wrt. state variables vector
L_mat = sym.Matrix([lagrangian]) # wrap the expression into a SymPy Matrix
dL_dq = L_mat.jacobian(q) #jacobian = deriv of matrix wrt. state vector

print("dL/dQ term:")
display(dL_dq)

#7. repeat for second term in E-L equations, then construct equation
dL_dqdot = L_mat.jacobian(qd)
LHS = dL_dq - dL_dqdot.diff(t)
RHS = 0
eqn = sym.Eq(LHS, RHS)

print("dL/dQdot term:")
display(dL_dqdot)
print("d_dt(dL/dQdot):")
display(LHS)
30/33:
# You can start your implementation here :)

#equation setup continued from previous problem

#4.  wrap system states into one vector (in SymPy would be Matrix)
q = sym.Matrix([x1, x2])
qd = q.diff(t)
qdd = qd.diff(t)

#5. create function of interest in terms of state variables x1, x2
#   --> we have already done this, it's the Lagrangian equation in this case

#6. compute deriv(function) wrt. state variables vector
L_mat = sym.Matrix([lagrangian]) # wrap the expression into a SymPy Matrix
dL_dq = L_mat.jacobian(q) #jacobian = deriv of matrix wrt. state vector

print("dL/dQ term:")
display(dL_dq)

#7. repeat for second term in E-L equations, then construct equation
dL_dqdot = L_mat.jacobian(qd)
LHS = dL_dq - dL_dqdot.diff(t)
RHS = 0
eqn = sym.Eq(LHS, RHS)

print("dL/dQdot term:")
display(dL_dqdot)
print("d_dt(dL/dQdot):")
display(dL_dqdot.diff(t))
30/34:
# You can start your implementation here :)

#equation setup continued from previous problem

#4.  wrap system states into one vector (in SymPy would be Matrix)
q = sym.Matrix([x1, x2])
qd = q.diff(t)
qdd = qd.diff(t)

#5. create function of interest in terms of state variables x1, x2
#   --> we have already done this, it's the Lagrangian equation in this case

#6. compute deriv(function) wrt. state variables vector
L_mat = sym.Matrix([lagrangian]) # wrap the expression into a SymPy Matrix
dL_dq = L_mat.jacobian(q) #jacobian = deriv of matrix wrt. state vector

print("dL/dQ term:")
display(dL_dq)

#7. repeat for second term in E-L equations, then construct equation
dL_dqdot = L_mat.jacobian(qd)
LHS = dL_dq - dL_dqdot.diff(t)
RHS = 0
eqn = sym.Eq(LHS, RHS)

print("dL/dQdot term:")
display(dL_dqdot)
print("LHS:")
display(LHS)
30/35:
# You can start your implementation here :)

#equation setup continued from previous problem

#4.  wrap system states into one vector (in SymPy would be Matrix)
q = sym.Matrix([x1, x2])
qd = q.diff(t)
qdd = qd.diff(t)

#5. create function of interest in terms of state variables x1, x2
#   --> we have already done this, it's the Lagrangian equation in this case

#6. compute deriv(function) wrt. state variables vector
L_mat = sym.Matrix([lagrangian]) # wrap the expression into a SymPy Matrix
dL_dq = L_mat.jacobian(q) #jacobian = deriv of matrix wrt. state vector

print("dL/dQ term:")
display(dL_dq)

#7. repeat for second term in E-L equations, then construct equation
dL_dqdot = L_mat.jacobian(qd)
LHS = dL_dq - dL_dqdot.diff(t)
RHS = Matrix([0,0])
eqn = sym.Eq(LHS, RHS)

print("dL/dQdot term:")
display(dL_dqdot)
print("LHS of equation:")
display(LHS)
print("RHS of equation:")
display(RHS)
30/36:
# You can start your implementation here :)

#equation setup continued from previous problem

#4.  wrap system states into one vector (in SymPy would be Matrix)
q = sym.Matrix([x1, x2])
qd = q.diff(t)
qdd = qd.diff(t)

#5. create function of interest in terms of state variables x1, x2
#   --> we have already done this, it's the Lagrangian equation in this case

#6. compute deriv(function) wrt. state variables vector
L_mat = sym.Matrix([lagrangian]) # wrap the expression into a SymPy Matrix
dL_dq = L_mat.jacobian(q) #jacobian = deriv of matrix wrt. state vector

print("dL/dQ term:")
display(dL_dq)

#7. repeat for second term in E-L equations, then construct equation
dL_dqdot = L_mat.jacobian(qd)
LHS = dL_dq - dL_dqdot.diff(t)
RHS = sym.Matrix([0,0])
eqn = sym.Eq(LHS, RHS)

print("dL/dQdot term:")
display(dL_dqdot)
print("LHS of equation:")
display(LHS)
print("RHS of equation:")
display(RHS)
30/37:
# You can start your implementation here :)

#equation setup continued from previous problem

#4.  wrap system states into one vector (in SymPy would be Matrix)
q = sym.Matrix([x1, x2])
qd = q.diff(t)
qdd = qd.diff(t)

#5. create function of interest in terms of state variables x1, x2
#   --> we have already done this, it's the Lagrangian equation in this case

#6. compute deriv(function) wrt. state variables vector
L_mat = sym.Matrix([lagrangian]) # wrap the expression into a SymPy Matrix
dL_dq = L_mat.jacobian(q) #jacobian = deriv of matrix wrt. state vector

print("dL/dQ term:")
display(dL_dq)

#7. repeat for second term in E-L equations, then construct equation
dL_dqdot = L_mat.jacobian(qd)
LHS = dL_dq - dL_dqdot.diff(t)
RHS = sym.Matrix([0,0]).T
eqn = sym.Eq(LHS, RHS)

print("dL/dQdot term:")
display(dL_dqdot)
print("LHS of equation:")
display(LHS)
print("RHS of equation:")
display(RHS)
30/38:
# You can start your implementation here :)

#equation setup continued from previous problem

#4.  wrap system states into one vector (in SymPy would be Matrix)
q = sym.Matrix([x1, x2])
qd = q.diff(t)
qdd = qd.diff(t)

#5. create function of interest in terms of state variables x1, x2
#   --> we have already done this, it's the Lagrangian equation in this case

#6. compute deriv(function) wrt. state variables vector
L_mat = sym.Matrix([lagrangian]) # wrap the expression into a SymPy Matrix
dL_dq = L_mat.jacobian(q) #jacobian = deriv of matrix wrt. state vector

print("dL/dQ term:")
display(dL_dq)

#7. repeat for second term in E-L equations, then construct equation
dL_dqdot = L_mat.jacobian(qd)
LHS = dL_dq - dL_dqdot.diff(t)
RHS = sym.Matrix([0,0]).T
eqn = sym.Eq(LHS, RHS)

print("dL/dQdot term:")
display(dL_dqdot)
print("LHS of equation:")
display(LHS)
print("RHS of equation:")
display(RHS)
print('Equation:')
display(eqn)
30/39:
# You can start your implementation here :)

# 8. solve equation and display result
soln = sym.solve(eqn, q, dict = True)

for x in q:
    display(sym.Eq(q, soln[q]))
30/40:
# You can start your implementation here :)

# 8. solve equation and display result
soln = sym.solve(eqn, q, dict = True)

for x in q:
    display(sym.Eq(q, soln[x]))
30/41:
# You can start your implementation here :)

# 8. solve equation and display result
soln = sym.solve(eqn, q, dict = True)

print(soln)

for x in q:
    display(sym.Eq(q, soln[x]))
30/42:
# You can start your implementation here :)

# 8. solve equation and display result
soln = sym.solve(eqn, q, dict = True)

display(soln)

for x in q:
    display(sym.Eq(q, soln[x]))
30/43:
# You can start your implementation here :)

# 8. solve equation and display result
soln = sym.solve(eqn, q, dict = True)

display(soln)

for x in q:
    display(sym.Eq(q, soln[x]))
30/44:
# You can start your implementation here :)

#equation setup continued from previous problem

#4.  wrap system states into one vector (in SymPy would be Matrix)
q = sym.Matrix([x1, x2])
qd = q.diff(t)
qdd = qd.diff(t)

#5. create function of interest in terms of state variables x1, x2
#   --> we have already done this, it's the Lagrangian equation in this case

#6. compute deriv(function) wrt. state variables vector
L_mat = sym.Matrix([lagrangian]) # wrap the expression into a SymPy Matrix
dL_dq = L_mat.jacobian(q) #jacobian = deriv of matrix wrt. state vector

print("dL/dQ term:")
display(dL_dq)

#7. repeat for second term in E-L equations, then construct equation elements
dL_dqdot = L_mat.jacobian(qd)
LHS = dL_dq - dL_dqdot.diff(t)
RHS = sym.Matrix([0,0]).T

print("dL/dQdot term:")
display(dL_dqdot)
print("LHS of equation:")
display(LHS)
print("RHS of equation:")
display(RHS)
30/45:
# You can start your implementation here :)



# 8. solve equation and display result
LHS = LHS.T
RHS = RHS.T
eqn = sym.Eq(LHS, RHS)
soln = sym.solve(eqn, q, dict = True)

display(soln)

for x in q:
    display(sym.Eq(q, soln[x]))
30/46:
# You can start your implementation here :)

# 8. solve equation and display result
LHS = LHS.T
RHS = RHS.T
eqn = sym.Eq(LHS, RHS)
soln = sym.solve(eqn, q, dict = True)

print(soln)

for x in q:
    display(sym.Eq(q, soln[x]))
30/47:
# You can start your implementation here :)

# 8. solve equation and display result
LHS = LHS.T
RHS = RHS.T
eqn = sym.Eq(LHS, RHS)
soln = sym.solve(eqn, q, dict = True)

print(soln)

for x in q[0]:
    display(sym.Eq(q, soln[x]))
30/48:
# You can start your implementation here :)

# 8. solve equation and display result
LHS = LHS.T
RHS = RHS.T
eqn = sym.Eq(LHS, RHS)
soln = sym.solve(eqn, q, dict = True)

print(soln)

for x in q:
    display(sym.Eq(q, soln[0][x]))
30/49:
# You can start your implementation here :)

# 8. solve equation and display result
LHS = LHS.T
RHS = RHS.T
eqn = sym.Eq(LHS, RHS)
soln = sym.solve(eqn, q, dict = True)

print(soln)

for x in q:
    display(sym.Eq(q, soln[0][x]))
30/50:
# You can start your implementation here :)

# 8. solve equation and display result
LHS = LHS.T
RHS = RHS.T
eqn = sym.Eq(LHS, RHS)

print("Equation:")
display(eqn)

soln = sym.solve(eqn, q, dict = True)

print(soln)

for x in q:
    display(sym.Eq(q, soln[0][x]))
30/51:
# You can start your implementation here :)

# 8. solve equation and display result
# LHS = LHS.T
# RHS = RHS.T
eqn = sym.Eq(LHS.T, RHS.T)

print("Equation:")
display(eqn)

soln = sym.solve(eqn, q, dict = True)

print(soln)

for x in q:
    display(sym.Eq(q, soln[0][x]))
33/1:
#IMPORT ALL NECESSARY PACKAGES AT THE TOP OF THE CODE
import sympy as sym
import numpy as np
import matplotlib.pyplot as plt

from IPython.display import Markdown, display
33/2:
# for google colab only

# def custom_latex_printer(exp,**options):
#     from google.colab.output._publish import javascript
#     url = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.1.1/latest.js?config=TeX-AMS_HTML"
#     javascript(url=url)
#     return sym.printing.latex(exp,**options)
# sym.init_printing(use_latex="mathjax",latex_printer=custom_latex_printer)
33/3:
from IPython.core.display import HTML
display(HTML("<table><tr><td><img src='https://github.com/MuchenSun/ME314pngs/raw/master/2mass_spring.png' width=500' height='350'></table>"))
33/4:
# from sympy.abc import x, y, z or
x,y,z = sym.symbols(r'x,y,z')
expr = sym.sin(x) * y**2 * z + x*z + x/z**2
print('\033[1mExample expression: ')
display(expr)

# method 1: the numerical function will take variables one by one
func = sym.lambdify([x, y, z], expr)
print('\n\033[1mTest at x=1, y=2, z=3: \033[0m{:.2f}'.format(func(1, 2, 3)))

# method 2: the numerical function will take variables cotained in one list/array
func = sym.lambdify([[x, y, z]], expr)
print('\033[1mTest at x=1, y=2, z=3: \033[0m{:.2f}'.format(func([1, 2, 3])))
33/5:
# You can start your implementation here :)

#1. grab variables
x1, x2 = sym.symbols(r'x1, x2') #state variables
k1, k2, m1, m2 = sym.symbols(r'k1, k2, m1, m2') # constants
x1dd = sym.Function('x1') 
x2dd = sym.Function('x2')

#2. write expressions of x1** and x2** in terms of state variables
x1dd = (1/m1) * (k2 * x2) - (1/m1) * (k1 + k2) * x1
x2dd = -(k2/m2) * (x2 - x1)

print("Acceleration for mass 1:")
display(x1dd)
print("Acceleration for mass 2:")
display(x2dd)

#3. subs()titute in values for things
accel1 = x1dd.subs({
    k1: 0.5,
    k2: 0.8,
    m1: 1,
    m2: 2
}) #all in SI units; N/m and kg

accel2 = x2dd.subs({
    k1: 0.5,
    k2: 0.8,
    m1: 1,
    m2: 2
}) #all in SI units; N/m and kg

#4. lambdify functions and input values, method 1: take variables one by one

npaccel1 = sym.lambdify([x1, x2], accel1)
npaccel2 = sym.lambdify([x1, x2], accel2)

ans1 = npaccel1(1, 3)
ans2 = npaccel2(1, 3)

#check NP answer with hand calcs
assert np.isclose(ans1, 1.1), f"Accel 1: {ans1}" 
assert np.isclose(ans2, -0.8), f"Accel 2: {ans2}"
33/6:
t = sym.symbols('t')
# define position as function of t
x1 = sym.Function(r'x_1')(t)
# define velocity as derivative of position wrt t
x1dot = x1.diff(t)
# define acceleration as derivative of velocity wrt t
x1ddot = x1dot.diff(t)

# now write down an expression in terms of position and velocity
expr = x1**2 + x1*x1dot
print('\033[1mExample expression: ')
display(expr)
# you can take the derivative of this expression wrt to time t
expr_dt = expr.diff(t)
print('\n\033[1mDerivative of expression w.r.t. time (t): ')
display(expr_dt)
# or you can take the derivative wrt the functions: x, xdot, xddot
expr_dx = expr.diff(x1)
print('\n\033[1mDerivative of expression w.r.t. x1(t): ')
display(expr_dx)
33/7:
# You can start your implementation here :)

#1. grab variables
t = sym.symbols(r't') #independent variable
k1, k2, m1, m2 = sym.symbols(r'k1, k2, m1, m2') #constant

#2. define position, velocity, accel for masses 1 and 2 as functions
x1 = sym.Function(r'x1')(t)
x2 = sym.Function(r'x2')(t)

x1d = x1.diff('t')
x1dd = x1d.diff('t') #will need acceleration later
x2d = x2.diff('t')
x2dd = x2d.diff('t')

#3.  now write down an expression in terms of position and velocity
KE1 = (m1/2.0) * (x1d)**2
KE2 = (m2/2.0) * (x2d)**2
KE_sys = KE1 + KE2

U1  = (k1/2.0) * (x1) **2
U2  = (k2/2.0) * (x2 - x1) **2
U_sys = U1 + U2

lagrangian = KE_sys - U_sys
print('Lagrangian function:')
display(lagrangian)
33/8:
print('\033[1mDifferent ways of taking the derivative of the Lagrangian with respect ot the system state vector (q)')
t = sym.symbols('t')

# define two system states as functions
x1 = sym.Function(r'x_1')(t)
x2 = sym.Function(r'x_2')(t)
# wrap system states into one vector (in SymPy would be Matrix)
q = sym.Matrix([x1, x2])
# define an expression in terms of x1(t) and x2(t)
J = sym.sin(x1**2) + sym.cos(x2)**2
print('\n\033[1mExample expression ')
display(J)

# compute derivative wrt a vector, method 1
# wrap the expression into a SymPy Matrix
J_mat = sym.Matrix([J])
# SymPy Matrix has built-in method for Jacobian
dJdq = J_mat.jacobian(q)
print('\n\033[1mMethod: built-in Jacobian derivative')
display(dJdq) # note that dJdq is 1-by-2 vector, not 2-by-1 as q

# compute derivative wrt a vector, method 2: do it one by one
dJdx1 = J.diff(x1)
dJdx2 = J.diff(x2)
dJdq = sym.Matrix([dJdx1, dJdx2]).T # transpose so dimension can match
print('\n\033[1mMethod: one-by-one')
display(dJdq)

# compute derivative wrt a vector, method 3: do it one by one ... but in a "fancy" way
dJdq = []
for x in q:
    dJdq.append(J.diff(x))
dJdq = sym.Matrix([dJdq])
print('\n\033[1mMethod: for loop')
display(dJdq)
33/9:
# You can start your implementation here :)

#equation setup continued from previous problem

#4.  wrap system states into one vector (in SymPy would be Matrix)
q = sym.Matrix([x1, x2])
qd = q.diff(t)
qdd = qd.diff(t)

#5. create function of interest in terms of state variables x1, x2
#   --> we have already done this, it's the Lagrangian equation in this case

#6. compute deriv(function) wrt. state variables vector
L_mat = sym.Matrix([lagrangian]) # wrap the expression into a SymPy Matrix
dL_dq = L_mat.jacobian(q) #jacobian = deriv of matrix wrt. state vector

print("dL/dQ term:")
display(dL_dq)

#7. repeat for second term in E-L equations, then construct equation elements
dL_dqdot = L_mat.jacobian(qd)
LHS = dL_dq - dL_dqdot.diff(t)
RHS = sym.Matrix([0,0]).T

print("dL/dQdot term:")
display(dL_dqdot)
print("LHS of equation:")
display(LHS)
print("RHS of equation:")
display(RHS)
33/10:
x,y = sym.symbols(r'x,y')
# define left hand side as a matrix
lhs = sym.Matrix([x**2+y, x+y])

# define right hand side as a Matrix
rhs = sym.Matrix([3, 1])

# define the equations
eqn = sym.Eq(lhs, rhs)

# solve it for both x and y
q = sym.Matrix([x, y])
soln = sym.solve(eqn, q, dict=True) # this will return the solution 
                                     # as a Python dictionary
for sol in soln:
    print('\n\033[1mSolution: ')
    for v in q:
        display(sym.Eq(v, sol[v]))
33/11:
# You can start your implementation here :)

# 8. solve equation and display result
# LHS = LHS.T
# RHS = RHS.T
eqn = sym.Eq(LHS.T, RHS.T)

print("Equation:")
display(eqn)

soln = sym.solve(eqn, q, dict = True)

print(soln)

for x in q:
    display(sym.Eq(q, soln[0][x]))
    
#hm. ask for help regarding why code isn't behaving
34/1:
#IMPORT ALL NECESSARY PACKAGES AT THE TOP OF THE CODE
import sympy as sym
import numpy as np
import matplotlib.pyplot as plt

from IPython.display import Markdown, display
34/2:
# for google colab only

# def custom_latex_printer(exp,**options):
#     from google.colab.output._publish import javascript
#     url = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.1.1/latest.js?config=TeX-AMS_HTML"
#     javascript(url=url)
#     return sym.printing.latex(exp,**options)
# sym.init_printing(use_latex="mathjax",latex_printer=custom_latex_printer)
34/3:
from IPython.core.display import HTML
display(HTML("<table><tr><td><img src='https://github.com/MuchenSun/ME314pngs/raw/master/2mass_spring.png' width=500' height='350'></table>"))
34/4:
# from sympy.abc import x, y, z or
x,y,z = sym.symbols(r'x,y,z')
expr = sym.sin(x) * y**2 * z + x*z + x/z**2
print('\033[1mExample expression: ')
display(expr)

# method 1: the numerical function will take variables one by one
func = sym.lambdify([x, y, z], expr)
print('\n\033[1mTest at x=1, y=2, z=3: \033[0m{:.2f}'.format(func(1, 2, 3)))

# method 2: the numerical function will take variables cotained in one list/array
func = sym.lambdify([[x, y, z]], expr)
print('\033[1mTest at x=1, y=2, z=3: \033[0m{:.2f}'.format(func([1, 2, 3])))
34/5:
# You can start your implementation here :)

#1. grab variables
x1, x2 = sym.symbols(r'x1, x2') #state variables
k1, k2, m1, m2 = sym.symbols(r'k1, k2, m1, m2') # constants
x1dd = sym.Function('x1') 
x2dd = sym.Function('x2')

#2. write expressions of x1** and x2** in terms of state variables
x1dd = (1/m1) * (k2 * x2) - (1/m1) * (k1 + k2) * x1
x2dd = -(k2/m2) * (x2 - x1)

print("Acceleration for mass 1:")
display(x1dd)
print("Acceleration for mass 2:")
display(x2dd)

#3. subs()titute in values for things
accel1 = x1dd.subs({
    k1: 0.5,
    k2: 0.8,
    m1: 1,
    m2: 2
}) #all in SI units; N/m and kg

accel2 = x2dd.subs({
    k1: 0.5,
    k2: 0.8,
    m1: 1,
    m2: 2
}) #all in SI units; N/m and kg

#4. lambdify functions and input values, method 1: take variables one by one

npaccel1 = sym.lambdify([x1, x2], accel1)
npaccel2 = sym.lambdify([x1, x2], accel2)

ans1 = npaccel1(1, 3)
ans2 = npaccel2(1, 3)

#check NP answer with hand calcs
assert np.isclose(ans1, 1.1), f"Accel 1: {ans1}" 
assert np.isclose(ans2, -0.8), f"Accel 2: {ans2}"
34/6:
t = sym.symbols('t')
# define position as function of t
x1 = sym.Function(r'x_1')(t)
# define velocity as derivative of position wrt t
x1dot = x1.diff(t)
# define acceleration as derivative of velocity wrt t
x1ddot = x1dot.diff(t)

# now write down an expression in terms of position and velocity
expr = x1**2 + x1*x1dot
print('\033[1mExample expression: ')
display(expr)
# you can take the derivative of this expression wrt to time t
expr_dt = expr.diff(t)
print('\n\033[1mDerivative of expression w.r.t. time (t): ')
display(expr_dt)
# or you can take the derivative wrt the functions: x, xdot, xddot
expr_dx = expr.diff(x1)
print('\n\033[1mDerivative of expression w.r.t. x1(t): ')
display(expr_dx)
34/7:
# You can start your implementation here :)

#1. grab variables
t = sym.symbols(r't') #independent variable
k1, k2, m1, m2 = sym.symbols(r'k1, k2, m1, m2') #constant

#2. define position, velocity, accel for masses 1 and 2 as functions
x1 = sym.Function(r'x1')(t)
x2 = sym.Function(r'x2')(t)

x1d = x1.diff('t')
x1dd = x1d.diff('t') #will need acceleration later
x2d = x2.diff('t')
x2dd = x2d.diff('t')

#3.  now write down an expression in terms of position and velocity
KE1 = (m1/2.0) * (x1d)**2
KE2 = (m2/2.0) * (x2d)**2
KE_sys = KE1 + KE2

U1  = (k1/2.0) * (x1) **2
U2  = (k2/2.0) * (x2 - x1) **2
U_sys = U1 + U2

lagrangian = KE_sys - U_sys
print('Lagrangian function:')
display(lagrangian)
34/8:
print('\033[1mDifferent ways of taking the derivative of the Lagrangian with respect ot the system state vector (q)')
t = sym.symbols('t')

# define two system states as functions
x1 = sym.Function(r'x_1')(t)
x2 = sym.Function(r'x_2')(t)
# # wrap system states into one vector (in SymPy would be Matrix)
# q = sym.Matrix([x1, x2])
# # define an expression in terms of x1(t) and x2(t)
# J = sym.sin(x1**2) + sym.cos(x2)**2
# print('\n\033[1mExample expression ')
# display(J)

# # compute derivative wrt a vector, method 1
# # wrap the expression into a SymPy Matrix
# J_mat = sym.Matrix([J])
# # SymPy Matrix has built-in method for Jacobian
# dJdq = J_mat.jacobian(q)
# print('\n\033[1mMethod: built-in Jacobian derivative')
# display(dJdq) # note that dJdq is 1-by-2 vector, not 2-by-1 as q

# # compute derivative wrt a vector, method 2: do it one by one
# dJdx1 = J.diff(x1)
# dJdx2 = J.diff(x2)
# dJdq = sym.Matrix([dJdx1, dJdx2]).T # transpose so dimension can match
# print('\n\033[1mMethod: one-by-one')
# display(dJdq)

# # compute derivative wrt a vector, method 3: do it one by one ... but in a "fancy" way
# dJdq = []
# for x in q:
#     dJdq.append(J.diff(x))
# dJdq = sym.Matrix([dJdq])
# print('\n\033[1mMethod: for loop')
# display(dJdq)
34/9:
# You can start your implementation here :)

#equation setup continued from previous problem

#4.  wrap system states into one vector (in SymPy would be Matrix)
q = sym.Matrix([x1, x2])
qd = q.diff(t)
qdd = qd.diff(t)

#5. create function of interest in terms of state variables x1, x2
#   --> we have already done this, it's the Lagrangian equation in this case

#6. compute deriv(function) wrt. state variables vector
L_mat = sym.Matrix([lagrangian]) # wrap the expression into a SymPy Matrix
dL_dq = L_mat.jacobian(q) #jacobian = deriv of matrix wrt. state vector

print("dL/dQ term:")
display(dL_dq)

#7. repeat for second term in E-L equations, then construct equation elements
dL_dqdot = L_mat.jacobian(qd)
LHS = dL_dq - dL_dqdot.diff(t)
RHS = sym.Matrix([0,0]).T

print("dL/dQdot term:")
display(dL_dqdot)
print("LHS of equation:")
display(LHS)
print("RHS of equation:")
display(RHS)
34/10:
x,y = sym.symbols(r'x,y')
# define left hand side as a matrix
lhs = sym.Matrix([x**2+y, x+y])

# define right hand side as a Matrix
rhs = sym.Matrix([3, 1])

# define the equations
eqn = sym.Eq(lhs, rhs)

# solve it for both x and y
q = sym.Matrix([x, y])
soln = sym.solve(eqn, q, dict=True) # this will return the solution 
                                     # as a Python dictionary
for sol in soln:
    print('\n\033[1mSolution: ')
    for v in q:
        display(sym.Eq(v, sol[v]))
34/11:
# You can start your implementation here :)

# 8. solve equation and display result
# LHS = LHS.T
# RHS = RHS.T
eqn = sym.Eq(LHS.T, RHS.T)

print("Equation:")
display(eqn)

soln = sym.solve(eqn, q, dict = True)

print(soln)

for x in q:
    display(sym.Eq(q, soln[0][x]))
    
#hm. ask for help regarding why code isn't behaving
35/1:
#IMPORT ALL NECESSARY PACKAGES AT THE TOP OF THE CODE
import sympy as sym
import numpy as np
import matplotlib.pyplot as plt

from IPython.display import Markdown, display
35/2:
# for google colab only

# def custom_latex_printer(exp,**options):
#     from google.colab.output._publish import javascript
#     url = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.1.1/latest.js?config=TeX-AMS_HTML"
#     javascript(url=url)
#     return sym.printing.latex(exp,**options)
# sym.init_printing(use_latex="mathjax",latex_printer=custom_latex_printer)
35/3:
from IPython.core.display import HTML
display(HTML("<table><tr><td><img src='https://github.com/MuchenSun/ME314pngs/raw/master/2mass_spring.png' width=500' height='350'></table>"))
35/4:
# # from sympy.abc import x, y, z or
# x,y,z = sym.symbols(r'x,y,z')
# expr = sym.sin(x) * y**2 * z + x*z + x/z**2
# print('\033[1mExample expression: ')
# display(expr)

# # method 1: the numerical function will take variables one by one
# func = sym.lambdify([x, y, z], expr)
# print('\n\033[1mTest at x=1, y=2, z=3: \033[0m{:.2f}'.format(func(1, 2, 3)))

# # method 2: the numerical function will take variables cotained in one list/array
# func = sym.lambdify([[x, y, z]], expr)
# print('\033[1mTest at x=1, y=2, z=3: \033[0m{:.2f}'.format(func([1, 2, 3])))
35/5:
# You can start your implementation here :)

#1. grab variables
x1, x2 = sym.symbols(r'x1, x2') #state variables
k1, k2, m1, m2 = sym.symbols(r'k1, k2, m1, m2') # constants
x1dd = sym.Function('x1') 
x2dd = sym.Function('x2')

#2. write expressions of x1** and x2** in terms of state variables
x1dd = (1/m1) * (k2 * x2) - (1/m1) * (k1 + k2) * x1
x2dd = -(k2/m2) * (x2 - x1)

print("Acceleration for mass 1:")
display(x1dd)
print("Acceleration for mass 2:")
display(x2dd)

#3. subs()titute in values for things
accel1 = x1dd.subs({
    k1: 0.5,
    k2: 0.8,
    m1: 1,
    m2: 2
}) #all in SI units; N/m and kg

accel2 = x2dd.subs({
    k1: 0.5,
    k2: 0.8,
    m1: 1,
    m2: 2
}) #all in SI units; N/m and kg

#4. lambdify functions and input values, method 1: take variables one by one

npaccel1 = sym.lambdify([x1, x2], accel1)
npaccel2 = sym.lambdify([x1, x2], accel2)

ans1 = npaccel1(1, 3)
ans2 = npaccel2(1, 3)

#check NP answer with hand calcs
assert np.isclose(ans1, 1.1), f"Accel 1: {ans1}" 
assert np.isclose(ans2, -0.8), f"Accel 2: {ans2}"
35/6:
# t = sym.symbols('t')
# # define position as function of t
# x1 = sym.Function(r'x_1')(t)
# # define velocity as derivative of position wrt t
# x1dot = x1.diff(t)
# # define acceleration as derivative of velocity wrt t
# x1ddot = x1dot.diff(t)

# # now write down an expression in terms of position and velocity
# expr = x1**2 + x1*x1dot
# print('\033[1mExample expression: ')
# display(expr)
# # you can take the derivative of this expression wrt to time t
# expr_dt = expr.diff(t)
# print('\n\033[1mDerivative of expression w.r.t. time (t): ')
# display(expr_dt)
# # or you can take the derivative wrt the functions: x, xdot, xddot
# expr_dx = expr.diff(x1)
# print('\n\033[1mDerivative of expression w.r.t. x1(t): ')
# display(expr_dx)
35/7:
# You can start your implementation here :)

#1. grab variables
t = sym.symbols(r't') #independent variable
k1, k2, m1, m2 = sym.symbols(r'k1, k2, m1, m2') #constant

#2. define position, velocity, accel for masses 1 and 2 as functions
x1 = sym.Function(r'x1')(t)
x2 = sym.Function(r'x2')(t)

x1d = x1.diff('t')
x1dd = x1d.diff('t') #will need acceleration later
x2d = x2.diff('t')
x2dd = x2d.diff('t')

#3.  now write down an expression in terms of position and velocity
KE1 = (m1/2.0) * (x1d)**2
KE2 = (m2/2.0) * (x2d)**2
KE_sys = KE1 + KE2

U1  = (k1/2.0) * (x1) **2
U2  = (k2/2.0) * (x2 - x1) **2
U_sys = U1 + U2

lagrangian = KE_sys - U_sys
print('Lagrangian function:')
display(lagrangian)
35/8:
print('\033[1mDifferent ways of taking the derivative of the Lagrangian with respect ot the system state vector (q)')
t = sym.symbols('t')

# define two system states as functions
x1 = sym.Function(r'x_1')(t)
x2 = sym.Function(r'x_2')(t)
# # wrap system states into one vector (in SymPy would be Matrix)
# q = sym.Matrix([x1, x2])
# # define an expression in terms of x1(t) and x2(t)
# J = sym.sin(x1**2) + sym.cos(x2)**2
# print('\n\033[1mExample expression ')
# display(J)

# # compute derivative wrt a vector, method 1
# # wrap the expression into a SymPy Matrix
# J_mat = sym.Matrix([J])
# # SymPy Matrix has built-in method for Jacobian
# dJdq = J_mat.jacobian(q)
# print('\n\033[1mMethod: built-in Jacobian derivative')
# display(dJdq) # note that dJdq is 1-by-2 vector, not 2-by-1 as q

# # compute derivative wrt a vector, method 2: do it one by one
# dJdx1 = J.diff(x1)
# dJdx2 = J.diff(x2)
# dJdq = sym.Matrix([dJdx1, dJdx2]).T # transpose so dimension can match
# print('\n\033[1mMethod: one-by-one')
# display(dJdq)

# # compute derivative wrt a vector, method 3: do it one by one ... but in a "fancy" way
# dJdq = []
# for x in q:
#     dJdq.append(J.diff(x))
# dJdq = sym.Matrix([dJdq])
# print('\n\033[1mMethod: for loop')
# display(dJdq)
35/9:
# You can start your implementation here :)

#equation setup continued from previous problem

#4.  wrap system states into one vector (in SymPy would be Matrix)
q = sym.Matrix([x1, x2])
qd = q.diff(t)
qdd = qd.diff(t)

#5. create function of interest in terms of state variables x1, x2
#   --> we have already done this, it's the Lagrangian equation in this case

#6. compute deriv(function) wrt. state variables vector
L_mat = sym.Matrix([lagrangian]) # wrap the expression into a SymPy Matrix
dL_dq = L_mat.jacobian(q) #jacobian = deriv of matrix wrt. state vector

print("dL/dQ term:")
display(dL_dq)

#7. repeat for second term in E-L equations, then construct equation elements
dL_dqdot = L_mat.jacobian(qd)
LHS = dL_dq - dL_dqdot.diff(t)
RHS = sym.Matrix([0,0]).T

print("dL/dQdot term:")
display(dL_dqdot)
print("LHS of equation:")
display(LHS)
print("RHS of equation:")
display(RHS)
35/10:
x,y = sym.symbols(r'x,y')
# define left hand side as a matrix
lhs = sym.Matrix([x**2+y, x+y])

# define right hand side as a Matrix
rhs = sym.Matrix([3, 1])

# define the equations
eqn = sym.Eq(lhs, rhs)

# solve it for both x and y
q = sym.Matrix([x, y])
soln = sym.solve(eqn, q, dict=True) # this will return the solution 
                                     # as a Python dictionary
for sol in soln:
    print('\n\033[1mSolution: ')
    for v in q:
        display(sym.Eq(v, sol[v]))
35/11:
# You can start your implementation here :)

# 8. solve equation and display result
# LHS = LHS.T
# RHS = RHS.T
eqn = sym.Eq(LHS.T, RHS.T)

print("Equation:")
display(eqn)

soln = sym.solve(eqn, q, dict = True)

print(soln)

for x in q:
    display(sym.Eq(q, soln[0][x]))
    
#hm. ask for help regarding why code isn't behaving
35/12:
# print('\033[1mDifferent ways of taking the derivative of the Lagrangian with respect ot the system state vector (q)')
# t = sym.symbols('t')

# # define two system states as functions
# x1 = sym.Function(r'x_1')(t)
# x2 = sym.Function(r'x_2')(t)
# # wrap system states into one vector (in SymPy would be Matrix)
# q = sym.Matrix([x1, x2])
# # define an expression in terms of x1(t) and x2(t)
# J = sym.sin(x1**2) + sym.cos(x2)**2
# print('\n\033[1mExample expression ')
# display(J)

# # compute derivative wrt a vector, method 1
# # wrap the expression into a SymPy Matrix
# J_mat = sym.Matrix([J])
# # SymPy Matrix has built-in method for Jacobian
# dJdq = J_mat.jacobian(q)
# print('\n\033[1mMethod: built-in Jacobian derivative')
# display(dJdq) # note that dJdq is 1-by-2 vector, not 2-by-1 as q

# # compute derivative wrt a vector, method 2: do it one by one
# dJdx1 = J.diff(x1)
# dJdx2 = J.diff(x2)
# dJdq = sym.Matrix([dJdx1, dJdx2]).T # transpose so dimension can match
# print('\n\033[1mMethod: one-by-one')
# display(dJdq)

# # compute derivative wrt a vector, method 3: do it one by one ... but in a "fancy" way
# dJdq = []
# for x in q:
#     dJdq.append(J.diff(x))
# dJdq = sym.Matrix([dJdq])
# print('\n\033[1mMethod: for loop')
# display(dJdq)
35/13:
# You can start your implementation here :)

#equation setup continued from previous problem

#4.  wrap system states into one vector (in SymPy would be Matrix)
q = sym.Matrix([x1, x2])
qd = q.diff(t)
qdd = qd.diff(t)

#5. create function of interest in terms of state variables x1, x2
#   --> we have already done this, it's the Lagrangian equation in this case

#6. compute deriv(function) wrt. state variables vector
L_mat = sym.Matrix([lagrangian]) # wrap the expression into a SymPy Matrix
dL_dq = L_mat.jacobian(q) #jacobian = deriv of matrix wrt. state vector

print("dL/dQ term:")
display(dL_dq)

#7. repeat for second term in E-L equations, then construct equation elements
dL_dqdot = L_mat.jacobian(qd)
LHS = dL_dq - dL_dqdot.diff(t)
RHS = sym.Matrix([0,0]).T

print("dL/dQdot term:")
display(dL_dqdot)
print("LHS of equation:")
display(LHS)
print("RHS of equation:")
display(RHS)
35/14:
# You can start your implementation here :)

#equation setup continued from previous problem

#4.  wrap system states into one vector (in SymPy would be Matrix)
q = sym.Matrix([x1, x2])
qd = q.diff(t)
qdd = qd.diff(t)

#5. create function of interest in terms of state variables x1, x2
#   --> we have already done this, it's the Lagrangian equation in this case

#6. compute deriv(function) wrt. state variables vector
L_mat = sym.Matrix([lagrangian]) # wrap the expression into a SymPy Matrix
dL_dq = L_mat.jacobian(q) #jacobian = deriv of matrix wrt. state vector

print("dL/dQ term:")
display(dL_dq)

#7. repeat for second term in E-L equations, then construct equation elements
dL_dqdot = L_mat.jacobian(qd)
LHS = dL_dq - dL_dqdot.diff(t)
RHS = sym.Matrix([0,0]).T

print("dL/dQdot term:")
display(dL_dqdot)
print("LHS of equation:")
display(LHS)
print("RHS of equation:")
display(RHS)
35/15:
# You can start your implementation here :)

#1. grab variables
t = sym.symbols(r't') #independent variable
k1, k2, m1, m2 = sym.symbols(r'k1, k2, m1, m2') #constant

#2. define position, velocity, accel for masses 1 and 2 as functions
x1 = sym.Function(r'x1')(t)
x2 = sym.Function(r'x2')(t)

x1d = x1.diff('t')
x1dd = x1d.diff('t') #will need acceleration later
x2d = x2.diff('t')
x2dd = x2d.diff('t')

#3.  now write down an expression in terms of position and velocity
KE1 = (m1/2.0) * (x1d)**2
KE2 = (m2/2.0) * (x2d)**2
KE_sys = KE1 + KE2

U1  = (k1/2.0) * (x1) **2
U2  = (k2/2.0) * (x2 - x1) **2
U_sys = U1 + U2

lagrangian = KE_sys - U_sys
print('Lagrangian function:')
display(lagrangian)
35/16:
# You can start your implementation here :)

#equation setup continued from previous problem

#4.  wrap system states into one vector (in SymPy would be Matrix)
q = sym.Matrix([x1, x2])
qd = q.diff(t)
qdd = qd.diff(t)

#5. create function of interest in terms of state variables x1, x2
#   --> we have already done this, it's the Lagrangian equation in this case

#6. compute deriv(function) wrt. state variables vector
L_mat = sym.Matrix([lagrangian]) # wrap the expression into a SymPy Matrix
dL_dq = L_mat.jacobian(q) #jacobian = deriv of matrix wrt. state vector

print("dL/dQ term:")
display(dL_dq)

#7. repeat for second term in E-L equations, then construct equation elements
dL_dqdot = L_mat.jacobian(qd)
LHS = dL_dq - dL_dqdot.diff(t)
RHS = sym.Matrix([0,0]).T

print("dL/dQdot term:")
display(dL_dqdot)
print("LHS of equation:")
display(LHS)
print("RHS of equation:")
display(RHS)
36/1:
#IMPORT ALL NECESSARY PACKAGES AT THE TOP OF THE CODE
import sympy as sym
import numpy as np
import matplotlib.pyplot as plt

from IPython.display import Markdown, display
36/2:
# for google colab only

# def custom_latex_printer(exp,**options):
#     from google.colab.output._publish import javascript
#     url = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.1.1/latest.js?config=TeX-AMS_HTML"
#     javascript(url=url)
#     return sym.printing.latex(exp,**options)
# sym.init_printing(use_latex="mathjax",latex_printer=custom_latex_printer)
36/3:
from IPython.core.display import HTML
display(HTML("<table><tr><td><img src='https://github.com/MuchenSun/ME314pngs/raw/master/2mass_spring.png' width=500' height='350'></table>"))
36/4:
# # from sympy.abc import x, y, z or
# x,y,z = sym.symbols(r'x,y,z')
# expr = sym.sin(x) * y**2 * z + x*z + x/z**2
# print('\033[1mExample expression: ')
# display(expr)

# # method 1: the numerical function will take variables one by one
# func = sym.lambdify([x, y, z], expr)
# print('\n\033[1mTest at x=1, y=2, z=3: \033[0m{:.2f}'.format(func(1, 2, 3)))

# # method 2: the numerical function will take variables cotained in one list/array
# func = sym.lambdify([[x, y, z]], expr)
# print('\033[1mTest at x=1, y=2, z=3: \033[0m{:.2f}'.format(func([1, 2, 3])))
36/5:
# You can start your implementation here :)

#1. grab variables
x1, x2 = sym.symbols(r'x1, x2') #state variables
k1, k2, m1, m2 = sym.symbols(r'k1, k2, m1, m2') # constants
x1dd = sym.Function('x1') 
x2dd = sym.Function('x2')

#2. write expressions of x1** and x2** in terms of state variables
x1dd = (1/m1) * (k2 * x2) - (1/m1) * (k1 + k2) * x1
x2dd = -(k2/m2) * (x2 - x1)

print("Acceleration for mass 1:")
display(x1dd)
print("Acceleration for mass 2:")
display(x2dd)

#3. subs()titute in values for things
accel1 = x1dd.subs({
    k1: 0.5,
    k2: 0.8,
    m1: 1,
    m2: 2
}) #all in SI units; N/m and kg

accel2 = x2dd.subs({
    k1: 0.5,
    k2: 0.8,
    m1: 1,
    m2: 2
}) #all in SI units; N/m and kg

#4. lambdify functions and input values, method 1: take variables one by one

npaccel1 = sym.lambdify([x1, x2], accel1)
npaccel2 = sym.lambdify([x1, x2], accel2)

ans1 = npaccel1(1, 3)
ans2 = npaccel2(1, 3)

#check NP answer with hand calcs
assert np.isclose(ans1, 1.1), f"Accel 1: {ans1}" 
assert np.isclose(ans2, -0.8), f"Accel 2: {ans2}"
36/6:
# t = sym.symbols('t')
# # define position as function of t
# x1 = sym.Function(r'x_1')(t)
# # define velocity as derivative of position wrt t
# x1dot = x1.diff(t)
# # define acceleration as derivative of velocity wrt t
# x1ddot = x1dot.diff(t)

# # now write down an expression in terms of position and velocity
# expr = x1**2 + x1*x1dot
# print('\033[1mExample expression: ')
# display(expr)
# # you can take the derivative of this expression wrt to time t
# expr_dt = expr.diff(t)
# print('\n\033[1mDerivative of expression w.r.t. time (t): ')
# display(expr_dt)
# # or you can take the derivative wrt the functions: x, xdot, xddot
# expr_dx = expr.diff(x1)
# print('\n\033[1mDerivative of expression w.r.t. x1(t): ')
# display(expr_dx)
36/7:
# You can start your implementation here :)

#1. grab variables
t = sym.symbols(r't') #independent variable
k1, k2, m1, m2 = sym.symbols(r'k1, k2, m1, m2') #constant

#2. define position, velocity, accel for masses 1 and 2 as functions
x1 = sym.Function(r'x1')(t)
x2 = sym.Function(r'x2')(t)

x1d = x1.diff('t')
x1dd = x1d.diff('t') #will need acceleration later
x2d = x2.diff('t')
x2dd = x2d.diff('t')

#3.  now write down an expression in terms of position and velocity
KE1 = (m1/2.0) * (x1d)**2
KE2 = (m2/2.0) * (x2d)**2
KE_sys = KE1 + KE2

U1  = (k1/2.0) * (x1) **2
U2  = (k2/2.0) * (x2 - x1) **2
U_sys = U1 + U2

lagrangian = KE_sys - U_sys
print('Lagrangian function:')
display(lagrangian)
36/8:
# print('\033[1mDifferent ways of taking the derivative of the Lagrangian with respect ot the system state vector (q)')
# t = sym.symbols('t')

# # define two system states as functions
# x1 = sym.Function(r'x_1')(t)
# x2 = sym.Function(r'x_2')(t)
# # wrap system states into one vector (in SymPy would be Matrix)
# q = sym.Matrix([x1, x2])
# # define an expression in terms of x1(t) and x2(t)
# J = sym.sin(x1**2) + sym.cos(x2)**2
# print('\n\033[1mExample expression ')
# display(J)

# # compute derivative wrt a vector, method 1
# # wrap the expression into a SymPy Matrix
# J_mat = sym.Matrix([J])
# # SymPy Matrix has built-in method for Jacobian
# dJdq = J_mat.jacobian(q)
# print('\n\033[1mMethod: built-in Jacobian derivative')
# display(dJdq) # note that dJdq is 1-by-2 vector, not 2-by-1 as q

# # compute derivative wrt a vector, method 2: do it one by one
# dJdx1 = J.diff(x1)
# dJdx2 = J.diff(x2)
# dJdq = sym.Matrix([dJdx1, dJdx2]).T # transpose so dimension can match
# print('\n\033[1mMethod: one-by-one')
# display(dJdq)

# # compute derivative wrt a vector, method 3: do it one by one ... but in a "fancy" way
# dJdq = []
# for x in q:
#     dJdq.append(J.diff(x))
# dJdq = sym.Matrix([dJdq])
# print('\n\033[1mMethod: for loop')
# display(dJdq)
36/9:
# You can start your implementation here :)

#equation setup continued from previous problem

#4.  wrap system states into one vector (in SymPy would be Matrix)
q = sym.Matrix([x1, x2])
qd = q.diff(t)
qdd = qd.diff(t)

#5. create function of interest in terms of state variables x1, x2
#   --> we have already done this, it's the Lagrangian equation in this case

#6. compute deriv(function) wrt. state variables vector
L_mat = sym.Matrix([lagrangian]) # wrap the expression into a SymPy Matrix
dL_dq = L_mat.jacobian(q) #jacobian = deriv of matrix wrt. state vector

print("dL/dQ term:")
display(dL_dq)

#7. repeat for second term in E-L equations, then construct equation elements
dL_dqdot = L_mat.jacobian(qd)
LHS = dL_dq - dL_dqdot.diff(t)
RHS = sym.Matrix([0,0]).T

print("dL/dQdot term:")
display(dL_dqdot)
print("LHS of equation:")
display(LHS)
print("RHS of equation:")
display(RHS)
36/10:
# x,y = sym.symbols(r'x,y')
# # define left hand side as a matrix
# lhs = sym.Matrix([x**2+y, x+y])

# # define right hand side as a Matrix
# rhs = sym.Matrix([3, 1])

# # define the equations
# eqn = sym.Eq(lhs, rhs)

# # solve it for both x and y
# q = sym.Matrix([x, y])
# soln = sym.solve(eqn, q, dict=True) # this will return the solution 
#                                      # as a Python dictionary
# for sol in soln:
#     print('\n\033[1mSolution: ')
#     for v in q:
#         display(sym.Eq(v, sol[v]))
36/11:
# You can start your implementation here :)

# 8. solve equation and display result
# LHS = LHS.T
# RHS = RHS.T
eqn = sym.Eq(LHS.T, RHS.T)

print("Equation:")
display(eqn)

soln = sym.solve(eqn, q, dict = True)

print(soln)

for x in q:
    display(sym.Eq(q, soln[0][x]))
    
#hm. ask for help regarding why code isn't behaving
36/12:
from IPython.core.display import HTML
display(HTML("<table><tr><td><img src='https://raw.githubusercontent.com/MuchenSun/ME314pngs/master/dyninvpend.png' width=500' height='350'></table>"))
36/13: # You can start your implementation here :)
36/14: # You can start your implementation here :)
36/15: # You can start your implementation here :)
36/16:
def integrate(f, xt, dt):
    """
    This function takes in an initial condition x(t) and a timestep dt,
    as well as a dynamical system f(x) that outputs a vector of the
    same dimension as x(t). It outputs a vector x(t+dt) at the future
    time step.
    
    Parameters
    ============
    dyn: Python function
        derivate of the system at a given step x(t), 
        it can considered as \dot{x}(t) = func(x(t))
    xt: NumPy array
        current step x(t)
    dt: 
        step size for integration

    Return
    ============
    new_xt: 
        value of x(t+dt) integrated from x(t)
    """
    k1 = dt * f(xt)
    k2 = dt * f(xt+k1/2.)
    k3 = dt * f(xt+k2/2.)
    k4 = dt * f(xt+k3)
    new_xt = xt + (1/6.) * (k1+2.0*k2+2.0*k3+k4)
    return new_xt

def simulate(f, x0, tspan, dt, integrate):
    """
    This function takes in an initial condition x0, a timestep dt,
    a time span tspan consisting of a list [min_time, max_time],
    as well as a dynamical system f(x) that outputs a vector of the
    same dimension as x0. It outputs a full trajectory simulated
    over the time span of dimensions (xvec_size, time_vec_size).
    
    Parameters
    ============
    f: Python function
        derivate of the system at a given step x(t), 
        it can considered as \dot{x}(t) = func(x(t))
    x0: NumPy array
        initial conditions
    tspan: Python list
        tspan = [min_time, max_time], it defines the start and end
        time of simulation
    dt:
        time step for numerical integration
    integrate: Python function
        numerical integration method used in this simulation

    Return
    ============
    x_traj:
        simulated trajectory of x(t) from t=0 to tf
    """
    N = int((max(tspan)-min(tspan))/dt)
    x = np.copy(x0)
    tvec = np.linspace(min(tspan),max(tspan),N)
    xtraj = np.zeros((len(x0),N))
    for i in range(N):
        xtraj[:,i]=integrate(f,x,dt)
        x = np.copy(xtraj[:,i])
    return xtraj 

##############################################
# example: simulate a particle falling in gravity
def xddot(x, xdot):
    """
    Acceleration of the particle in terms of
    position and velocity. Here it's a constant.
    """
    
    return -9.8

def dyn(s):
    """
    System dynamics function (extended)
    
    Parameters
    ============
    s: NumPy array
        s = [x, xdot] is the extended system
        state vector, includng the position and
        the velocity of the particle
    
    Return
    ============
    sdot: NumPy array
        time derivative of input state vector,
        sdot = [xdot, xddot]
    """
    return np.array([s[1], xddot(s[0], s[1])])

# define initial state
s0 = np.array([10, 0]) # at 10m high with zero velocity
# simulat from t=0 to 10, since dt=0.1, the returned trajectory
# will have 10/0.1=100 time steps, each time step contains extended
# system state vector [x(t), xdot(t)]
traj = simulate(dyn, s0, [0, 10], 0.1, integrate) 
print('\033[1mShape of traj: \033[0m', traj.shape)
36/17: # You can start your implementation here :)
36/18:
mat = [[1, 2, 3],
       [4, 5, 6],
       [7, 8, 9]]
trace = mat[0][0] + mat[1][1] + mat[2][2]
36/19:
def compute_trace(mat):
    dim = len(mat)
    trace_val = 0
    for i in range(dim):
        trace_val += mat[i][i]
    return trace_val

mat = [[1, 2, 3],
       [4, 5, 6],
       [7, 8, 9]]
trace = compute_trace(mat)
36/20:
def euler_equations(L, funcs, t):
    """
    Find the Euler-Lagrangian equations given the Lagrangian equation.

    Parameters:
    ============
    L: SymPy Expression
        L should be a SymPy expression containing necessary system 
        configuration variables
    funcs: list of SymPy Functions
        func should included all the system configuration variables
        as functions of time variable "t" in the Lagrangian
    t: SymPy Symbol
        time variable

    Returns:
    ============
    eqns: SymPy Equation
        eqns is the resulting Euler-Lagrangian equations, it should
        be a sinlge SymPy Equation object, each side being a SymPy
        Matrix object
    """
    pass # In Python, "pass" means "do nothing",  many people use it
         # to occupy a space so they don't need to implement a function
         # while getting the program running. Here you just need to 
         # replace it with your own implementation.
36/21:
# You can start your implementation here :)

#1. grab variables
x1, x2 = sym.symbols(r'x1, x2') #state variables
k1, k2, m1, m2 = sym.symbols(r'k1, k2, m1, m2') # constants
x1dd = sym.Function('x1') 
x2dd = sym.Function('x2')

#2. write expressions of x1** and x2** in terms of state variables
x1dd = (1/m1) * (k2 * x2) - (1/m1) * (k1 + k2) * x1
x2dd = -(k2/m2) * (x2 - x1)

print("Acceleration for mass 1:")
display(x1dd)
print("Acceleration for mass 2:")
display(x2dd)

#3. subs()titute in values for things
accel1 = x1dd.subs({
    k1: 0.5,
    k2: 0.8,
    m1: 1,
    m2: 2
}) #all in SI units; N/m and kg

accel2 = x2dd.subs({
    k1: 0.5,
    k2: 0.8,
    m1: 1,
    m2: 2
}) #all in SI units; N/m and kg

#4. lambdify functions and input values, method 1: take variables one by one

npaccel1 = sym.lambdify([x1, x2], accel1)
npaccel2 = sym.lambdify([x1, x2], accel2)

ans1 = npaccel1(1, 3)
ans2 = npaccel2(1, 3)

#check NP answer with hand calcs
assert np.isclose(ans1, 1.1), f"Accel 1: {ans1}" 
assert np.isclose(ans2, -0.8), f"Accel 2: {ans2}"
36/22:
# You can start your implementation here :)

#1. grab variables
t = sym.symbols(r't') #independent variable
k1, k2, m1, m2 = sym.symbols(r'k1, k2, m1, m2') #constant

#2. define position, velocity, accel for masses 1 and 2 as functions
x1 = sym.Function(r'x1')(t)
x2 = sym.Function(r'x2')(t)

x1d = x1.diff('t')
x1dd = x1d.diff('t') #will need acceleration later
x2d = x2.diff('t')
x2dd = x2d.diff('t')

#3.  now write down an expression in terms of position and velocity
KE1 = (m1/2.0) * (x1d)**2
KE2 = (m2/2.0) * (x2d)**2
KE_sys = KE1 + KE2

U1  = (k1/2.0) * (x1) **2
U2  = (k2/2.0) * (x2 - x1) **2
U_sys = U1 + U2

lagrangian = KE_sys - U_sys
print('Lagrangian function:')
display(lagrangian)
36/23:
# You can start your implementation here :)

#equation setup continued from previous problem

#4.  wrap system states into one vector (in SymPy would be Matrix)
q = sym.Matrix([x1, x2])
qd = q.diff(t)
qdd = qd.diff(t)

#5. create function of interest in terms of state variables x1, x2
#   --> we have already done this, it's the Lagrangian equation in this case

#6. compute deriv(function) wrt. state variables vector
L_mat = sym.Matrix([lagrangian]) # wrap the expression into a SymPy Matrix
dL_dq = L_mat.jacobian(q) #jacobian = deriv of matrix wrt. state vector

print("dL/dQ term:")
display(dL_dq)

#7. repeat for second term in E-L equations, then construct equation elements
dL_dqdot = L_mat.jacobian(qd)
LHS = dL_dq - dL_dqdot.diff(t)
RHS = sym.Matrix([0,0]).T

print("dL/dQdot term:")
display(dL_dqdot)
print("LHS of equation:")
display(LHS)
print("RHS of equation:")
display(RHS)
36/24:
# You can start your implementation here :)

# 8. solve equation and display result
# LHS = LHS.T
# RHS = RHS.T
eqn = sym.Eq(LHS.T, RHS.T)

print("Equation:")
display(eqn)

soln = sym.solve(eqn, qdd, dict = True)

print(soln)

for x in q:
    display(sym.Eq(q, soln[0][x]))
    
#hm. ask for help regarding why code isn't behaving
36/25:
# You can start your implementation here :)

#purpose of this step: have sympy simplify the equation to give the acceleration of objects.
#this lets us integrate to give v and x as a function of t in next steps

# 8. solve equation and display result
# LHS = LHS.T
# RHS = RHS.T
eqn = sym.Eq(LHS.T, RHS.T)

print("Equation:")
display(eqn)

soln = sym.solve(eqn, qdd, dict = True)

print(soln)

for sol in soln:
    for x in q:
        display(sym.Eq(q, soln[x]))
    
#hm. ask for help regarding why code isn't behaving
36/26:
# You can start your implementation here :)

#purpose of this step: have sympy simplify the equation to give the acceleration of objects.
#this lets us integrate to give v and x as a function of t in next steps

# 8. solve equation and display result
# LHS = LHS.T
# RHS = RHS.T
eqn = sym.Eq(LHS.T, RHS.T)

print("Equation:")
display(eqn)

soln = sym.solve(eqn, qdd, dict = True)

print(soln)

for sol in soln:
    for x in q:
        display(sym.Eq(x, soln[x]))
    
#hm. ask for help regarding why code isn't behaving
36/27:
# You can start your implementation here :)

#purpose of this step: have sympy simplify the equation to give the acceleration of objects.
#this lets us integrate to give v and x as a function of t in next steps

# 8. solve equation and display result
# LHS = LHS.T
# RHS = RHS.T
eqn = sym.Eq(LHS.T, RHS.T)

print("Equation:")
display(eqn)

soln = sym.solve(eqn, qdd, dict = True)

print(soln)

for sol in soln:
    for x in q:
        display(sym.Eq(x, sol[x]))
    
#hm. ask for help regarding why code isn't behaving
36/28:
# You can start your implementation here :)

#purpose of this step: have sympy simplify the equation to give the acceleration of objects.
#this lets us integrate to give v and x as a function of t in next steps

# 8. solve equation and display result
# LHS = LHS.T
# RHS = RHS.T
eqn = sym.Eq(LHS.T, RHS.T)

print("Equation:")
display(eqn)

soln = sym.solve(eqn, qdd, dict = True)

print(soln)

for sol in soln:
    for x in qdd:
        display(sym.Eq(x, sol[x]))
    
#hm. ask for help regarding why code isn't behaving
36/29:
# You can start your implementation here :)

#purpose of this step: have sympy simplify the equation to give the acceleration of objects.
#this lets us integrate to give v and x as a function of t in next steps

# 8. solve equation and display result
# LHS = LHS.T
# RHS = RHS.T
eqn = sym.Eq(LHS.T, RHS.T)

print("Equation:")
display(eqn)

soln = sym.solve(eqn, qdd, dict = True)

print("Solution: ")
for sol in soln:
    for x in qdd:
        display(sym.Eq(x, sol[x]))
36/30:
#9. using numerical solvers, integrate the system from time t_o to t_f,
#applying initial conditions

#9a. lambdify our acceleration functions so we can plug in values for them and solve
x1dd_sy = sym.Eq(qdd[0], soln[0][qdd[0]])
x2dd_sy = sym.Eq(qdd[1], soln[1][qdd[1]])

display(x1dd_sy)

x1dd_np = sym.lambdify(q[0], q[1], soln[0]) #lamd(vars, function)


#how to set it up so that the function can take in a vector of x1 and x2, 
#then integrate to get acceleration x1d and x2d?

def dx1_dt(func, q): 
    
    pass

def rk4(dxdt, x, t, dt):
    '''
    Applies the Runge-Kutta method, 4th order, to a sample function,
    for a given state q0, for a given step size. Currently only
    configured for a 2-variable dependent system (x,y).
    ==========
    dxdt: a Sympy function that specifies the derivative of the system of interest
    t: the current timestep of the simulation
    x: current value of x for the sim
    dt: the amount to increment by for Runge-Kutta
    '''  
    k1 = dt * dxdt(t)
    k2 = dt * dxdt(t + dt/2, x + k1/2)
    k3 = dt * dxdt(t + dt/2, x + k2/2)
    k4 = dt * dxdt(t + dt, x + k3)
    x_new = x + (k1 + 2*k2 + 2*k3 + k4)/6
    
    return x_new

def rk4_array(dxdt, x_span, q0, step_size)
    '''
    Uses Runge-Kutta integration to integrate the x-y values for an entire array.
    
    func: a Sympy function that takes in a state vector of the same size as q0
    q0: a set of initial values for the state variables of the system
    x_span: the start and end of the range for which we are looking to
        study the system
    step_size: size of subdivision between steps from x0 to xf 
    
    '''
    



def euler(func, xspan, step_size):
    '''
    Numerical integration with Euler's method

    Parameters:
    ====================
    func: Python function
        func is the function you want to integrate for
    xspan: list
        xspan is a list of two elements, representing 
        the start and end of integration
    step_size:
        a smaller step size will give a more accurate result

    Returns:
    int_val:
        result of the integration
    ====================
    '''
    x = np.arange(xspan[0], xspan[1], step_size)
    int_val = 0
    for xi in x:
        int_val += func(xi) * step_size
    return int_val
36/31:
#9a. lambdify our acceleration functions so we can plug in values for them and solve
x1dd_sy = sym.Eq(qdd[0], soln[0][qdd[0]])
x2dd_sy = sym.Eq(qdd[1], soln[1][qdd[1]])

display(x1dd_sy)
display(x2dd_sy)

x1dd_np = sym.lambdify(q[0], q[1], soln[0]) #lamd(vars, function)
36/32:
#9a. lambdify our acceleration functions so we can plug in values for them and solve
x1dd_sy = sym.Eq(qdd[0], soln[0][qdd[0]])
x2dd_sy = sym.Eq(qdd[1], soln[0][qdd[1]])

display(x1dd_sy)
display(x2dd_sy)

x1dd_np = sym.lambdify(q[0], q[1], soln[0]) #lamd(vars, function)
36/33:
#9a. lambdify our acceleration functions so we can plug in values for them and solve
x1dd_sy = sym.Eq(qdd[0], soln[0][qdd[0]])
x2dd_sy = sym.Eq(qdd[1], soln[0][qdd[1]])

display(x1dd_sy)
display(x2dd_sy)

x1dd_np = sym.lambdify(q[0], q[1], x1dd_sy) #lamd(vars, function)
x2dd_np = sym.lambdify(q[0], q[1], x2dd_sy) #lamd(vars, function)
36/34:
#9a. lambdify our acceleration functions so we can plug in values for them and solve
x1dd_sy = soln[0][qdd[0]]
x2dd_sy = soln[0][qdd[1]]

display(x1dd_sy)
display(x2dd_sy)

x1dd_np = sym.lambdify(q[0], q[1], x1dd_sy) #lamd(vars, function)
x2dd_np = sym.lambdify(q[0], q[1], x2dd_sy) #lamd(vars, function)
36/35:
#9a. lambdify our acceleration functions so we can plug in values for them and solve
x1dd_sy = soln[0][qdd[0]]
x2dd_sy = soln[0][qdd[1]]

display(x1dd_sy)
display(x2dd_sy)

x1dd_np = sym.lambdify([q[0], q[1]], x1dd_sy) #lamd(vars, function)
x2dd_np = sym.lambdify([q[0], q[1]], x2dd_sy) #lamd(vars, function)
36/36:
# You can start your implementation here :)

#purpose of this step: have sympy simplify the equation to give the acceleration of objects.
#this lets us integrate to give v and x as a function of t in next steps

# 8. solve equation and display result
# LHS = LHS.T
# RHS = RHS.T
eqn = sym.Eq(LHS.T, RHS.T)

print("Equation:")
display(eqn)

soln = sym.solve(eqn, qdd, dict = True)

print("Solution: ")
for sol in soln:
    for x in qdd:
        display(sym.Eq(x, sol[x]))
    
print("These acceleration equations match what I found via written analysis.")
36/37:
#9a. lambdify our acceleration functions so we can plug in values for them and solve
#substitute in our values of constants b/c we sure can't do it once they're in numpy
x1dd_sy = soln[0][qdd[0]]
x2dd_sy = soln[0][qdd[1]]

x1dd_sy = x1dd.subs(consts_dict) #defined above
x2dd_sy = x2dd.subs(consts_dict) #defined above


display(x1dd_sy)
display(x2dd_sy)

x1dd_np = sym.lambdify([q[0], q[1]], x1dd_sy) #lamd(vars, function)
x2dd_np = sym.lambdify([q[0], q[1]], x2dd_sy) #lamd(vars, function)
38/1:
#IMPORT ALL NECESSARY PACKAGES AT THE TOP OF THE CODE
import sympy as sym
import numpy as np
import matplotlib.pyplot as plt

from IPython.display import Markdown, display
38/2:
# for google colab only

# def custom_latex_printer(exp,**options):
#     from google.colab.output._publish import javascript
#     url = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.1.1/latest.js?config=TeX-AMS_HTML"
#     javascript(url=url)
#     return sym.printing.latex(exp,**options)
# sym.init_printing(use_latex="mathjax",latex_printer=custom_latex_printer)
38/3:
from IPython.core.display import HTML
display(HTML("<table><tr><td><img src='https://github.com/MuchenSun/ME314pngs/raw/master/2mass_spring.png' width=500' height='350'></table>"))
38/4:
# # from sympy.abc import x, y, z or
# x,y,z = sym.symbols(r'x,y,z')
# expr = sym.sin(x) * y**2 * z + x*z + x/z**2
# print('\033[1mExample expression: ')
# display(expr)

# # method 1: the numerical function will take variables one by one
# func = sym.lambdify([x, y, z], expr)
# print('\n\033[1mTest at x=1, y=2, z=3: \033[0m{:.2f}'.format(func(1, 2, 3)))

# # method 2: the numerical function will take variables cotained in one list/array
# func = sym.lambdify([[x, y, z]], expr)
# print('\033[1mTest at x=1, y=2, z=3: \033[0m{:.2f}'.format(func([1, 2, 3])))
38/5:
# You can start your implementation here :)

#1. grab variables
x1, x2 = sym.symbols(r'x1, x2') #state variables
k1, k2, m1, m2 = sym.symbols(r'k1, k2, m1, m2') # constants
x1dd = sym.Function('x1') 
x2dd = sym.Function('x2')

#2. write expressions of x1** and x2** in terms of state variables
x1dd = (1/m1) * (k2 * x2) - (1/m1) * (k1 + k2) * x1
x2dd = -(k2/m2) * (x2 - x1)

print("Acceleration for mass 1:")
display(x1dd)
print("Acceleration for mass 2:")
display(x2dd)

consts_dict = {
    k1: 0.5,
    k2: 0.8,
    m1: 1,
    m2: 2
}

#3. subs()titute in values for things
accel1 = x1dd.subs(consts_dict) #all in SI units; N/m and kg
accel2 = x2dd.subs(consts_dict) #all in SI units; N/m and kg

#4. lambdify functions and input values, method 1: take variables one by one

npaccel1 = sym.lambdify([x1, x2], accel1)
npaccel2 = sym.lambdify([x1, x2], accel2)

ans1 = npaccel1(1, 3)
ans2 = npaccel2(1, 3)

#check NP answer with hand calcs
assert np.isclose(ans1, 1.1), f"Accel 1: {ans1}" 
assert np.isclose(ans2, -0.8), f"Accel 2: {ans2}"
38/6:
# t = sym.symbols('t')
# # define position as function of t
# x1 = sym.Function(r'x_1')(t)
# # define velocity as derivative of position wrt t
# x1dot = x1.diff(t)
# # define acceleration as derivative of velocity wrt t
# x1ddot = x1dot.diff(t)

# # now write down an expression in terms of position and velocity
# expr = x1**2 + x1*x1dot
# print('\033[1mExample expression: ')
# display(expr)
# # you can take the derivative of this expression wrt to time t
# expr_dt = expr.diff(t)
# print('\n\033[1mDerivative of expression w.r.t. time (t): ')
# display(expr_dt)
# # or you can take the derivative wrt the functions: x, xdot, xddot
# expr_dx = expr.diff(x1)
# print('\n\033[1mDerivative of expression w.r.t. x1(t): ')
# display(expr_dx)
38/7:
# You can start your implementation here :)

#1. grab variables
t = sym.symbols(r't') #independent variable
k1, k2, m1, m2 = sym.symbols(r'k1, k2, m1, m2') #constant

#2. define position, velocity, accel for masses 1 and 2 as functions
x1 = sym.Function(r'x1')(t)
x2 = sym.Function(r'x2')(t)

x1d = x1.diff('t')
x1dd = x1d.diff('t') #will need acceleration later
x2d = x2.diff('t')
x2dd = x2d.diff('t')

#3.  now write down an expression in terms of position and velocity
KE1 = (m1/2.0) * (x1d)**2
KE2 = (m2/2.0) * (x2d)**2
KE_sys = KE1 + KE2

U1  = (k1/2.0) * (x1) **2
U2  = (k2/2.0) * (x2 - x1) **2
U_sys = U1 + U2

lagrangian = KE_sys - U_sys
print('Lagrangian function:')
display(lagrangian)
38/8:
# print('\033[1mDifferent ways of taking the derivative of the Lagrangian with respect ot the system state vector (q)')
# t = sym.symbols('t')

# # define two system states as functions
# x1 = sym.Function(r'x_1')(t)
# x2 = sym.Function(r'x_2')(t)
# # wrap system states into one vector (in SymPy would be Matrix)
# q = sym.Matrix([x1, x2])
# # define an expression in terms of x1(t) and x2(t)
# J = sym.sin(x1**2) + sym.cos(x2)**2
# print('\n\033[1mExample expression ')
# display(J)

# # compute derivative wrt a vector, method 1
# # wrap the expression into a SymPy Matrix
# J_mat = sym.Matrix([J])
# # SymPy Matrix has built-in method for Jacobian
# dJdq = J_mat.jacobian(q)
# print('\n\033[1mMethod: built-in Jacobian derivative')
# display(dJdq) # note that dJdq is 1-by-2 vector, not 2-by-1 as q

# # compute derivative wrt a vector, method 2: do it one by one
# dJdx1 = J.diff(x1)
# dJdx2 = J.diff(x2)
# dJdq = sym.Matrix([dJdx1, dJdx2]).T # transpose so dimension can match
# print('\n\033[1mMethod: one-by-one')
# display(dJdq)

# # compute derivative wrt a vector, method 3: do it one by one ... but in a "fancy" way
# dJdq = []
# for x in q:
#     dJdq.append(J.diff(x))
# dJdq = sym.Matrix([dJdq])
# print('\n\033[1mMethod: for loop')
# display(dJdq)
38/9:
# You can start your implementation here :)

#equation setup continued from previous problem

#4.  wrap system states into one vector (in SymPy would be Matrix)
q = sym.Matrix([x1, x2])
qd = q.diff(t)
qdd = qd.diff(t)

#5. create function of interest in terms of state variables x1, x2
#   --> we have already done this, it's the Lagrangian equation in this case

#6. compute deriv(function) wrt. state variables vector
L_mat = sym.Matrix([lagrangian]) # wrap the expression into a SymPy Matrix
dL_dq = L_mat.jacobian(q) #jacobian = deriv of matrix wrt. state vector

print("dL/dQ term:")
display(dL_dq)

#7. repeat for second term in E-L equations, then construct equation elements
dL_dqdot = L_mat.jacobian(qd)
LHS = dL_dq - dL_dqdot.diff(t)
RHS = sym.Matrix([0,0]).T

print("dL/dQdot term:")
display(dL_dqdot)
print("LHS of equation:")
display(LHS)
print("RHS of equation:")
display(RHS)
38/10:
# x,y = sym.symbols(r'x,y')
# # define left hand side as a matrix
# lhs = sym.Matrix([x**2+y, x+y])

# # define right hand side as a Matrix
# rhs = sym.Matrix([3, 1])

# # define the equations
# eqn = sym.Eq(lhs, rhs)

# # solve it for both x and y
# q = sym.Matrix([x, y])
# soln = sym.solve(eqn, q, dict=True) # this will return the solution 
#                                      # as a Python dictionary
# for sol in soln:
#     print('\n\033[1mSolution: ')
#     for v in q:
#         display(sym.Eq(v, sol[v]))
38/11:
# You can start your implementation here :)

#purpose of this step: have sympy simplify the equation to give the acceleration of objects.
#this lets us integrate to give v and x as a function of t in next steps

# 8. solve equation and display result
# LHS = LHS.T
# RHS = RHS.T
eqn = sym.Eq(LHS.T, RHS.T)

print("Equation:")
display(eqn)

soln = sym.solve(eqn, qdd, dict = True)

print("Solution: ")
for sol in soln:
    for x in qdd:
        display(sym.Eq(x, sol[x]))
    
print("These acceleration equations match what I found via written analysis.")
38/12:
#9a. lambdify our acceleration functions so we can plug in values for them and solve
#substitute in our values of constants b/c we sure can't do it once they're in numpy
x1dd_sy = soln[0][qdd[0]]
x2dd_sy = soln[0][qdd[1]]

x1dd_sy = x1dd.subs(consts_dict) #defined above
x2dd_sy = x2dd.subs(consts_dict) #defined above


display(x1dd_sy)
display(x2dd_sy)

x1dd_np = sym.lambdify([q[0], q[1]], x1dd_sy) #lamd(vars, function)
x2dd_np = sym.lambdify([q[0], q[1]], x2dd_sy) #lamd(vars, function)
38/13:
#9. using numerical solvers, integrate the system from time t_o to t_f,
#applying initial conditions


#how to set it up so that the function can take in a vector of x1 and x2, 
#then integrate to get acceleration x1d and x2d?

#should I be using dictionaries more than I currently am, rather than lists
#like in the state vector?

def dx1_dt(func, q): 
    
    pass

def rk4(dxdt, x, t, dt):
    '''
    Applies the Runge-Kutta method, 4th order, to a sample function,
    for a given state q0, for a given step size. Currently only
    configured for a 2-variable dependent system (x,y).
    ==========
    dxdt: a Sympy function that specifies the derivative of the system of interest
    t: the current timestep of the simulation
    x: current value of x for the sim
    dt: the amount to increment by for Runge-Kutta
    '''  
    k1 = dt * dxdt(t)
    k2 = dt * dxdt(t + dt/2, x + k1/2)
    k3 = dt * dxdt(t + dt/2, x + k2/2)
    k4 = dt * dxdt(t + dt, x + k3)
    x_new = x + (k1 + 2*k2 + 2*k3 + k4)/6
    
    return x_new

def rk4_array(dxdt, x_span, q0, step_size):
    '''
    Uses Runge-Kutta integration to integrate the x-y values for an entire array.
    
    func: a Sympy function that takes in a state vector of the same size as q0
    q0: a set of initial values for the state variables of the system
    x_span: the start and end of the range for which we are looking to
        study the system
    step_size: size of subdivision between steps from x0 to xf 
    
    '''
    



def euler(func, xspan, step_size):
    '''
    Numerical integration with Euler's method

    Parameters:
    ====================
    func: Python function
        func is the function you want to integrate for
    xspan: list
        xspan is a list of two elements, representing 
        the start and end of integration
    step_size:
        a smaller step size will give a more accurate result

    Returns:
    int_val:
        result of the integration
    ====================
    '''
    x = np.arange(xspan[0], xspan[1], step_size)
    int_val = 0
    for xi in x:
        int_val += func(xi) * step_size
    return int_val
38/14:
from IPython.core.display import HTML
display(HTML("<table><tr><td><img src='https://raw.githubusercontent.com/MuchenSun/ME314pngs/master/dyninvpend.png' width=500' height='350'></table>"))
38/15: # You can start your implementation here :)
38/16: # You can start your implementation here :)
38/17: # You can start your implementation here :)
38/18:
def integrate(f, xt, dt):
    """
    This function takes in an initial condition x(t) and a timestep dt,
    as well as a dynamical system f(x) that outputs a vector of the
    same dimension as x(t). It outputs a vector x(t+dt) at the future
    time step.
    
    Parameters
    ============
    dyn: Python function
        derivate of the system at a given step x(t), 
        it can considered as \dot{x}(t) = func(x(t))
    xt: NumPy array
        current step x(t)
    dt: 
        step size for integration

    Return
    ============
    new_xt: 
        value of x(t+dt) integrated from x(t)
    """
    k1 = dt * f(xt)
    k2 = dt * f(xt+k1/2.)
    k3 = dt * f(xt+k2/2.)
    k4 = dt * f(xt+k3)
    new_xt = xt + (1/6.) * (k1+2.0*k2+2.0*k3+k4)
    return new_xt

def simulate(f, x0, tspan, dt, integrate):
    """
    This function takes in an initial condition x0, a timestep dt,
    a time span tspan consisting of a list [min_time, max_time],
    as well as a dynamical system f(x) that outputs a vector of the
    same dimension as x0. It outputs a full trajectory simulated
    over the time span of dimensions (xvec_size, time_vec_size).
    
    Parameters
    ============
    f: Python function
        derivate of the system at a given step x(t), 
        it can considered as \dot{x}(t) = func(x(t))
    x0: NumPy array
        initial conditions
    tspan: Python list
        tspan = [min_time, max_time], it defines the start and end
        time of simulation
    dt:
        time step for numerical integration
    integrate: Python function
        numerical integration method used in this simulation

    Return
    ============
    x_traj:
        simulated trajectory of x(t) from t=0 to tf
    """
    N = int((max(tspan)-min(tspan))/dt)
    x = np.copy(x0)
    tvec = np.linspace(min(tspan),max(tspan),N)
    xtraj = np.zeros((len(x0),N))
    for i in range(N):
        xtraj[:,i]=integrate(f,x,dt)
        x = np.copy(xtraj[:,i])
    return xtraj 

##############################################
# example: simulate a particle falling in gravity
def xddot(x, xdot):
    """
    Acceleration of the particle in terms of
    position and velocity. Here it's a constant.
    """
    
    return -9.8

def dyn(s):
    """
    System dynamics function (extended)
    
    Parameters
    ============
    s: NumPy array
        s = [x, xdot] is the extended system
        state vector, includng the position and
        the velocity of the particle
    
    Return
    ============
    sdot: NumPy array
        time derivative of input state vector,
        sdot = [xdot, xddot]
    """
    return np.array([s[1], xddot(s[0], s[1])])

# define initial state
s0 = np.array([10, 0]) # at 10m high with zero velocity
# simulat from t=0 to 10, since dt=0.1, the returned trajectory
# will have 10/0.1=100 time steps, each time step contains extended
# system state vector [x(t), xdot(t)]
traj = simulate(dyn, s0, [0, 10], 0.1, integrate) 
print('\033[1mShape of traj: \033[0m', traj.shape)
38/19: # You can start your implementation here :)
38/20:
mat = [[1, 2, 3],
       [4, 5, 6],
       [7, 8, 9]]
trace = mat[0][0] + mat[1][1] + mat[2][2]
38/21:
def compute_trace(mat):
    dim = len(mat)
    trace_val = 0
    for i in range(dim):
        trace_val += mat[i][i]
    return trace_val

mat = [[1, 2, 3],
       [4, 5, 6],
       [7, 8, 9]]
trace = compute_trace(mat)
38/22:
def euler_equations(L, funcs, t):
    """
    Find the Euler-Lagrangian equations given the Lagrangian equation.

    Parameters:
    ============
    L: SymPy Expression
        L should be a SymPy expression containing necessary system 
        configuration variables
    funcs: list of SymPy Functions
        func should included all the system configuration variables
        as functions of time variable "t" in the Lagrangian
    t: SymPy Symbol
        time variable

    Returns:
    ============
    eqns: SymPy Equation
        eqns is the resulting Euler-Lagrangian equations, it should
        be a sinlge SymPy Equation object, each side being a SymPy
        Matrix object
    """
    pass # In Python, "pass" means "do nothing",  many people use it
         # to occupy a space so they don't need to implement a function
         # while getting the program running. Here you just need to 
         # replace it with your own implementation.
38/23:
#9a. lambdify our acceleration functions so we can plug in values for them and solve
#substitute in our values of constants b/c we sure can't do it once they're in numpy
x1dd_sy = soln[0][qdd[0]]
x2dd_sy = soln[0][qdd[1]]

# x1dd_sy = x1dd.subs(consts_dict) #defined above
# x2dd_sy = x2dd.subs(consts_dict) #defined above


display(x1dd_sy)
display(x2dd_sy)

x1dd_np = sym.lambdify([q[0], q[1]], x1dd_sy) #lamd(vars, function)
x2dd_np = sym.lambdify([q[0], q[1]], x2dd_sy) #lamd(vars, function)
38/24:
#9a. lambdify our acceleration functions so we can plug in values for them and solve
#substitute in our values of constants b/c we sure can't do it once they're in numpy
x1dd_sy = soln[0][qdd[0]]
x2dd_sy = soln[0][qdd[1]]

x1dd_sy = x1dd_sy.subs(consts_dict) #defined above
x2dd_sy = x2dd_sy.subs(consts_dict) #defined above


display(x1dd_sy)
display(x2dd_sy)

x1dd_np = sym.lambdify([q[0], q[1]], x1dd_sy) #lamd(vars, function)
x2dd_np = sym.lambdify([q[0], q[1]], x2dd_sy) #lamd(vars, function)
38/25:
#9a. lambdify our acceleration functions so we can plug in values for them and solve
#substitute in our values of constants b/c we sure can't do it once they're in numpy
x1dd_sy = soln[0][qdd[0]]
x2dd_sy = soln[0][qdd[1]]

x1dd_sy = x1dd_sy.subs(consts_dict) #defined above
x2dd_sy = x2dd_sy.subs(consts_dict) #defined above

display(x1dd_sy)
display(x2dd_sy)

x1dd_np = sym.lambdify([q[0], q[1]], x1dd_sy) #lamd(vars, function)
x2dd_np = sym.lambdify([q[0], q[1]], x2dd_sy) #lamd(vars, function)
38/26:
def rk4(dxdt, x, t, dt):
    '''
    Applies the Runge-Kutta method, 4th order, to a sample function,
    for a given state q0, for a given step size. Currently only
    configured for a 2-variable dependent system (x,y).
    ==========
    dxdt: a Sympy function that specifies the derivative of the system of interest
    t: the current timestep of the simulation
    x: current value of the state vector
    dt: the amount to increment by for Runge-Kutta
    ======
    returns:
    x_new: value of the state vector at the next timestep
    '''  
    k1 = dt * dxdt(t, x)
    k2 = dt * dxdt(t + dt/2, x + k1/2)
    k3 = dt * dxdt(t + dt/2, x + k2/2)
    k4 = dt * dxdt(t + dt, x + k3)
    x_new = x + (k1 + 2*k2 + 2*k3 + k4)/6
    
    return x_new
    
def euler(dxdt, x, t, dt):
    '''
    Euler's method

    Parameters:
    =============
    dxdt: a Sympy function that specifies the derivative of the system of interest
    t: the current timestep of the simulation
    x: current value of the state vector
    dt: the amount to increment by for Euler
    ======
    returns:
    x_new: value of the state vector at the next timestep
    '''
    x_new = dt * dxdt(t, x)
    return x_new

res = euler(lambda (t, x): x^2, 0.5, 2, 0.1)
assert res == 0.025, f"Euler val: {res}"
38/27:
def rk4(dxdt, x, t, dt):
    '''
    Applies the Runge-Kutta method, 4th order, to a sample function,
    for a given state q0, for a given step size. Currently only
    configured for a 2-variable dependent system (x,y).
    ==========
    dxdt: a Sympy function that specifies the derivative of the system of interest
    t: the current timestep of the simulation
    x: current value of the state vector
    dt: the amount to increment by for Runge-Kutta
    ======
    returns:
    x_new: value of the state vector at the next timestep
    '''  
    k1 = dt * dxdt(t, x)
    k2 = dt * dxdt(t + dt/2, x + k1/2)
    k3 = dt * dxdt(t + dt/2, x + k2/2)
    k4 = dt * dxdt(t + dt, x + k3)
    x_new = x + (k1 + 2*k2 + 2*k3 + k4)/6
    
    return x_new
    
def euler(dxdt, x, t, dt):
    '''
    Euler's method

    Parameters:
    =============
    dxdt: a Sympy function that specifies the derivative of the system of interest
    t: the current timestep of the simulation
    x: current value of the state vector
    dt: the amount to increment by for Euler
    ======
    returns:
    x_new: value of the state vector at the next timestep
    '''
    x_new = dt * dxdt(t, x)
    return x_new

res = euler(lambda t, x: x^2, 0.5, 2, 0.1)
assert res == 0.025, f"Euler val: {res}"
38/28:
def rk4(dxdt, x, t, dt):
    '''
    Applies the Runge-Kutta method, 4th order, to a sample function,
    for a given state q0, for a given step size. Currently only
    configured for a 2-variable dependent system (x,y).
    ==========
    dxdt: a Sympy function that specifies the derivative of the system of interest
    t: the current timestep of the simulation
    x: current value of the state vector
    dt: the amount to increment by for Runge-Kutta
    ======
    returns:
    x_new: value of the state vector at the next timestep
    '''  
    k1 = dt * dxdt(t, x)
    k2 = dt * dxdt(t + dt/2, x + k1/2)
    k3 = dt * dxdt(t + dt/2, x + k2/2)
    k4 = dt * dxdt(t + dt, x + k3)
    x_new = x + (k1 + 2*k2 + 2*k3 + k4)/6
    
    return x_new
    
def euler(dxdt, x, t, dt):
    '''
    Euler's method

    Parameters:
    =============
    dxdt: a Sympy function that specifies the derivative of the system of interest
    t: the current timestep of the simulation
    x: current value of the state vector
    dt: the amount to increment by for Euler
    ======
    returns:
    x_new: value of the state vector at the next timestep
    '''
    x_new = dt * dxdt(t, x)
    return x_new

res = euler(lambda t, x: x**2, 0.5, 2, 0.1)
assert res == 0.025, f"Euler val: {res}"
38/29:
def rk4(dxdt, x, t, dt):
    '''
    Applies the Runge-Kutta method, 4th order, to a sample function,
    for a given state q0, for a given step size. Currently only
    configured for a 2-variable dependent system (x,y).
    ==========
    dxdt: a Sympy function that specifies the derivative of the system of interest
    t: the current timestep of the simulation
    x: current value of the state vector
    dt: the amount to increment by for Runge-Kutta
    ======
    returns:
    x_new: value of the state vector at the next timestep
    '''  
    k1 = dt * dxdt(t, x)
    k2 = dt * dxdt(t + dt/2, x + k1/2)
    k3 = dt * dxdt(t + dt/2, x + k2/2)
    k4 = dt * dxdt(t + dt, x + k3)
    x_new = x + (k1 + 2*k2 + 2*k3 + k4)/6
    
    return x_new
    
def euler(dxdt, x, t, dt):
    '''
    Euler's method

    Parameters:
    =============
    dxdt: a Sympy function that specifies the derivative of the system of interest
    t: the current timestep of the simulation
    x: current value of the state vector
    dt: the amount to increment by for Euler
    ======
    returns:
    x_new: value of the state vector at the next timestep
    '''
    x_new = dt * dxdt(t, x)
    return x_new

res = euler(lambda t, x: x**2, 0.5, 2, 0.1)
assert res == 0.025, f"Euler val: {res}"
38/30:
def rk4(dxdt, x, t, dt):
    '''
    Applies the Runge-Kutta method, 4th order, to a sample function,
    for a given state q0, for a given step size. Currently only
    configured for a 2-variable dependent system (x,y).
    ==========
    dxdt: a Sympy function that specifies the derivative of the system of interest
    t: the current timestep of the simulation
    x: current value of the state vector
    dt: the amount to increment by for Runge-Kutta
    ======
    returns:
    x_new: value of the state vector at the next timestep
    '''  
    k1 = dt * dxdt(t, x)
    k2 = dt * dxdt(t + dt/2, x + k1/2)
    k3 = dt * dxdt(t + dt/2, x + k2/2)
    k4 = dt * dxdt(t + dt, x + k3)
    x_new = x + (k1 + 2*k2 + 2*k3 + k4)/6
    
    return x_new
    
def euler(dxdt, x, t, dt):
    '''
    Euler's method

    Parameters:
    =============
    dxdt: a Sympy function that specifies the derivative of the system of interest
    t: the current timestep of the simulation
    x: current value of the state vector
    dt: the amount to increment by for Euler
    ======
    returns:
    x_new: value of the state vector at the next timestep
    '''
    x_new = dt * dxdt(t, x)
    return x_new

res = euler(lambda t, x: x**2, 0.5, 2, 0.1)
assert res == 0.025, f"Euler val: {res}"
38/31:
def rk4(dxdt, x, t, dt):
    '''
    Applies the Runge-Kutta method, 4th order, to a sample function,
    for a given state q0, for a given step size. Currently only
    configured for a 2-variable dependent system (x,y).
    ==========
    dxdt: a Sympy function that specifies the derivative of the system of interest
    t: the current timestep of the simulation
    x: current value of the state vector
    dt: the amount to increment by for Runge-Kutta
    ======
    returns:
    x_new: value of the state vector at the next timestep
    '''  
    k1 = dt * dxdt(t, x)
    k2 = dt * dxdt(t + dt/2, x + k1/2)
    k3 = dt * dxdt(t + dt/2, x + k2/2)
    k4 = dt * dxdt(t + dt, x + k3)
    x_new = x + (k1 + 2*k2 + 2*k3 + k4)/6
    
    return x_new
    
def euler(dxdt, x, t, dt):
    '''
    Euler's method

    Parameters:
    =============
    dxdt: a Sympy function that specifies the derivative of the system of interest
    t: the current timestep of the simulation
    x: current value of the state vector
    dt: the amount to increment by for Euler
    ======
    returns:
    x_new: value of the state vector at the next timestep
    '''
    x_new = dt * dxdt(t, x)
    return x_new

eul = euler(lambda t, x: x**2, 0.5, 2, 0.1)
assert eul == 0.025, f"Euler val: {res}"

rk = rk4(lambda t, x: x**2, 0.5, 2, 0.1)
assert np.isclose(rk, 0.002512562814003933), f"RK4 value: {rk}"
38/32:
def rk4(dxdt, x, t, dt):
    '''
    Applies the Runge-Kutta method, 4th order, to a sample function,
    for a given state q0, for a given step size. Currently only
    configured for a 2-variable dependent system (x,y).
    ==========
    dxdt: a Sympy function that specifies the derivative of the system of interest
    t: the current timestep of the simulation
    x: current value of the state vector
    dt: the amount to increment by for Runge-Kutta
    ======
    returns:
    x_new: value of the state vector at the next timestep
    '''  
    k1 = dt * dxdt(t, x)
    k2 = dt * dxdt(t + dt/2, x + k1/2)
    k3 = dt * dxdt(t + dt/2, x + k2/2)
    k4 = dt * dxdt(t + dt, x + k3)
    x_new = x + (k1 + 2*k2 + 2*k3 + k4)/6
    
    return x_new
    
def euler(dxdt, x, t, dt):
    '''
    Euler's method

    Parameters:
    =============
    dxdt: a Sympy function that specifies the derivative of the system of interest
    t: the current timestep of the simulation
    x: current value of the state vector
    dt: the amount to increment by for Euler
    ======
    returns:
    x_new: value of the state vector at the next timestep
    '''
    x_new = x + dt * dxdt(t, x)
    return x_new

eul = euler(lambda t, x: x**2, 0.5, 2, 0.1)
assert eul == 0.525, f"Euler val: {res}"

rk = rk4(lambda t, x: x**2, 0.5, 2, 0.1)
assert np.isclose(rk, 0.002512562814003933), f"RK4 value: {rk}"
38/33:
def rk4(dxdt, x, t, dt):
    '''
    Applies the Runge-Kutta method, 4th order, to a sample function,
    for a given state q0, for a given step size. Currently only
    configured for a 2-variable dependent system (x,y).
    ==========
    dxdt: a Sympy function that specifies the derivative of the system of interest
    t: the current timestep of the simulation
    x: current value of the state vector
    dt: the amount to increment by for Runge-Kutta
    ======
    returns:
    x_new: value of the state vector at the next timestep
    '''  
    k1 = dt * dxdt(t, x)
    k2 = dt * dxdt(t + dt/2, x + k1/2)
    k3 = dt * dxdt(t + dt/2, x + k2/2)
    k4 = dt * dxdt(t + dt, x + k3)
    x_new = x + (k1 + 2*k2 + 2*k3 + k4)/6
    
    return x_new
    
def euler(dxdt, x, t, dt):
    '''
    Euler's method

    Parameters:
    =============
    dxdt: a Sympy function that specifies the derivative of the system of interest
    t: the current timestep of the simulation
    x: current value of the state vector
    dt: the amount to increment by for Euler
    ======
    returns:
    x_new: value of the state vector at the next timestep
    '''
    x_new = x + dt * dxdt(t, x)
    return x_new

eul = euler(lambda t, x: x**2, 0.5, 2, 0.1)
assert eul == 0.525, f"Euler val: {res}"

rk = rk4(lambda t, x: x**2, 0.5, 2, 0.1)
assert np.isclose(rk, 0.526315781526278075), f"RK4 value: {rk}"
38/34:
#9a. lambdify our acceleration functions so we can plug in values for them and solve
#substitute in our values of constants b/c we sure can't do it once they're in numpy
x1dd_sy = soln[0][qdd[0]]
x2dd_sy = soln[0][qdd[1]]

x1dd_sy = x1dd_sy.subs(consts_dict) #defined above
x2dd_sy = x2dd_sy.subs(consts_dict) #defined above

display(x1dd_sy)
display(x2dd_sy)

x1dd_np = sym.lambdify([q[0], q[1]], x1dd_sy) #lamd(vars, function)
x2dd_np = sym.lambdify([q[0], q[1]], x2dd_sy) #lamd(vars, function)
38/35:
#9. define our state vector 
q0 = np.array(0,0,0,0) #x1, x2, x1d, x2d
qd0 = np.array(0,0,0,0) #x1d, x2d, x1dd, x2dd

def dxdt(t, q):
    '''
    Derivative of our state vector at the given state [x1, x2, x1d, x2d].
    Inputs:
     - x1dd: a lambdified Python function that calculates x1ddot as a function
         of x1, x2, x1d, x2d
     - x2dd: ditto for x2ddot
     - q: current value of our state vector
     
     implicitly, this dxdt() function takes in the 2 functions x1dd and x2dd - 
     they are not included in the arguments for compatibility with rk4() and euler()
     
     Returns: an array [x1d, x2d, x1dd, x2dd]
    '''
    #potential to turn this into a dictionary-type set of functions
    
    #calculate x1'' and x2'' based on current state values and sympy function
    #x1' and x2' are given
    return np.array(q[2], q[3], x1dd(*s), x2dd(*s))

q = [0.2, 0.25, 0.6, 0.7]
assert dxdt(0, q) == np.array([0.6, 0.7, -0.06, -0.02])

#using numerical solvers, integrate the system from time t_o to t_f,
#applying initial conditions


#how to set it up so that the function can take in a vector of x1 and x2, 
#then integrate to get acceleration x1d and x2d?

#should I be using dictionaries more than I currently am, rather than lists
#like in the state vector?
38/36:
#9. define our state vector 
q0 = np.array([0,0,0,0]) #x1, x2, x1d, x2d
qd0 = np.array([0,0,0,0]) #x1d, x2d, x1dd, x2dd

def dxdt(t, q):
    '''
    Derivative of our state vector at the given state [x1, x2, x1d, x2d].
    Inputs:
     - x1dd: a lambdified Python function that calculates x1ddot as a function
         of x1, x2, x1d, x2d
     - x2dd: ditto for x2ddot
     - q: current value of our state vector
     
     implicitly, this dxdt() function takes in the 2 functions x1dd and x2dd - 
     they are not included in the arguments for compatibility with rk4() and euler()
     
     Returns: an array [x1d, x2d, x1dd, x2dd]
    '''
    #potential to turn this into a dictionary-type set of functions
    
    #calculate x1'' and x2'' based on current state values and sympy function
    #x1' and x2' are given
    return np.array(q[2], q[3], x1dd(*s), x2dd(*s))

q = [0.2, 0.25, 0.6, 0.7]
assert dxdt(0, q) == np.array([0.6, 0.7, -0.06, -0.02])

#using numerical solvers, integrate the system from time t_o to t_f,
#applying initial conditions


#how to set it up so that the function can take in a vector of x1 and x2, 
#then integrate to get acceleration x1d and x2d?

#should I be using dictionaries more than I currently am, rather than lists
#like in the state vector?
38/37:
#9. define our state vector 
q0 = np.array([0,0,0,0]) #x1, x2, x1d, x2d
qd0 = np.array([0,0,0,0]) #x1d, x2d, x1dd, x2dd

def dxdt(t, q):
    '''
    Derivative of our state vector at the given state [x1, x2, x1d, x2d].
    Inputs:
     - x1dd: a lambdified Python function that calculates x1ddot as a function
         of x1, x2, x1d, x2d
     - x2dd: ditto for x2ddot
     - q: current value of our state vector
     
     implicitly, this dxdt() function takes in the 2 functions x1dd and x2dd - 
     they are not included in the arguments for compatibility with rk4() and euler()
     
     Returns: an array [x1d, x2d, x1dd, x2dd]
    '''
    #potential to turn this into a dictionary-type set of functions
    
    #calculate x1'' and x2'' based on current state values and sympy function
    #x1' and x2' are given
    return np.array(q[2], q[3], x1dd(*q), x2dd(*q))

q = [0.2, 0.25, 0.6, 0.7]
assert dxdt(0, q) == np.array([0.6, 0.7, -0.06, -0.02])

#using numerical solvers, integrate the system from time t_o to t_f,
#applying initial conditions


#how to set it up so that the function can take in a vector of x1 and x2, 
#then integrate to get acceleration x1d and x2d?

#should I be using dictionaries more than I currently am, rather than lists
#like in the state vector?
38/38:
#9. define our state vector 
q0 = np.array([0,0,0,0]) #x1, x2, x1d, x2d
qd0 = np.array([0,0,0,0]) #x1d, x2d, x1dd, x2dd

def dxdt(t, q):
    '''
    Derivative of our state vector at the given state [x1, x2, x1d, x2d].
    Inputs:
     - x1dd: a lambdified Python function that calculates x1ddot as a function
         of x1, x2, x1d, x2d
     - x2dd: ditto for x2ddot
     - q: current value of our state vector
     
     implicitly, this dxdt() function takes in the 2 functions x1dd and x2dd - 
     they are not included in the arguments for compatibility with rk4() and euler()
     
     Returns: an array [x1d, x2d, x1dd, x2dd]
    '''
    #potential to turn this into a dictionary-type set of functions
    
    #calculate x1'' and x2'' based on current state values and sympy function
    #x1' and x2' are given
    return np.array(q[2], q[3], x1dd_np(*q), x2dd_np(*q))

q = [0.2, 0.25, 0.6, 0.7]
assert dxdt(0, q) == np.array([0.6, 0.7, -0.06, -0.02])

#using numerical solvers, integrate the system from time t_o to t_f,
#applying initial conditions


#how to set it up so that the function can take in a vector of x1 and x2, 
#then integrate to get acceleration x1d and x2d?

#should I be using dictionaries more than I currently am, rather than lists
#like in the state vector?
38/39:
# You can start your implementation here :)

#1. grab variables
t = sym.symbols(r't') #independent variable
k1, k2, m1, m2 = sym.symbols(r'k1, k2, m1, m2') #constant

#2. define position, velocity, accel for masses 1 and 2 as functions
x1 = sym.Function(r'x1')(t)
x2 = sym.Function(r'x2')(t)

x1d = x1.diff('t')
x1dd = x1d.diff('t') #will need acceleration later
x2d = x2.diff('t')
x2dd = x2d.diff('t')

#define state of system
q = [x1, x2, x1d, x2d]

#3.  now write down an expression in terms of position and velocity
KE1 = (m1/2.0) * (x1d)**2
KE2 = (m2/2.0) * (x2d)**2
KE_sys = KE1 + KE2

U1  = (k1/2.0) * (x1) **2
U2  = (k2/2.0) * (x2 - x1) **2
U_sys = U1 + U2

lagrangian = KE_sys - U_sys
print('Lagrangian function:')
display(lagrangian)
38/40:
#9a. lambdify our acceleration functions so we can plug in values for them and solve
#substitute in our values of constants b/c we sure can't do it once they're in numpy
x1dd_sy = soln[0][qdd[0]]
x2dd_sy = soln[0][qdd[1]]

x1dd_sy = x1dd_sy.subs(consts_dict) #defined above
x2dd_sy = x2dd_sy.subs(consts_dict) #defined above

display(x1dd_sy)
display(x2dd_sy)

x1dd_np = sym.lambdify([q[0], q[1]], x1dd_sy) #lamd(vars, function)
x2dd_np = sym.lambdify([q[0], q[1]], x2dd_sy) #lamd(vars, function)
38/41:
#9a. lambdify our acceleration functions so we can plug in values for them and solve
#substitute in our values of constants b/c we sure can't do it once they're in numpy
x1dd_sy = soln[0][qdd[0]]
x2dd_sy = soln[0][qdd[1]]

x1dd_sy = x1dd_sy.subs(consts_dict) #defined above
x2dd_sy = x2dd_sy.subs(consts_dict) #defined above

display(x1dd_sy)
display(x2dd_sy)

x1dd_np = sym.lambdify([q[0], q[1]], x1dd_sy) #lamd(vars, function)
x2dd_np = sym.lambdify([q[0], q[1]], x2dd_sy) #lamd(vars, function)

print(x1dd_np)
38/42:
#9a. lambdify our acceleration functions so we can plug in values for them and solve
#substitute in our values of constants b/c we sure can't do it once they're in numpy
x1dd_sy = soln[0][qdd[0]]
x2dd_sy = soln[0][qdd[1]]

x1dd_sy = x1dd_sy.subs(consts_dict) #defined above
x2dd_sy = x2dd_sy.subs(consts_dict) #defined above

display(x1dd_sy)
display(x2dd_sy)

x1dd_np = sym.lambdify([q[0], q[1]], x1dd_sy) #lamd(vars, function)
x2dd_np = sym.lambdify([q[0], q[1]], x2dd_sy) #lamd(vars, function)

help(x1dd_np)
38/43:
#9. define our state vector 
q0 = np.array([0,0,0,0]) #x1, x2, x1d, x2d
qd0 = np.array([0,0,0,0]) #x1d, x2d, x1dd, x2dd

def dxdt(t, s):
    '''
    Derivative of our state vector at the given state [x1, x2, x1d, x2d].
    Inputs:
     - x1dd: a lambdified Python function that calculates x1ddot as a function
         of x1, x2, x1d, x2d
     - x2dd: ditto for x2ddot
     - q: current value of our state vector
     
     implicitly, this dxdt() function takes in the 2 functions x1dd and x2dd - 
     they are not included in the arguments for compatibility with rk4() and euler()
     
     Returns: an array [x1d, x2d, x1dd, x2dd]
    '''
    #potential to turn this into a dictionary-type set of functions
    
    #calculate x1'' and x2'' based on current state values and sympy function
    #x1' and x2' are given
    return np.array(s[2], s[3], x1dd_np(q[0], q[1]), x2dd_np(q[0], q[1])

q_sample = [0.2, 0.25, 0.6, 0.7]
assert dxdt(0, q_sample) == np.array([0.6, 0.7, -0.06, -0.02])

#using numerical solvers, integrate the system from time t_o to t_f,
#applying initial conditions


#how to set it up so that the function can take in a vector of x1 and x2, 
#then integrate to get acceleration x1d and x2d?

#should I be using dictionaries more than I currently am, rather than lists
#like in the state vector?
38/44:
#9. define our state vector 
q0 = np.array([0,0,0,0]) #x1, x2, x1d, x2d
qd0 = np.array([0,0,0,0]) #x1d, x2d, x1dd, x2dd

def dxdt(t, s):
    '''
    Derivative of our state vector at the given state [x1, x2, x1d, x2d].
    Inputs:
     - x1dd: a lambdified Python function that calculates x1ddot as a function
         of x1, x2, x1d, x2d
     - x2dd: ditto for x2ddot
     - q: current value of our state vector
     
     implicitly, this dxdt() function takes in the 2 functions x1dd and x2dd - 
     they are not included in the arguments for compatibility with rk4() and euler()
     
     Returns: an array [x1d, x2d, x1dd, x2dd]
    '''
    #potential to turn this into a dictionary-type set of functions
    
    #calculate x1'' and x2'' based on current state values and sympy function
    #x1' and x2' are given
    return np.array(s[2], s[3], x1dd_np(q[0], q[1]), x2dd_np(q[0], q[1]))

q_sample = [0.2, 0.25, 0.6, 0.7]
assert dxdt(0, q_sample) == np.array([0.6, 0.7, -0.06, -0.02])

#using numerical solvers, integrate the system from time t_o to t_f,
#applying initial conditions


#how to set it up so that the function can take in a vector of x1 and x2, 
#then integrate to get acceleration x1d and x2d?

#should I be using dictionaries more than I currently am, rather than lists
#like in the state vector?
38/45:
#9. define our state vector 
q0 = np.array([0,0,0,0]) #x1, x2, x1d, x2d
qd0 = np.array([0,0,0,0]) #x1d, x2d, x1dd, x2dd

def dxdt(t, s):
    '''
    Derivative of our state vector at the given state [x1, x2, x1d, x2d].
    Inputs:
     - x1dd: a lambdified Python function that calculates x1ddot as a function
         of x1, x2, x1d, x2d
     - x2dd: ditto for x2ddot
     - q: current value of our state vector
     
     implicitly, this dxdt() function takes in the 2 functions x1dd and x2dd - 
     they are not included in the arguments for compatibility with rk4() and euler()
     
     Returns: an array [x1d, x2d, x1dd, x2dd]
    '''
    #potential to turn this into a dictionary-type set of functions
    
    #calculate x1'' and x2'' based on current state values and sympy function
    #x1' and x2' are given
    return np.array([s[2], s[3], x1dd_np(q[0], q[1]), x2dd_np(q[0], q[1])])

q_sample = [0.2, 0.25, 0.6, 0.7]
assert dxdt(0, q_sample) == np.array([0.6, 0.7, -0.06, -0.02])

#using numerical solvers, integrate the system from time t_o to t_f,
#applying initial conditions


#how to set it up so that the function can take in a vector of x1 and x2, 
#then integrate to get acceleration x1d and x2d?

#should I be using dictionaries more than I currently am, rather than lists
#like in the state vector?
38/46:
#9. define our state vector 
q0 = np.array([0,0,0,0]) #x1, x2, x1d, x2d
qd0 = np.array([0,0,0,0]) #x1d, x2d, x1dd, x2dd

def dxdt(t, s):
    '''
    Derivative of our state vector at the given state [x1, x2, x1d, x2d].
    Inputs:
     - x1dd: a lambdified Python function that calculates x1ddot as a function
         of x1, x2, x1d, x2d
     - x2dd: ditto for x2ddot
     - q: current value of our state vector
     
     implicitly, this dxdt() function takes in the 2 functions x1dd and x2dd - 
     they are not included in the arguments for compatibility with rk4() and euler()
     
     Returns: an array [x1d, x2d, x1dd, x2dd]
    '''
    #potential to turn this into a dictionary-type set of functions
    
    #calculate x1'' and x2'' based on current state values and sympy function
    #x1' and x2' are given
    return np.array([s[2], s[3], x1dd_np(q[0], q[1]), x2dd_np(q[0], q[1])])

q_sample = [0.2, 0.25, 0.6, 0.7]
assert dxdt(0, q_sample).all() == np.array([0.6, 0.7, -0.06, -0.02]).all()

#using numerical solvers, integrate the system from time t_o to t_f,
#applying initial conditions


#how to set it up so that the function can take in a vector of x1 and x2, 
#then integrate to get acceleration x1d and x2d?

#should I be using dictionaries more than I currently am, rather than lists
#like in the state vector?
38/47:
#9. define our state vector 
q0 = np.array([0,0,0,0]) #x1, x2, x1d, x2d
qd0 = np.array([0,0,0,0]) #x1d, x2d, x1dd, x2dd

def dxdt(t, s):
    '''
    Derivative of our state vector at the given state [x1, x2, x1d, x2d].
    Inputs:
     - x1dd: a lambdified Python function that calculates x1ddot as a function
         of x1, x2, x1d, x2d
     - x2dd: ditto for x2ddot
     - q: current value of our state vector
     
     implicitly, this dxdt() function takes in the 2 functions x1dd and x2dd - 
     they are not included in the arguments for compatibility with rk4() and euler()
     
     Returns: an array [x1d, x2d, x1dd, x2dd]
    '''
    #potential to turn this into a dictionary-type set of functions
    
    #calculate x1'' and x2'' based on current state values and sympy function
    #x1' and x2' are given
    return np.array([s[2], s[3], x1dd_np(q[0], q[1]), x2dd_np(q[0], q[1])])

q_sample = [0.2, 0.25, 0.6, 0.7]
out = dxdt(0, q_sample)
assert out.all() == np.array([0.6, 0.7, -0.06, -0.02]).all(), f"Output of dxdt: {out}"

#using numerical solvers, integrate the system from time t_o to t_f,
#applying initial conditions


#how to set it up so that the function can take in a vector of x1 and x2, 
#then integrate to get acceleration x1d and x2d?

#should I be using dictionaries more than I currently am, rather than lists
#like in the state vector?
39/1:
#9. define our state vector 
q0 = np.array([0,0,0,0]) #x1, x2, x1d, x2d
qd0 = np.array([0,0,0,0]) #x1d, x2d, x1dd, x2dd

def dxdt(t, s):
    '''
    Derivative of our state vector at the given state [x1, x2, x1d, x2d].
    Inputs:
     - x1dd: a lambdified Python function that calculates x1ddot as a function
         of x1, x2, x1d, x2d
     - x2dd: ditto for x2ddot
     - q: current value of our state vector
     
     implicitly, this dxdt() function takes in the 2 functions x1dd and x2dd - 
     they are not included in the arguments for compatibility with rk4() and euler()
     
     Returns: an array [x1d, x2d, x1dd, x2dd]
    '''
    #potential to turn this into a dictionary-type set of functions
    
    #calculate x1'' and x2'' based on current state values and sympy function
    #x1' and x2' are given
    return np.array([s[2], s[3], x1dd_np(q[0], q[1]), x2dd_np(q[0], q[1])])

help(x1dd_np)
help(x2dd_np)

q_sample = [0.2, 0.25, 0.6, 0.7]
out = dxdt(0, q_sample)
assert out.all() == np.array([0.6, 0.7, -0.06, -0.02]).all(), f"Output of dxdt: {out}"

#using numerical solvers, integrate the system from time t_o to t_f,
#applying initial conditions


#how to set it up so that the function can take in a vector of x1 and x2, 
#then integrate to get acceleration x1d and x2d?

#should I be using dictionaries more than I currently am, rather than lists
#like in the state vector?
39/2:
#9. define our state vector 
q0 = np.array([0,0,0,0]) #x1, x2, x1d, x2d
qd0 = np.array([0,0,0,0]) #x1d, x2d, x1dd, x2dd

def dxdt(t, s):
    '''
    Derivative of our state vector at the given state [x1, x2, x1d, x2d].
    Inputs:
     - x1dd: a lambdified Python function that calculates x1ddot as a function
         of x1, x2, x1d, x2d
     - x2dd: ditto for x2ddot
     - q: current value of our state vector
     
     implicitly, this dxdt() function takes in the 2 functions x1dd and x2dd - 
     they are not included in the arguments for compatibility with rk4() and euler()
     
     Returns: an array [x1d, x2d, x1dd, x2dd]
    '''
    #potential to turn this into a dictionary-type set of functions
    
    #calculate x1'' and x2'' based on current state values and sympy function
    #x1' and x2' are given
    return np.array([s[2], s[3], x1dd_np(q[0], q[1]), x2dd_np(q[0], q[1])])

help(x1dd_np)
help(x2dd_np)

q_sample = [0.2, 0.25, 0.6, 0.7]
out = dxdt(0, q_sample)
assert out.all() == np.array([0.6, 0.7, -0.06, -0.02]).all(), f"Output of dxdt: {out}"

#using numerical solvers, integrate the system from time t_o to t_f,
#applying initial conditions


#how to set it up so that the function can take in a vector of x1 and x2, 
#then integrate to get acceleration x1d and x2d?

#should I be using dictionaries more than I currently am, rather than lists
#like in the state vector?
   1:
#IMPORT ALL NECESSARY PACKAGES AT THE TOP OF THE CODE
import sympy as sym
import numpy as np
import matplotlib.pyplot as plt

from IPython.display import Markdown, display
   2:
# for google colab only

# def custom_latex_printer(exp,**options):
#     from google.colab.output._publish import javascript
#     url = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.1.1/latest.js?config=TeX-AMS_HTML"
#     javascript(url=url)
#     return sym.printing.latex(exp,**options)
# sym.init_printing(use_latex="mathjax",latex_printer=custom_latex_printer)
   3:
from IPython.core.display import HTML
display(HTML("<table><tr><td><img src='https://github.com/MuchenSun/ME314pngs/raw/master/2mass_spring.png' width=500' height='350'></table>"))
   4:
# # from sympy.abc import x, y, z or
# x,y,z = sym.symbols(r'x,y,z')
# expr = sym.sin(x) * y**2 * z + x*z + x/z**2
# print('\033[1mExample expression: ')
# display(expr)

# # method 1: the numerical function will take variables one by one
# func = sym.lambdify([x, y, z], expr)
# print('\n\033[1mTest at x=1, y=2, z=3: \033[0m{:.2f}'.format(func(1, 2, 3)))

# # method 2: the numerical function will take variables cotained in one list/array
# func = sym.lambdify([[x, y, z]], expr)
# print('\033[1mTest at x=1, y=2, z=3: \033[0m{:.2f}'.format(func([1, 2, 3])))
   5:
# You can start your implementation here :)

#1. grab variables
x1, x2 = sym.symbols(r'x1, x2') #state variables
k1, k2, m1, m2 = sym.symbols(r'k1, k2, m1, m2') # constants
x1dd = sym.Function('x1') 
x2dd = sym.Function('x2')

#2. write expressions of x1** and x2** in terms of state variables
x1dd = (1/m1) * (k2 * x2) - (1/m1) * (k1 + k2) * x1
x2dd = -(k2/m2) * (x2 - x1)

print("Acceleration for mass 1:")
display(x1dd)
print("Acceleration for mass 2:")
display(x2dd)

consts_dict = {
    k1: 0.5,
    k2: 0.8,
    m1: 1,
    m2: 2
}

#3. subs()titute in values for things
accel1 = x1dd.subs(consts_dict) #all in SI units; N/m and kg
accel2 = x2dd.subs(consts_dict) #all in SI units; N/m and kg

#4. lambdify functions and input values, method 1: take variables one by one

npaccel1 = sym.lambdify([x1, x2], accel1)
npaccel2 = sym.lambdify([x1, x2], accel2)

ans1 = npaccel1(1, 3)
ans2 = npaccel2(1, 3)

#check NP answer with hand calcs
assert np.isclose(ans1, 1.1), f"Accel 1: {ans1}" 
assert np.isclose(ans2, -0.8), f"Accel 2: {ans2}"
   6:
# t = sym.symbols('t')
# # define position as function of t
# x1 = sym.Function(r'x_1')(t)
# # define velocity as derivative of position wrt t
# x1dot = x1.diff(t)
# # define acceleration as derivative of velocity wrt t
# x1ddot = x1dot.diff(t)

# # now write down an expression in terms of position and velocity
# expr = x1**2 + x1*x1dot
# print('\033[1mExample expression: ')
# display(expr)
# # you can take the derivative of this expression wrt to time t
# expr_dt = expr.diff(t)
# print('\n\033[1mDerivative of expression w.r.t. time (t): ')
# display(expr_dt)
# # or you can take the derivative wrt the functions: x, xdot, xddot
# expr_dx = expr.diff(x1)
# print('\n\033[1mDerivative of expression w.r.t. x1(t): ')
# display(expr_dx)
   7:
# You can start your implementation here :)

#1. grab variables
t = sym.symbols(r't') #independent variable
k1, k2, m1, m2 = sym.symbols(r'k1, k2, m1, m2') #constant

#2. define position, velocity, accel for masses 1 and 2 as functions
x1 = sym.Function(r'x1')(t)
x2 = sym.Function(r'x2')(t)

x1d = x1.diff('t')
x1dd = x1d.diff('t') #will need acceleration later
x2d = x2.diff('t')
x2dd = x2d.diff('t')

#define state of system
q = [x1, x2, x1d, x2d]

#3.  now write down an expression in terms of position and velocity
KE1 = (m1/2.0) * (x1d)**2
KE2 = (m2/2.0) * (x2d)**2
KE_sys = KE1 + KE2

U1  = (k1/2.0) * (x1) **2
U2  = (k2/2.0) * (x2 - x1) **2
U_sys = U1 + U2

lagrangian = KE_sys - U_sys
print('Lagrangian function:')
display(lagrangian)
   8:
# print('\033[1mDifferent ways of taking the derivative of the Lagrangian with respect ot the system state vector (q)')
# t = sym.symbols('t')

# # define two system states as functions
# x1 = sym.Function(r'x_1')(t)
# x2 = sym.Function(r'x_2')(t)
# # wrap system states into one vector (in SymPy would be Matrix)
# q = sym.Matrix([x1, x2])
# # define an expression in terms of x1(t) and x2(t)
# J = sym.sin(x1**2) + sym.cos(x2)**2
# print('\n\033[1mExample expression ')
# display(J)

# # compute derivative wrt a vector, method 1
# # wrap the expression into a SymPy Matrix
# J_mat = sym.Matrix([J])
# # SymPy Matrix has built-in method for Jacobian
# dJdq = J_mat.jacobian(q)
# print('\n\033[1mMethod: built-in Jacobian derivative')
# display(dJdq) # note that dJdq is 1-by-2 vector, not 2-by-1 as q

# # compute derivative wrt a vector, method 2: do it one by one
# dJdx1 = J.diff(x1)
# dJdx2 = J.diff(x2)
# dJdq = sym.Matrix([dJdx1, dJdx2]).T # transpose so dimension can match
# print('\n\033[1mMethod: one-by-one')
# display(dJdq)

# # compute derivative wrt a vector, method 3: do it one by one ... but in a "fancy" way
# dJdq = []
# for x in q:
#     dJdq.append(J.diff(x))
# dJdq = sym.Matrix([dJdq])
# print('\n\033[1mMethod: for loop')
# display(dJdq)
   9:
# x,y = sym.symbols(r'x,y')
# # define left hand side as a matrix
# lhs = sym.Matrix([x**2+y, x+y])

# # define right hand side as a Matrix
# rhs = sym.Matrix([3, 1])

# # define the equations
# eqn = sym.Eq(lhs, rhs)

# # solve it for both x and y
# q = sym.Matrix([x, y])
# soln = sym.solve(eqn, q, dict=True) # this will return the solution 
#                                      # as a Python dictionary
# for sol in soln:
#     print('\n\033[1mSolution: ')
#     for v in q:
#         display(sym.Eq(v, sol[v]))
  10:
# You can start your implementation here :)

#purpose of this step: have sympy simplify the equation to give the acceleration of objects.
#this lets us integrate to give v and x as a function of t in next steps

# 8. solve equation and display result
eqn = sym.Eq(LHS.T, RHS.T)

print("Equation:")
display(eqn)

soln = sym.solve(eqn, qdd, dict = True)

print("Solution: ")
for sol in soln:
    for x in qdd:
        display(sym.Eq(x, sol[x]))
    
print("These acceleration equations match what I found via written analysis.")
  11: %history -g -f filename
